---
title: Connection Pool Jdbc
tags:
  - jdbc
  - PostgreSql
related_topics: 
created: 2025-04-29 14:54
modified: 2025-04-29T16:36:32+03:00
questions: 
notes: 
links: 
---


------
 






------------
![[Pasted image 20250429160143.png]]


# Connection pooling в PostgreSQL и Java

## Теория и демонстрация кода на чистом JDBC и Spring Boot

Connection pooling – это механизм повторного использования открытых соединений с базой данных вместо их постоянного создания и уничтожения. Он позволяет существенно снизить накладные расходы на подключение к СУБД, что критично при большом числе запросов. Например, без пула при каждой операции `DriverManager.getConnection(...)` Java будет устанавливать новое TCP-соединение и авторизовываться в БД, что медленно. Ниже показан пример кода на чистом JDBC без пула:

```java
String url = "jdbc:postgresql://localhost:5432/mydb";
String user = "postgres";
String pass = "secret";

// Прямое подключение без пула
try (Connection conn = DriverManager.getConnection(url, user, pass)) {
    PreparedStatement ps = conn.prepareStatement("SELECT * FROM users WHERE active = true");
    ResultSet rs = ps.executeQuery();
    while (rs.next()) {
        // обработка результата
    }
}

```

В Spring Boot и других фреймворках вместо `DriverManager` обычно используется DataSource, который управляет пулом. Например, с HikariCP конфигурируется DataSource:

```java
HikariConfig config = new HikariConfig();
config.setJdbcUrl("jdbc:postgresql://localhost:5432/mydb");
config.setUsername("postgres");
config.setPassword("secret");
config.setMaximumPoolSize(10); // размер пула
HikariDataSource ds = new HikariDataSource(config);

// Использование пула:
try (Connection conn = ds.getConnection()) {
    // Работа с соединением из пула
    PreparedStatement ps = conn.prepareStatement("INSERT INTO logs(message) VALUES(?)");
    ps.setString(1, "log msg");
    ps.executeUpdate();
}
```

В Spring Boot достаточно задать в `application.properties` или `application.yml` параметры `spring.datasource.*`, и пул (по умолчанию HikariCP) будет создан автоматически. Пример конфигурации в `application.yml`:

```java
spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/mydb
    username: postgres
    password: secret
    hikari:
      maximum-pool-size: 20
      minimum-idle: 5
      idle-timeout: 300000    # 5 minutes
      max-lifetime: 1800000   # 30 minutes
      connection-timeout: 30000  # 30 seconds

```

Spring Boot с версий 2.x по умолчанию использует HikariCP как пул соединений, обеспечивая «нулевые накладные расходы» и высокую производительность​[github.com](https://github.com/brettwooldridge/HikariCP#:~:text=Fast%2C%20simple%2C%20reliable,how%20we%20do%20it%20here). Код выше демонстрирует, как пул позволяет брать соединения из готового набора вместо постоянной их инициализации.

----

## Основные задачи, которые решает connection pool

- **Повышение производительности:** повторное использование существующих соединений сокращает время на установку соединения (TCP handshake, аутентификация и т. д.). HikariCP позиционируется как «быстрый, простой, надёжный» пул с минимальными накладными расходами​[github.com](https://github.com/brettwooldridge/HikariCP#:~:text=Fast%2C%20simple%2C%20reliable,how%20we%20do%20it%20here).
    
- **Ограничение ресурсов:** пул задаёт `maximumPoolSize` – максимальное число одновременных соединений к БД. Это предотвращает ситуации, когда Java-приложение спамит базу слишком большим количеством соединений. При исчерпании пула вызов `getConnection()` ждёт до `connectionTimeout`, а затем выдаёт исключение​[github.com](https://github.com/brettwooldridge/HikariCP#:~:text=,Default%3A%2010).
    
- **Управление временем простоя:** параметры `idleTimeout` и `maxLifetime` в HikariCP позволяют автоматически закрывать долго простаивающие или старые соединения​[github.com](https://github.com/brettwooldridge/HikariCP#:~:text=%E2%8F%B3,Default%3A%20600000%20%2810)​[github.com](https://github.com/brettwooldridge/HikariCP#:~:text=,Default%3A%2010). Это предотвращает накапливание «зомби»-соединений.
    
- **Повышение надёжности:** пул отслеживает проблемные соединения и может обнаруживать «утечки» соединений (пул не вернул соединение вовремя) с помощью `leakDetectionThreshold`​[github.com](https://github.com/brettwooldridge/HikariCP#:~:text=%E2%8F%B3,Default%3A%200). Также HikariCP может выполнять тестирование соединения перед выдачей (`connectionTestQuery` или `isValid()`) для гарантии живости соединения​[github.com](https://github.com/brettwooldridge/HikariCP#:~:text=%E2%8F%B3,Default%3A%205000).
    
- **Мониторинг и диагностика:** большинство пулов (включая HikariCP) экспортируют метрики (число активных/свободных соединений, скорость выдачи/возврата и т. д.) через JMX или Micrometer. Это упрощает отслеживание состояния пула и выявление проблем.
    

Таким образом, основная задача пула – обеспечить эффективное и контролируемое использование соединений к базе данных при высокой нагрузке, избавляя приложение от лишних задержек и ошибок при исчерпании соединений​[github.com](https://github.com/brettwooldridge/HikariCP#:~:text=Fast%2C%20simple%2C%20reliable,how%20we%20do%20it%20here)​[github.com](https://github.com/brettwooldridge/HikariCP#:~:text=,Default%3A%2010).

## Устройство HikariCP

HikariCP – современный высокопроизводительный пул, ориентированный на «минимализм» и оптимизацию. Рассмотрим ключевые аспекты его работы:

- **Выдача соединений:** при вызове `HikariDataSource.getConnection()` пул выдаёт готовое соединение из пула. Если свободных соединений нет, но общее число меньше `maximumPoolSize`, пул быстро создаст новое соединение. Если пул уже достиг максимального размера и свободных соединений нет, вызов будет ждать не дольше, чем `connectionTimeout`. По истечении `connectionTimeout` генерируется `SQLException`​[github.com](https://github.com/brettwooldridge/HikariCP#:~:text=,Default%3A%2010). Таким образом, HikariCP гарантирует, что приложение либо получит соединение, либо упадёт с ощибкой при перегрузке.
    
- **Очистка idle-соединений:** параметры `idleTimeout`, `maxLifetime` и `keepaliveTime` управляют удалением неиспользуемых соединений​[github.com](https://github.com/brettwooldridge/HikariCP#:~:text=%E2%8F%B3,Default%3A%20600000%20%2810%20minutes)​[github.com](https://github.com/brettwooldridge/HikariCP#:~:text=%E2%8F%B3,millisecond%2C%20and%20therefore)​[github.com](https://github.com/brettwooldridge/HikariCP#:~:text=%E2%8F%B3,Default%3A%201800000%20%2830%20minutes). По умолчанию `idleTimeout` = 10 минут: соединения, простаивающие дольше этого времени, могут удаляться из пула, если их число превышает `minimumIdle`. Параметр `maxLifetime` (по умолчанию 30 минут) задаёт максимальный возраст соединения: после этого срока соединение будет принудительно закрыто после выхода из пула​[github.com](https://github.com/brettwooldridge/HikariCP#:~:text=%E2%8F%B3,Default%3A%201800000%20%2830%20minutes). Параметр `keepaliveTime` позволяет время от времени «пропинговать» долго простоявшие соединения, чтобы не дать им разорваться по таймауту сети​[github.com](https://github.com/brettwooldridge/HikariCP#:~:text=%E2%8F%B3,millisecond%2C%20and%20therefore).
    
- **Мониторинг и JMX:** HikariCP может экспортировать метрики для инструментов мониторинга. При включении параметра `registerMbeans=true` пул регистрируется в JMX (по умолчанию отключено)​[github.com](https://github.com/brettwooldridge/HikariCP#:~:text=%E2%9D%8E,Default%3A%20false). Кроме того, пул поддерживает интеграцию с Dropwizard/Prometheus (через `metricRegistry` или Spring Boot Actuator). В метриках обычно присутствуют счётчики активных и свободных соединений, число заблокированных потоков, статистика по времени ожидания и т. п. HikariCP также умеет логировать возможные утечки соединений с помощью `leakDetectionThreshold` (порог тревоги по времени удержания соединения)​[github.com](https://github.com/brettwooldridge/HikariCP#:~:text=%E2%8F%B3,Default%3A%200).
    
- **Минимализм дизайна:** у HikariCP меньше «навороченных» свойств, чем у старых пулов. Например, HikariCP **не** кэширует `PreparedStatement` на стороне пула (хотя многие другие пулы, такие как DBCP или c3p0, предоставляют такое кэширование)​[github.com](https://github.com/brettwooldridge/HikariCP#:~:text=Many%20connection%20pools%2C%20including%20Apache,Why). Разработчик Hikari объясняет это тем, что кэширование лучше оставлять на стороне драйвера или СУБД​[github.com](https://github.com/brettwooldridge/HikariCP#:~:text=Many%20connection%20pools%2C%20including%20Apache,Why).
    

Все эти особенности делают HikariCP очень быстрым и при этом надёжным решением. Внутренне HikariCP оптимизирован на уровне байткода и использует тонкие оптимизации, чтобы операции выдачи и возврата соединений выполнялись максимально быстро​[github.com](https://github.com/brettwooldridge/HikariCP/wiki/Down-the-Rabbit-Hole#:~:text=performance%20equation,etc).

## Сравнение HikariCP с Apache DBCP и C3P0

HikariCP традиционно считается наиболее производительным пулом среди Java-решений. В нескольких независимых тестах и обзорах было показано, что старые реализации, такие как Apache DBCP (Commons DBCP2) и c3p0, заметно отстают по скорости и устойчивости. Например, в бенчмарке HikariCP обнаружилась проблема у DBCP – при нагрузке пул DBCP вовсе не завершал тест из-за долгих пауз сборщика мусора​[github.com](https://github.com/brettwooldridge/HikariCP#:~:text=,to%20excessive%20garbage%20collection%20times). HikariCP же успешно справился с аналогичной нагрузкой, демонстрируя низкую задержку на выдачу соединений.

Основные отличия:

- **Производительность:** HikariCP оптимизирован с учётом современных JVM и процессоров, минимизируя накладные расходы на синхронизацию и сбор мусора. По данным авторов, большинство выигрыша даёт не сам пул соединений, а оптимизированная обёртка над объектами `Connection`, `Statement` и т. д.​[github.com](https://github.com/brettwooldridge/HikariCP/wiki/Down-the-Rabbit-Hole#:~:text=performance%20equation,etc). Apache DBCP и c3p0 были разработаны раньше и показывают более высокие накладные расходы при интенсивных операциях.
    
- **Надёжность:** HikariCP уделяет внимание стабильному поведению при сбоях и масштабируемости. У DBCP известны проблемы с «утечками» при высоких нагрузках (см. примеры с невозможностью завершить бенчмарк​[github.com](https://github.com/brettwooldridge/HikariCP#:~:text=,to%20excessive%20garbage%20collection%20times)), а c3p0 давно считается устаревшим и медленным. В продакшене современные сообщества практикуют HikariCP как стандартный пул (например, в Spring Boot), тогда как DBCP и c3p0 используются всё реже.
    
- **Функциональность:** DBCP и c3p0 предлагали дополнительные возможности – например, кэширование `PreparedStatement` и множество конфигурационных опций. HikariCP сознательно отказывается от некоторых «наворотов» ради простоты и надёжности​[github.com](https://github.com/brettwooldridge/HikariCP#:~:text=HikariCP%20has%20plenty%20of%20,axis%20are%20intentionally%20left%20out)​[github.com](https://github.com/brettwooldridge/HikariCP#:~:text=Many%20connection%20pools%2C%20including%20Apache,Why). При этом HikariCP покрывает все базовые потребности: конфигурируемый размер пула, таймауты, валидацию, экспорт метрик и т.д.
    
- **Конфигурация:** HikariCP имеет более «разумные» настройки по умолчанию и меньше скрытых «подводных камней». Многие рекомендуют не изменять `minimumIdle` (оставить по умолчанию равным `maximumPoolSize`), чтобы пул вел себя как фиксированного размера​[github.com](https://github.com/brettwooldridge/HikariCP#:~:text=,Default%3A%20same%20as%20maximumPoolSize). В DBCP и c3p0 настройка может требовать более тонкой юстировки для достижения схожей производительности.
    

Таким образом, для современных приложений HikariCP обычно предпочтительнее из-за своей скорости и простоты. Однако в редких случаях (например, если требуется специфичный функционал кэширования в рамках пула) могут быть рассмотрены DBCP2 или c3p0.

## Best practices настройки HikariCP для продакшена

Для надёжной работы в реальных условиях рекомендуются следующие практики:

- **Размер пула:** `maximumPoolSize` следует выбирать исходя из возможностей БД и нагрузки приложения. Часто ориентиром служит число ядер CPU или ожидаемое число конкурентных запросов. При использовании микросервисов нужно суммарно рассчитывать число соединений от всех сервисов (может потребоваться PgBouncer, см. ниже).
    
- **`maxLifetime` и `idleTimeout`:** устанавливайте `maxLifetime` немного ниже любого сетевого или БД-таймаута (например, если PostgreSQL порождает свои лимиты на несколько часов, задайте `maxLifetime = 30 минут`). Это позволяет избежать ситуаций, когда СУБД внезапно закрывает соединение из-за старости, а пул этого не заметил. `idleTimeout` настраивается, чтобы не держать слишком много неиспользуемых соединений, обычно 5–10 минут.
    
- **`minimumIdle`:** рекомендуют не принудительно задавать `minimumIdle` выше нуля, чтобы избежать «резкого роста» пула. По умолчанию `minimumIdle = maximumPoolSize`, что фактически делает пул фиксированного размера​[github.com](https://github.com/brettwooldridge/HikariCP#:~:text=,Default%3A%20same%20as%20maximumPoolSize). Если нужно сэкономить ресурсы, можно уменьшить `minimumIdle`, позволяя пулу уменьшаться при отсутствии нагрузки.
    
- **`connectionTimeout`:** лучше поставить разумно короткий (несколько секунд) – чтобы приложение быстро узнавал о проблеме нехватки соединений. Слишком длинный таймаут может привести к тому, что запросы будут долго «подвисать» вместо быстрого провала.
    
- **Диагностика утечек:** во время тестирования можно включить `leakDetectionThreshold` (например, несколько секунд) для выявления кода, который забывает закрывать соединения​[github.com](https://github.com/brettwooldridge/HikariCP#:~:text=%E2%8F%B3,Default%3A%200). В продакшене этот параметр обычно отключают (`0`), чтобы не влиять на производительность.
    
- **Keep-alive TCP:** иногда сети или БД могут убивать неактивные соединения. Рекомендуется использовать TCP_KEEPALIVE на уровне ОС или свойства драйвера (`tcpKeepAlive=true` для PostgreSQL), чтобы пул периодически «пробуждал» соединения​[github.com](https://github.com/brettwooldridge/HikariCP#:~:text=In%20order%20to%20avoid%20a,for%20a%20better%20PostgreSQL%20experience).
    
- **Мониторинг:** активно используйте метрики пула. Spring Boot Actuator автоматически собирает статистику HikariCP (например, `hikaricp_connections_active`, `hikaricp_connections_idle`, `hikaricp_connections_pending` и др.), которые можно визуализировать в Grafana через Prometheus или другой бэкенд. При настройке убедитесь, что метрики включены и доступны.

```java
# Пример рекомендуемых параметров HikariCP в production
spring:
  datasource:
    hikari:
      maximum-pool-size: 15
      minimum-idle: 5
      idle-timeout: 300000      # 5 минут
      max-lifetime: 1800000     # 30 минут
      connection-timeout: 5000  # 5 секунд
      leak-detection-threshold: 0

```

В итоге ключевое – сбалансировать размер пула и таймауты под нагрузку приложения и ограничения СУБД. Правильная настройка позволяет избежать «узких мест» и сделать систему устойчивой.

## Обзор стандартных пулов на стороне PostgreSQL: PgBouncer и Pgpool-II

Помимо Java-пулов, существуют внешние прокси-пулы для PostgreSQL, которые работают на стороне сервера:

- **PgBouncer:** очень лёгкий, популярный пул соединений. Он работает как отдельный сервер-прокси между приложением и СУБД. Преимущества PgBouncer: малое потребление памяти, простая настройка, несколько режимов работы (режимы `session`, `transaction`, `statement` pooling). В режиме _transaction pooling_ одно физическое соединение к БД используется для каждой транзакции; между транзакциями приложение может работать через другое. Это позволяет дополнительно снижать потребление соединений при высокой нагрузке. PgBouncer обычно разворачивают как отдельный контейнер или сервис. Пример Docker Compose для PgBouncer:

```java
version: '3'
services:
  pgbouncer:
    image: edoburu/pgbouncer
    environment:
      - DATABASE_URL=postgresql://postgres:secret@db:5432/mydb
      - POOL_MODE=transaction
      - MAX_CLIENT_CONN=100
      - DEFAULT_POOL_SIZE=20
      - AUTH_TYPE=md5
      - AUTH_FILE=/config/users.txt
    volumes:
      - ./pgbouncer.ini:/etc/pgbouncer/pgbouncer.ini
      - ./users.txt:/etc/pgbouncer/users.txt
    ports:
      - "6432:6432"

```

В этом примере настроен PgBouncer на 100 клиентских подключений и 20 соединений к базе. Файл `users.txt` содержит хэши паролей для пользователей.

- **Pgpool-II:** более функциональное, но и более «тяжёлое» решение. Помимо пуллинга соединений, Pgpool-II может выполнять балансировку нагрузки между несколькими мастером и репликами, поддерживать репликацию (query routing), проводить автоматический failover и т.д. Однако такая универсальность делает Pgpool-II сложнее в настройке и сопровождающей инфарструктуре.
    

PgBouncer и Pgpool-II работают на уровне сети: к ним можно подключаться с обычными PostgreSQL-драйверами по тому же JDBC-URL (порт 6432, 5432 и т. д.). Основные отличия от Java-пулов: они обрабатывают пуллинг между клиентами и сервером, а не внутри приложения. Обычно их настраивают через конфигурационные файлы (или переменные окружения в Docker).

## Подробное сравнение Java-пулов и пулов на стороне PostgreSQL

Сравнивая внутренние (Java) пулы и внешние (PostgreSQL), важно понимать разные задачи, которые они решают:

- **Контекст использования:** Java-пул (Hikari, DBCP, c3p0) работает внутри вашего приложения и управляет соединениями именно в этом процессе. Каждый экземпляр приложения имеет свой собственный пул. В микросервисной архитектуре это значит, что суммарное число соединений к БД равно `poolSize × количество сервисов × количество реплик` сервисов. Внешний пул (PgBouncer/Pgpool) служит единым точкам входа для всех клиентов, объединяя их соединения на стороне БД.
    
- **Режимы работы:** Java-пул всегда «сессионный»: соединение выдается приложению и возвращается только при `close()`. PgBouncer в _transaction mode_ возвращает соединение после каждой транзакции, что позволяет одним физическим соединением обслуживать множество мелких запросов. Такой режим может существенно экономить ресурсы сервера при большой конкуренции, но требует, чтобы все запросы были корректно обернуты в транзакции.
    
- **Производительность:** Java-пул экономит время на открытие соединения внутри процесса JVM, но каждая сессия по-прежнему установлена и удерживается на PostgreSQL (использует ресурсы сервера: память, процессы). Внешний пул позволяет уменьшить число одновременных сессий на стороне БД. Это особенно полезно, если база имеет ограничения по максимальному числу процессов.
    
- **Надёжность и отказоустойчивость:** PgBouncer/Pgpool можно перезапускать независимо от приложения и масштабировать отдельно. Java-пул привязан к жизненному циклу приложения – при падении приложения все соединения закрываются разом. С другой стороны, Java-пул проще «горизонтально масштабировать» при росте нагрузки (каждый новый инстанс приложения добавляет свой пул).
    
- **Настройка и мониторинг:** HikariCP легко конфигурируется в приложении. PgBouncer настраивается через собственный конфиг (`pgbouncer.ini`), обычно развертывается как отдельный сервис/контейнер. Оба рода пулов имеют метрики для мониторинга.
    

В общем, Java-пул удобен для управления соединениями на уровне приложения, тогда как внешние пулы помогают контролировать нагрузку на сервер и масштабировать доступ к БД между несколькими клиентами. Часто применяют комбинацию: например, каждый микросервис использует HikariCP, а сам сервер БД обслуживается PgBouncer для дополнительных «надёжности» и «экономии» соединений.

## Устройство JDBC-драйвера PostgreSQL и его сравнение с HikariCP

JDBC-драйвер PostgreSQL (org.postgresql.Driver) обеспечивает низкоуровневую работу с БД: сетевой протокол, аутентификацию, выполнение SQL. Однако сам по себе драйвер не занимается пуллингом – каждый вызов `DriverManager.getConnection()` открывает новое соединение на стороне БД. Пул (например, HikariCP) оборачивает вызовы драйвера, скрывая детали.

В деталях: драйвер PostgreSQL устанавливает TCP-сокет, обменивается протоколом с сервером, отдает SQL и возвращает результаты. При закрытии `Connection` драйвер разрывает сетевой канал. HikariCP может создавать экземпляры `PGConnection` через драйвер и переиспользовать их, но код драйвера (например, `PGSimpleDataSource`) сам по себе не кэширует соединения.

Есть несколько моментов, где драйвер и пул пересекаются:

- **Настройки драйвера:** драйвер поддерживает такие опции, как `tcpKeepAlive=true`, `ApplicationName`, `socketTimeout` и т.д. Эти параметры влияют на долгоживущие соединения. Например, включение `tcpKeepAlive` может предотвратить случайные сбросы соединений маршрутизатором​[github.com](https://github.com/brettwooldridge/HikariCP#:~:text=In%20order%20to%20avoid%20a,for%20a%20better%20PostgreSQL%20experience). HikariCP советует использовать такие настройки на уровне драйвера или ОС для дополнительной стабильности.
    
- **Инициализация соединений:** драйвер позволяет задать SQL для выполнения при открытии (через `connectionInitSql` в конфигурации пула)​[github.com](https://github.com/brettwooldridge/HikariCP#:~:text=,Default%3A%20none). HikariCP может автоматически вызывать `Connection.isValid()` или специальный SQL-запрос перед выдачей соединения (параметр `connectionTestQuery` или JDBC4 `isValid` API)​[github.com](https://github.com/brettwooldridge/HikariCP#:~:text=)​[github.com](https://github.com/brettwooldridge/HikariCP#:~:text=%E2%8F%B3,Default%3A%205000). Это помогает убедиться, что соединение действительно активно.
    
- **Разница с HikariCP:** по сути, HikariCP “надстройка” над драйвером: он управляет пулом объектов `Connection`, но использует тот же драйвер для создания фактических соединений. HikariCP не зависит от специфики PostgreSQL – в качестве DataSource можно использовать любые JDBC-драйверы. Поэтому в контексте пула устройства драйвера PostgreSQL важны только те свойства, которые влияют на сетевые соединения и производительность запросов.
    

В целом, драйвер PostgreSQL и HikariCP решают разные задачи: драйвер – низкоуровневый транспорт, пул – механизм повторного использования и управления жизненным циклом соединений. При правильной комбинации они обеспечивают быстрое и стабильное взаимодействие приложения с базой.

## Примеры мониторинга состояния пулов через Micrometer/Prometheus для Spring Boot

Spring Boot Actuator вместе с Micrometer автоматически собирает метрики подключения к базе. При использовании HikariCP доступны метрики, например: `hikaricp_connections_active`, `hikaricp_connections_idle`, `hikaricp_connections_pending`, `hikaricp_connections_max`, `hikaricp_connections_min` и т.д. Эти метрики публикуются через endpoint `/actuator/metrics` и могут быть экспортированы в Prometheus.

Пример конфигурации для экспорта в Prometheus (`application.yml`):

```java
management:
  endpoints:
    web:
      exposure:
        include: health,info,prometheus,metrics
  metrics:
    export:
      prometheus:
        enabled: true

```

После этого Prometheus может опрашивать endpoint `/actuator/prometheus` для сбора метрик. В Grafana можно создать дашборд с графиками, например, запросы:

- `hikaricp_connections_active{application="myapp"}` – активные соединения в пуле;
    
- `hikaricp_connections_idle{application="myapp"}` – свободные (idle) соединения;
    
- `hikaricp_connections_pending{application="myapp"}` – число потоков, ожидающих соединение;
    
- `hikaricp_connection_timeout_count{application="myapp"}` – количество таймаутов при выдаче соединения.
    

Такая система мониторинга позволяет в реальном времени видеть, загружен ли пул соединений, сколько соединений свободно и есть ли частые ошибки ожидания (timeout). Это особенно важно в продакшен-среде для быстрого реагирования на проблемы. В микросервисах аналогично настраиваются метрики в каждом сервисе, агрегируемые централизованно.

## Монолитные и микросервисные архитектуры

В **монолитной** архитектуре обычно одно приложение содержит всю бизнес-логику и имеет один пул соединений к БД. Это упрощает настройку: достаточно спроектировать один пул нужного размера. Так как приложение масштабируется вертикально (дополнительные соединения в рамках одного процесса), количество пулов равно числу инстансов монолита.

В **микросервисной** архитектуре у каждого сервиса – свой пул. Допустим, у сервиса A максимальный пул 10, у сервиса B – 5, и оба обращаются к одной базе. При 3 инстансах A и 2 инстансах B, максимально может быть до 3×10 + 2×5 = 40 открытых соединений. Это может превысить лимиты БД. Поэтому при микросервисах часто применяют:

- Уменьшение размеров пулов в каждом сервисе и/или ограничение числа инстансов (или автоматический расчет).
    
- Введение промежуточного пула (PgBouncer) перед БД, чтобы агрегация соединений происходила вне JVM.
    
- Использование других СУБД-практик (read replicas, CQRS и т. д.), чтобы снизить нагрузку на одну БД.
    
Масштабирование микросервисов требует особой настройки пула: у каждого сервиса свой пул, и их сумма не должна превышать возможностей БД. При горизонтальном масштабировании рекомендуется мониторить суммарное число соединений и при необходимости использовать PgBouncer.

Таким образом, пул соединений является критическим компонентом как в монолите, так и в распределённой системе. В монолите зачастую достаточно HikariCP с однородными настройками. В микросервисах важно сбалансировать пулами разных сервисов и, при необходимости, вынести часть логики пуллинга на уровень БД (PgBouncer/Pgpool-II).

**Источники:** официальная документация и блог HikariCP​[github.com](https://github.com/brettwooldridge/HikariCP#:~:text=Fast%2C%20simple%2C%20reliable,how%20we%20do%20it%20here)​[github.com](https://github.com/brettwooldridge/HikariCP#:~:text=,Default%3A%2010), авторитетные статьи о JDBC-пулах, а также опыт практического использования в Spring Boot и PostgreSQL.