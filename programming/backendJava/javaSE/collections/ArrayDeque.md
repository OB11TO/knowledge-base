---
title: ArrayDeque
tags:
  - Collection
  - Concurrent
  - Queue
related_topics: 
created: 2024-09-09 18:05
modified: 2024-09-10T13:13:36+03:00
questions: 
notes: 
links: 
---
### class ArrayDeque<\E> extends java.util.AbstractCollection<\E>

All Implemented Interfaces:[Serializable](https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html), [Cloneable](https://docs.oracle.com/javase/8/docs/api/java/lang/Cloneable.html), [Iterable](https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html)<\E>, [Collection](https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html)<\E>, [Deque](https://docs.oracle.com/javase/8/docs/api/java/util/Deque.html)<\E>, [Queue](https://docs.oracle.com/javase/8/docs/api/java/util/Queue.html)<\E>

Класс `ArrayDeque<E>` представляет собой реализацию двусторонней очереди (дек) на основе массива в Java. Вот некоторые плюсы и минусы данного класса:

<mark class="hltr-orange">Плюсы</mark>:

- Эффективность вставки и удаления: `ArrayDeque` обеспечивает быструю вставку и удаление элементов как в начало, так и в конец очереди. Это делает его хорошим выбором для задач, где требуется интенсивное добавление и удаление элементов.
- Произвольный доступ: `ArrayDeque` предоставляет возможность произвольного доступа к элементам по индексу. Это позволяет эффективно получать элементы из середины очереди или выполнять операции, требующие произвольного доступа.
- Компактное использование памяти: по сравнению с другими реализациями деков, `ArrayDeque` обычно потребляет меньше памяти, так как использует внутренний массив для хранения элементов.

<mark class="hltr-orange">Минусы</mark>:

- Ограниченный размер: `ArrayDeque` имеет ограниченный размер, который определяется размером внутреннего массива. Если количество элементов в очереди достигает предела внутреннего массива, происходит его расширение, что может потребовать временных затрат.
- Не потокобезопасность: `ArrayDeque` не является потокобезопасной структурой данных. Если требуется использование `ArrayDeque` в многопоточной среде, необходимо обеспечить синхронизацию доступа к ней вручную.

В целом, `ArrayDeque` является хорошим выбором для многих задач, где требуется эффективное добавление, удаление и произвольный доступ к элементам. Однако, если вам требуется многопоточная безопасность или динамическое изменение размера без ограничений, возможно, стоит рассмотреть другие реализации, такие как `ConcurrentLinkedDeque`.

### Методы

- `boolean add(E e)`: Добавляет указанный элемент в конец дека.
- `void addFirst(E e)`: Вставляет указанный элемент в начало дека.
- `void addLast(E e)`: Вставляет указанный элемент в конец дека.
- `void clear()`: Удаляет все элементы из дека.
- `ArrayDeque<E> clone()`: Возвращает копию этого дека.
- `boolean contains(Object o)`: Возвращает true, если дек содержит указанный элемент.
- `Iterator<E> descendingIterator()`: Возвращает итератор по элементам дека в обратном порядке.
- `E element()`: Извлекает, но не удаляет, первый элемент очереди, представляемый деком.
- `E getFirst()`: Извлекает, но не удаляет, первый элемент дека. **ВАЖНО! Бросает NoSuchElementException!!!**
- `E getLast()`: Извлекает, но не удаляет, последний элемент дека.**ВАЖНО! Бросает NoSuchElementException!!!**
- `boolean isEmpty()`: Возвращает true, если дек не содержит элементов.
- `Iterator<E> iterator()`: Возвращает итератор по элементам дека.
- `boolean offer(E e)` - Вставляет указанный элемент в конец этой двусторонней очереди.
- `boolean offerFirst(E e)` - Вставляет указанный элемент в начало этой двусторонней очереди.
- `boolean offerLast(E e)` - Вставляет указанный элемент в конец этой двусторонней очереди.
- `E peek()` - Возвращает, но не удаляет, головной элемент очереди, представленной этой двусторонней очередью, или возвращает null, если эта очередь пуста.
- `E peekFirst()` - Возвращает, но не удаляет, первый элемент этой двусторонней очереди, или возвращает null, если эта очередь пуста.  
    ВАЖНО!  
    **Не бросает NoSuchElementException!!!**
- `E peekLast()` - Возвращает, но не удаляет, последний элемент этой двусторонней очереди, или возвращает null, если эта очередь пуста.
- ВАЖНО! **Не бросает NoSuchElementException!!!**
- `E poll()` - Извлекает и удаляет головной элемент очереди, представленной этой двусторонней очередью (то есть первый элемент этой очереди), или возвращает null, если эта очередь пуста.
- `E pollFirst()` - Извлекает и удаляет первый элемент этой двусторонней очереди, или возвращает null, если эта очередь пуста.
- `E pollLast()` - Извлекает и удаляет последний элемент этой двусторонней очереди, или возвращает null, если эта очередь пуста.
- `E pop()` - Извлекает элемент из стека, представленного этой двусторонней очередью. ВАЖНО! Б**росает NoSuchElementException!!!**
- `void push(E e)` - Помещает элемент в стек, представленный этой двусторонней очередью.
- `E remove()` - Извлекает и удаляет головной элемент очереди, представленной этой двусторонней очередью.
- `boolean remove(Object o)` - Удаляет один экземпляр указанного элемента из этой двусторонней очереди.
- `E removeFirst()` - Извлекает и удаляет первый элемент этой двусторонней очереди. ВАЖНО! Б**росает NoSuchElementException!!!**
- `boolean removeFirstOccurrence(Object o)` - Удаляет первое вхождение указанного элемента в этой двусторонней очереди (при обходе очереди от головы к хвосту).
- `E removeLast()` - Извлекает и удаляет последний элемент этой двусторонней очереди. **ВАЖНО! Бросает NoSuchElementException!!!**
- `boolean removeLastOccurrence(Object o)` - Удаляет последнее вхождение указанного элемента в этой двусторонней очереди (при обходе очереди от головы к хвосту).
- `int size()` - Возвращает количество элементов в этой двусторонней очереди.
- `Spliterator<E> spliterator()` - Создает "late-binding" (ленивую) и "fail-fast" (быстро обнаруживающую ошибки) Spliterator для элементов в этой двусторонней очереди.
- `Object[] toArray()` - Возвращает массив, содержащий все элементы этой двусторонней очереди в правильной последовательности (от первого до последнего элемента).
- `<T> T[] toArray(T[] a)` - Возвращает массив, содержащий все элементы этой двусторонней очереди в правильной последовательности (от первого до последнего элемента); тип возвращаемого массива определяется типом указанного массива.


### Когда использовать `add()`?

- Если вы **уверены**, что элемент будет добавлен в коллекцию (например, для неограниченных очередей или других коллекций, таких как `ArrayList`).
- Когда нужно, чтобы ошибка при добавлении элемента была сразу видна через исключение.

### Когда использовать `offer()`?

- Если вы работаете с **ограниченными очередями**, где добавление элемента может быть ограничено размером.
- Когда важно избежать выброса исключений и просто проверять, удалось ли добавить элемент, с помощью логики на основе `true` или `false`.
![[Pasted image 20240910131326.png]]