---
title: Buffer
tags:
  - IO-NIO
related_topics: 
created: 2024-09-10 17:59
modified: 2024-09-16T13:28:03+03:00
questions: 
notes: 
links: 
---

### Buffer

Класс `Buffer` в пакете `java.nio` <mark class="hltr-yellow">представляет буфер для чтения и записи данных. </mark>Буфер <mark class="hltr-green2">является контейнером для элементов определенного типа данных, таких как байты, символы и примитивные значения</mark>. Он <mark class="hltr-blue">предоставляет методы для удобного доступа и манипулирования данными.</mark>

Вот основные методы и свойства класса `Buffer`:

- `capacity()`: Возвращает <mark class="hltr-purple">емкость буфера, т.е. максимальное количество элементов, которое буфер может содержать.</mark>
- `position()`: Возвращает <mark class="hltr-yellow">текущую позицию в буфере, т.е. индекс следующего элемента, </mark>который будет считываться или записываться.
- `limit()`: Возвращает <mark class="hltr-yellow">предел буфера</mark>, т.е. индекс первого непрочитанного или незаписанного элемента.
- `mark()`: У<mark class="hltr-blue">станавливает метку в текущую позицию.</mark>
- `reset()`: <mark class="hltr-blue">Восстанавливает позицию на ранее установленную метку.</mark>
- `flip()`: Меняет предел с текущей позиции на текущую позицию, а текущую позицию на 0. Это <mark class="hltr-red">готовит буфер к чтению после записи.</mark>
- `rewind()`: Устанавливает текущую позицию в 0, сохраняя предел и емкость неизменными. Это готовит буфер к повторному чтению или записи.
- `clear()`: Очищает буфер путем установки текущей позиции в 0, предела в емкость и сброса метки. Это готовит буфер к записи после чтения.
- `hasRemaining()`: Проверяет, <mark class="hltr-yellow">есть ли еще непрочитанные или незаписанные элементы в буфере.</mark>
- `remaining()`: Возвращает количество оставшихся элементов, которые можно прочитать или записать.

Буферы в Java работают в двух режимах:

1. **Режим записи (writing mode)** — когда вы записываете данные в буфер.
2. **Режим чтения (reading mode)** — когда вы читаете данные из буфера.

Когда вы записываете данные в буфер, изменяются такие свойства, как `position` и `limit`:

- **position** — указывает текущую позицию, куда будет записываться следующий байт или символ.
- **limit** — в режиме записи указывает, сколько данных можно записать в буфер. Обычно равно вместимости буфера (capacity).

### Что делает `flip()`?

Метод `flip()` переключает буфер из режима записи в режим чтения. Когда вы вызываете `flip()`, происходят следующие изменения:

1. **limit** устанавливается в текущее значение `position` (то есть в точку, до которой были записаны данные).
2. **position** сбрасывается в 0, начиная чтение с самого начала буфера.
3. **mark** (если установлен) сбрасывается.

Таким образом, после вызова `flip()` вы сможете читать те данные, которые только что записали в буфер.

### Пример работы с буфером
```java
ByteBuffer buffer = ByteBuffer.allocate(10); // Создаем буфер на 10 байт

// Записываем данные в буфер
buffer.put((byte) 1);
buffer.put((byte) 2);
buffer.put((byte) 3);

System.out.println("Position before flip: " + buffer.position()); // 3
System.out.println("Limit before flip: " + buffer.limit());       // 10

// Переключаем в режим чтения
buffer.flip();

System.out.println("Position after flip: " + buffer.position());  // 0
System.out.println("Limit after flip: " + buffer.limit());        // 3

// Читаем данные из буфера
while (buffer.hasRemaining()) {
    System.out.println(buffer.get());
}

```
### Результат выполнения:

- До вызова `flip()`: позиция будет 3 (потому что мы записали 3 байта), а лимит будет 10 (размер буфера).
- После вызова `flip()`: позиция сбросится на 0 (чтобы читать с начала), а лимит станет равным 3 (то есть до того места, где данные были записаны).


Пример использования класса `Buffer` для чтения и записи данных:

```Java
import java.nio.Buffer;
import java.nio.ByteBuffer;

public class BufferExample {
    public static void main(String[] args) {
        // Создание буфера
        ByteBuffer buffer = ByteBuffer.allocate(10);

        // Запись данных в буфер
        buffer.put((byte) 1);
        buffer.put((byte) 2);
        buffer.put((byte) 3);

        // Подготовка буфера для чтения
        buffer.flip();

        // Чтение данных из буфера
        while (buffer.hasRemaining()) {
            byte data = buffer.get();
            System.out.println(data);
        }

        // Очистка буфера
        buffer.clear();
    }
}
```

### Подклассы `Buffer` для разных типов данных:

1. `ByteBuffer`: Подкласс `ByteBuffer` предназначен для работы с байтовыми данными. Он предоставляет методы для чтения и записи байтов в буфер.
2. `CharBuffer`: Подкласс `CharBuffer` предназначен для работы с символьными данными. Он предоставляет методы для чтения и записи символов в буфер.
3. `ShortBuffer`: Подкласс `ShortBuffer` предназначен для работы с короткими целыми числами (short). Он предоставляет методы для чтения и записи short-значений в буфер.
4. `IntBuffer`: Подкласс `IntBuffer` предназначен для работы с целыми числами (int). Он предоставляет методы для чтения и записи int-значений в буфер.
5. `LongBuffer`: Подкласс `LongBuffer` предназначен для работы с длинными целыми числами (long). Он предоставляет методы для чтения и записи long-значений в буфер.
6. `FloatBuffer`: Подкласс `FloatBuffer` предназначен для работы с числами с плавающей запятой одинарной точности (float). Он предоставляет методы для чтения и записи float-значений в буфер.
7. `DoubleBuffer`: Подкласс `DoubleBuffer` предназначен для работы с числами с плавающей запятой двойной точности (double). Он предоставляет методы для чтения и записи double-значений в буфер.

Каждый из этих подклассов имеет свои уникальные методы и свойства, специфичные для работы с соответствующим типом данных. Все они имеют общие методы и свойства, унаследованные от базового класса `Buffer`, такие как `capacity()`, `position()`, `limit()` и другие, которые позволяют управлять данными в буфере.