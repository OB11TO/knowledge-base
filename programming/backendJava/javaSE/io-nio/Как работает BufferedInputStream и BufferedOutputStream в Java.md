---
title: Как работает BufferedInputStream и BufferedOutputStream в Java
tags:
  - IO-NIO
related_topics: 
created: 2024-09-10 17:03
modified: 2025-03-25T13:35:55+03:00
questions: 
notes: 
links: 
---

**`BufferedInputStream`** и **`BufferedOutputStream`** — это классы, которые используют буферизацию для повышения производительности при работе с потоками ввода и вывода байтов. <mark class="hltr-yellow">Они оборачивают потоки данных и используют внутренний буфер, что позволяет читать и записывать данные более эффективно.</mark>

#### Основные моменты:

- **Буферизация**: При <mark class="hltr-yellow">чтении или записи байтов с помощью этих классов данные сначала помещаются в буфер (в памяти)</mark>, а уже <mark class="hltr-green2">потом читаются или записываются из потока.</mark> Это <mark class="hltr-yellow">снижает количество обращений к физическим ресурсам</mark>, таким как дисковая система или сеть, что ускоряет работу.
- **Размер буфера по умолчанию**: <mark class="hltr-purple">Обычно это 8 КБ, но его можно настроить.</mark>
- **Оптимизация работы**: <mark class="hltr-yellow">Без буферизации каждый вызов</mark> `read()` или `write()` о<mark class="hltr-yellow">бращался бы к исходному потоку,</mark> что требует дополнительных операций ввода-вывода (I/O), каждая из которых может быть дорогой по времени.

#### Принцип работы:

1. **`BufferedInputStream`**:
    
    - Когда выполняется чтение данных, <mark class="hltr-yellow">класс запрашивает данные большими порциями</mark> (например, 8 КБ) <mark class="hltr-yellow">из исходного потока и помещает их в буфер.</mark>
    - Если вызывается метод `read()`, <mark class="hltr-green2">данные берутся не напрямую из потока, а из буфера, что экономит время, так как доступ к памяти быстрее</mark>, чем к дисковым или сетевым ресурсам.
    - <mark class="hltr-red"> Когда буфер опустошается, происходит новое чтение большого блока данных.</mark>
2. **`BufferedOutputStream`**:
    
    - <mark class="hltr-yellow">Данные сначала записываются в буфер, и только когда буфер заполняется, они отправляются в исходный поток</mark> (например, в файл или сеть).
    - Метод `flush()` <mark class="hltr-red">заставляет поток записать данные из буфера в исходный поток принудительно, даже если буфер не полностью заполнен.</mark>
    - <mark class="hltr-yellow">Это уменьшает количество операций записи, так как вместо записи каждого байта по отдельности записывается сразу большой блок данных.</mark>

```java
try (BufferedInputStream in = new BufferedInputStream(new FileInputStream("input.txt"));
     BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream("output.txt"))) {

    int data;
    while ((data = in.read()) != -1) {
        out.write(data);
    }
    out.flush();  // Принудительная запись оставшихся данных из буфера
} catch (IOException e) {
    e.printStackTrace();
}

```

### Отличия буферов в NIO (`ByteBuffer`) и IO (`BufferedInputStream` / `BufferedOutputStream`)

- **`BufferedInputStream` / `BufferedOutputStream`** (IO):
    
    - <mark class="hltr-green2">Буферизация происходит автоматически</mark> "под капотом".
    - <mark class="hltr-yellow">Буфер управляется самим классом и скрыт от пользователя</mark>.
    - Класс <mark class="hltr-yellow">работает в рамках традиционной модели ввода-вывода с блокировками</mark> (Blocking IO).
    - <mark class="hltr-red">Цель</mark> — <mark class="hltr-purple">минимизировать количество системных вызовов, связанных с I/O-операциями</mark>, и повысить производительность.
- **`ByteBuffer`** (NIO):
    
    - `ByteBuffer` — это основа буферов в Java NIO.
    - Буфер в NIO<mark class="hltr-yellow"> является **явной** структурой данных</mark>, с которой разработчик работает напрямую.
    - <mark class="hltr-green2">Поддерживает методы для упр</mark>авления позициями, лимитами и ёмкостью буфера, что даёт более гибкий контроль над потоками.
    - NIO <mark class="hltr-purple">поддерживает неблокирующее I/O</mark> (Non-blocking IO) и позволяет работать с каналами (`Channel`) для более эффективного взаимодействия с файловыми системами и сетями.
    - В отличие от буферов в IO, `ByteBuffer` п<mark class="hltr-yellow">озволяет управлять памятью на уровне программы, что может повысить производительность при правильной настройке.</mark>

### Отличия и преимущества:

- **Простота использования**:
    
    - `BufferedInputStream` и `BufferedOutputStream` просты в использовании, и большинство деталей буферизации скрыты.
    - В NIO, буферы явные, и их использование требует больше внимания (работа с `ByteBuffer` предполагает прямое управление позициями, лимитами и ёмкостью).
- **Неблокирующий режим (NIO)**:
    
    - Одно из главных преимуществ NIO — поддержка неблокирующего ввода-вывода (особенно при работе с сетью). Это позволяет более эффективно обрабатывать множество соединений или файлов одновременно, не блокируя потоки при ожидании данных.
- **Эффективность в многозадачных средах**:
    
    - **NIO** более эффективно работает в сценариях, где необходимо работать с большим количеством одновременных операций ввода-вывода, например, при разработке серверов с высокой нагрузкой.

### Оптимизация благодаря `BufferedInputStream` и `BufferedOutputStream`

Если бы **буферизация** в классах `BufferedInputStream` и `BufferedOutputStream` не использовалась, то:

- Каждый вызов методов `read()` или `write()` обращался бы напрямую к источнику данных (например, к диску, сети).
- Это увеличивало бы количество системных вызовов, что могло бы существенно снизить производительность, особенно при работе с большими объемами данных.

Буферизация позволяет:

- **Сократить количество операций ввода-вывода** (особенно при чтении и записи небольших данных).
- **Уменьшить задержки** при доступе к медленным ресурсам, таким как сетевые соединения или дисковые системы.
- **Повысить общую производительность** приложения, так как данные читаются и записываются более эффективно благодаря использованию буферов.

>[!faq]-  Почему буферизация помогает, даже если нужно прочитать весь файл?
1. **Уменьшение количества системных вызовов**  
    Каждый вызов метода `read()` или `write()` в потоке ввода-вывода — это системный вызов, который требует ресурсов операционной системы. Он может быть довольно "дорогим" по времени выполнения, особенно при чтении одного байта за раз.
    
    **Без буферизации**:
    
    - Каждый вызов `read()` <mark class="hltr-yellow">запрашивает у операционной системы **один байт** данных.</mark>
    - Операционная система должна выполнить полный цикл взаимодействия с устройством (диском или сетью) даже для таких маленьких запросов.
    
    **С буферизацией**:
    
    - Один вызов `read()` в `BufferedInputStream` запрашивает сразу **большой блок данных** (например, 8 КБ), что уменьшает количество системных вызовов.
    - Далее, буфер передаёт данные небольшими порциями из памяти, что быстрее, чем взаимодействие с устройствами напрямую.
    
    **Пример**:  
    Если вы читаете 100 000 байтов:
    
    - **Без буфера**: 100 000 вызовов системы к диску.
    - **С буфером**: Один запрос на 8 КБ (около 12-13 вызовов), остальная работа выполняется в памяти.
2. **Медленность физических устройств**  
    Физические устройства, такие как жесткие диски или сетевые соединения, работают гораздо медленнее, чем доступ к оперативной памяти. Каждый раз, когда программа обращается к таким устройствам, есть задержка, связанная с чтением данных.
    
    **С буферизацией**:
    
    - Когда данные поступают в буфер, чтение или запись происходит **в оперативной памяти**, что значительно быстрее.
    - Буфер позволяет читать данные блоками, что снижает задержки и повышает скорость работы.
