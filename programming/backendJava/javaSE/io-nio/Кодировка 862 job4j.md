---
title: Кодировка 862 job4j
tags:
  - IO-NIO
  - Job4j
related_topics: 
created: 2025-01-20 15:00
modified: 2025-01-20T16:24:02+03:00
questions: 
notes: 
links: 
---

В этом уроке мы познакомимся с понятием кодировка и научимся применять его в своем коде, чтобы избегать недоразумений при работе с текстовыми файлами.  

В общем случае <mark class="hltr-red">кодировка</mark> - это **однозначное**<mark class="hltr-green2"> соответствие между подмножеством целых чисел (как правило идущих подряд) и некоторым набором символов</mark>. <mark class="hltr-yellow">Ключевым понятием здесь является понятие символа. Это может быть как буква, может соответствовать звуку речи, а также может быть представлен графическим знаком. Проще говоря - это мельчайшая неделимая частица информации.</mark>

Например латинское "A" и кириллическое "А" - это разные  символы, потому что они употребляются в разных контекстах и несут в себе разную информацию.

Определяющим для любой кодировки является количество охватываемых ею кодов и, соответственно, символов. Поскольку <mark class="hltr-purple">тексты в компьютере хранятся в виде последовательности байтов, большинство кодировок естественным образом распадаются на однобайтовые, или восьмибитные, способные закодировать не больше 256 символов, и двухбайтовые</mark>, или шестнадцатибитные, чья емкость может достигать 65636 знакомест.

Если говорить совсем простым языком, то <mark class="hltr-blue">кодировка для компьютера - это просто разные языки, как для человека английский, русский или китайский</mark>. Для <mark class="hltr-yellow">кодировки есть отдельные таблицы, в которых указано соответствие между символом и числом в которое кодируется этот символ</mark>. Например большинство шрифтов, которые определены в программе Microsoft Word имеют кодировку Windows-1251, одной из основоположниц кодирования является кодировка ASCII. Мы же в своих проектах используем кодировку UTF-8  и с самых первых шагов обучения рекомендуем проверить, чтобы среда разработки Inteliji IDEA была настроена на использование именно этой кодировки - увидеть это можно в правом нижнем углу открытого окна среды разработки:

![[Pasted image 20250120160133.png]]

В следующей таблице представлены примеры разницы между различными видами кодировки:

![[Pasted image 20250120160151.png]]
как мы видим кириллические символы в кодировке ISO-8859-1 вообще не имеют числового представления, т.е. таких символов в этой кодировке нет. Также стоит отметить что кириллические символы в кодировках Windows-1251 и UTF-8 имеют разные числа, т.е. не равны друг другу.

Давайте разберемся почему это так важно. Давайте напишем простенький класс, в котором будут определены 2 метода - для чтения файла и записи новых данных в него.

```java
public class UsageEncoding {
    public String readFile(String path) {
        StringBuilder builder = new StringBuilder();
        try (BufferedReader reader = new BufferedReader(new FileReader(path))) {
            reader.lines()
                    .map(string -> string + System.lineSeparator())
                    .forEach(builder::append);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return builder.toString();
    }

    public void writeDataInFile(String path, String data) {
        try (PrintWriter writer = new PrintWriter(new FileWriter(path, true))) {
            writer.println(data);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

Использовать код и вычитывать данные из файла будем в методе main следующим образом
```java
public static void main(String[] args) {
    String path = "./src/data/text.txt";
    UsageEncoding encoding = new UsageEncoding();
    String string = encoding.readFile(path);
    System.out.println("Данные из файла: ");
    System.out.println(string);
}
```

Создадим файл по пути /src/data/text.txt и заполним его несколькими строками произвольного содержания:

![[Pasted image 20250120160247.png]]

Все выполнено успешно, такой вывод нас устраивает. Давайте откроем наш файл в программке WordPad в котором есть набор шрифтов, аналогичных шрифтам Microsoft Word (как было упомянуто ранее большинство из них имеют кодировку Windows-1251), и добавим еще несколько новых текстовых строк (в качестве шрифта я выбрал Times New Roman):
![[Pasted image 20250120160306.png]]

уже на стадии добавления новых строк мы видим что те строки, которые в документе ранее отображаются как "кракозябры". Всему виной то, что первые строки закодированы в кодировке UTF-8, а нижние три Windows-1251. Вернемся в Intelij IDEA и посмотрим как этот файл выглядит там:

![[Pasted image 20250120160319.png]]
тут все наоборот - в файле не распознаются нижние три строки. Давайте попробуем прочитать данные из этого файла - вывод в консоль будет следующим:

![[Pasted image 20250120160333.png]]
результат вполне предсказуемый. Но давайте попробуем разобраться как быть в такой ситуации. Обратимся к официальной документации и прочитаем как работает с данными класс FileReader():

[https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/io/FileReader.html#%3Cinit%3E(java.lang.String)](https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/io/FileReader.html#%3Cinit%3E(java.lang.String))

<mark class="hltr-red">Получается что при чтении файла класс использует кодировку платформы по умолчанию, т.е. в нашем случае это UTF-8</mark>. Нам это не совсем подходит, поскольку у нас в файле есть другая кодировка и нас в данную секунду мало интересуют первые три строки, мы хотим прочитать последние три, которые дописал для нас другой пользователь. Что же делать в данной ситуации? Все очень просто - надо использовать другой конструктор FileReader, в котором можно указать какую кодировку для чтения использовать:

[https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/io/FileReader.html#%3Cinit%3E(java.io.File,java.nio.charset.Charset)](https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/io/FileReader.html#%3Cinit%3E(java.io.File,java.nio.charset.Charset))

Для передачи экземпляра Charset (он определен в пакете java.nio.charset), как того требует этот конструктор можно использовать следующую конструкцию:
```java
Charset.forName("WINDOWS-1251")
```

и тогда весь конструктор в измененном виде будет иметь вид:
```java
new FileReader(path, Charset.forName("WINDOWS-1251"))
```
![[Pasted image 20250120160424.png]]

В нашем случае потеряли 3 первые строки(кодировка в них UTF-8), однако узнали содержимое последних строк. Также для определения стандартных кодировок можно использовать статические поля, которые определены в классе StandardCharsets (он определен в пакете java.nio.charset):

[https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/nio/charset/StandardCharsets.html](https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/nio/charset/StandardCharsets.html)

Но мы все еще не решили проблему - данные в одном файле у нас определены в разных кодировках. Тут стоит поступить простым способом - наш код должен уметь читать данные из файла и записывать в него новые данные. При этом делать это в одной кодировке. Добавим метод, который будет записывать новые данные файл и при этом сразу определим для него кодировку данных для записи:
```java
public void writeDataInFile(String path, String data) {
    try (PrintWriter writer = new PrintWriter(
            new FileWriter(path, Charset.forName("WINDOWS-1251"), true))) {
        writer.println(data);
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

Видоизменим наш метод main и запишем его следующим образом:
```java
public static void main(String[] args) {
    String path = "./src/data/text.txt";
    UsageEncoding encoding = new UsageEncoding();
    List<String> strings = List.of(
            "Новая строка 1",
            "Новая строка 2",
            "Новая строка 3",
            "Новая строка 4",
            "Новая строка 5"
    );
    for (String string : strings) {
        encoding.writeDataInFile(path, string);
    }
    String string = encoding.readFile(path);
    System.out.println("Данные из файла: ");
    System.out.println(string);
}
```

Вывод в консоль будет следующим:
![[Pasted image 20250120160509.png]]
Поэтому необходимо всегда стараться в потоках записи и чтения данных задавать кодировку, чтобы не было непредвиденных результатов при работе с текстовыми данными, особенно если это касается кириллических символов. Вы, как программист, должны беспокоиться о сохранности данных и о том, чтобы их невозможно было потерять при кодировании. И тогда другие программисты, которые унаследуют Ваш код, скажут Вам только спасибо.


-----

**Частое открытие потоков**

Обратите внимание на пример выше. Для записи отдельно взятой строки каждый раз открывается поток вывода. Так делать НЕ стоит, т.к. открытие потоков ввода/вывода тяжелая операция, как и в целом работа с ресурсами (работы файловой системой, сетью, базой и т.д.). В современном мире компьютеры обладают достаточной памятью, что даёт возможность ее не экономить, поэтому по возможности стоит хранить данные в памяти и только при необходимости работать с ресурсами.   
  
Для примера выше лучше сразу записать список строк:

```java
public void writeDataInFile(String path, List<String> data) {
    try (PrintWriter writer = new PrintWriter(new FileWriter(path, Charset.forName("WINDOWS-1251"), true))) {
        data.forEach(writer::println);
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

```java
writeDataInFile(path, strings);
```
