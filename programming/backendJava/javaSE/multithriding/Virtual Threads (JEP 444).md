---
title: Virtual Threads (JEP 444)
tags:
  - Multithreading
related_topics: 
created: 2024-09-11 12:32
modified: 2024-09-11T12:33:08+03:00
questions: 
notes: 
links: 
---
### Virtual Threads (JEP 444)

Виртуальные потоки, которые много лет разрабатывались в рамках проекта [Loom](https://openjdk.org/projects/loom/) и появились в [Java 19](https://openjdk.org/jeps/425) в режиме preview, теперь наконец-то стали стабильными.

Виртуальные потоки, в отличие от потоков операционной системы,  
являются легковесными и могут создаваться в огромном количестве  
(миллионы экземпляров). Это свойство должно значительно облегчить  
написание конкурентных программ, поскольку позволит применять простой  
подход «один запрос – один поток» (или «одна задача – один поток») и не  
прибегать к более сложным асинхронному или реактивному программированию.  
При этом миграция на виртуальные потоки уже существующего кода должна  
быть максимально простой, потому что виртуальные потоки являются  
экземплярами существующего класса  
[`java.lang.Thread`](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Thread.html) и практически полностью совместимы с классическими потоками: поддерживают стек-трейсы, [`interrupt()`](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Thread.html#interrupt()), [`ThreadLocal`](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/ThreadLocal.html) и т.д.

Виртуальные потоки реализованы поверх обычных потоков и существуют  
только для JVM, но не для операционной системы (отсюда и название  
«виртуальные»). Поток, на котором в данный момент выполняется  
виртуальный поток, называется потоком-носителем. Если потоки платформы  
полагаются на планировщик операционной системы, то планировщиком для  
виртуальных потоков является  
[`ForkJoinPool`](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/ForkJoinPool.html).  
Когда виртуальный поток блокируется на некоторой блокирующей операции,  
то он размонтируется от своего потока-носителя, что позволяет  
потоку-носителю примонтировать другой виртуальный поток и продолжить  
работу. Такой режим работы и дешевизна виртуальных потоков позволяет им  
очень хорошо масштабироваться. Однако на данный момент есть два  
исключения:  
`synchronized` блоки и JNI. При их выполнении  
виртуальный поток не может быть размонтирован, поскольку он привязан к  
своему потоку-носителю. Такое ограничение может препятствовать  
масштабированию. Поэтому при желании максимально использовать потенциал  
виртуальных потоков рекомендуется избегать  
`synchronized` блоков и операции JNI, которые выполняются часто или занимают длительное время.

Несмотря на привлекательность виртуальных потоков, вовсе  
необязательно предпочитать только их и всегда избегать классических  
потоков. Например, для задач, интенсивно и долго использующих CPU, лучше  
подойдут обычные потоки. Или если нужен поток, не являющийся  
[демоном](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Thread.html#setDaemon(boolean)), то также придётся использовать обычный поток, потому что виртуальный поток всегда является демоном.

Для создания виртуальных потоков и работы с ними появилось следующее API:

- [`Thread.Builder`](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Thread.Builder.html) – билдер потоков. Например, виртуальный поток можно создать путём вызова `Thread.ofVirtual().name("name").unstarted(runnable)`.
- [`Thread.startVirtualThread(Runnable)`](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Thread.html#startVirtualThread(java.lang.Runnable)) – создаёт и сразу же запускает виртуальный поток.
- [`Thread.isVirtual()`](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Thread.html#isVirtual()) – проверяет, является ли поток виртуальным.
- [`Executors.newVirtualThreadPerTaskExecutor()`](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/Executors.html#newVirtualThreadPerTaskExecutor()) – возвращает исполнитель, который создаёт новый виртуальный поток на каждую задачу.

Для виртуальных потоков также добавилась поддержка в инструментарии JDK (дебаггер, JVM TI, Java Flight Recorder).