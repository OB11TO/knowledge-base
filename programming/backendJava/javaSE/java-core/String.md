---
title: String
tags:
  - String
  - JavaSE
related_topics:
  - "[[Компактные строки Java 9]]"
  - "[[Дедупликация Собственный пул строк]]"
  - "[[Строковый литерал и конструктор в String]]"
created: 2024-08-30 16:21
modified: 2025-04-02T15:41:32+03:00
difficulty: 
questions: 
notes: 
links: 
---

## ПРО STRING byte[] char[]

- `char[] byte[]`
- ==Всё по стандарту в== ==UTF-8==
- `char[]` ==всегда 2 байта== ==(на диске в памяти либо 1 2 3 4 байта)== в Джава `char` ==либо 2, либо 4 байта==
- с Java 8 ==компактные строки==, сжимают информацию `byte[]`

>[!info] Ключевые моменты: 
> - Строки в Java представляют собой константы, которые не могут быть изменены  
>- Создать объект класса _String_ можно двумя способами: при помощи строкового литерала и конструктора  
>- Строковый литерал сохраняется в пул строк, если до этого он там отсутствовал  
>- Строка, созданная при помощи конструктора, сохраняется в heap, а не в пул строк  
>- Java 6: Пул строк хранится в памяти фиксированного размера, именуемого PermGen.  
>- Java 7, 8: Пул строк хранится в heap и, соответственно, для пула строк можно использовать всю память приложения  
>- При помощи параметра _-XX:StringTableSize=N_, где _N_ — размер _HashMap_, можно изменить размер пула строк. Его размер является фиксированным, поскольку он реализован, как _HashMap_ со списками в корзинах  
>- Инженеры по оптимизации _Java_ компании Oracle настоятельно не рекомендуют самостоятельно интернировать строки, поскольку это приводит к замедлению работы приложения. Их рекомендация — дедупликация.




![[Pasted image 20240830162146.png]]![[Pasted image 20240830162202.png]]![[Pasted image 20240830162212.png]]![[Pasted image 20240830162225.png]]![[Pasted image 20240830162241.png]]![[Pasted image 20240830162250.png]]![[Pasted image 20240830162302.png]]![[Pasted image 20240830162312.png]]![[Pasted image 20240830162323.png]]![[Pasted image 20240830162335.png]]![[Pasted image 20240830162353.png]]


### <mark class="hltr-orange">Рассмотрим еще один пример, который выдаст неожиданный результат:  </mark>

```java
public class StringExampleThree {

    public static void main(String[] args) {
        String str1 = "TopJava";
        String str2 = "Java";
        String str3 = "Top" + str2;

        System.out.println("Строка 1 равна строке 3? " + (str1 == str3));
    }
}
```

Результат выполнения программы:  

![](https://optim.tildacdn.com/tild6531-3136-4866-b334-383731333836/-/resize/760x/-/format/webp/carbon_29.png)

Схематично это выглядит примерно так:  

![](https://optim.tildacdn.com/tild3734-3833-4834-b733-653938633934/-/resize/760x/-/format/webp/Frame_201_1.jpg)

Причиной получения false является то, что <mark class="hltr-red">интернирование происходит не во время работы приложения (runtime), а во время компиляции</mark>. А т.к. <mark class="hltr-yellow">значение строки _str3_ вычисляется во время выполнения приложения, то на этапе компиляции оно не известно и потому, не добавляется в пул строк.</mark>


-----


![[Pasted image 20250402151013.png]]
![[Pasted image 20250402151002.png]]


----
![[Pasted image 20250402151252.png]]

![[Pasted image 20250402151640.png]]
 ![[Pasted image 20250402151653.png]]
![[Pasted image 20250402151816.png]]


----

![[Pasted image 20250402152255.png]]![[Pasted image 20250402152305.png]]
![[Pasted image 20250402152324.png]]



---
![[Pasted image 20250402153112.png]]
- GC пробежался по Хипу с сравнил byte[] в каждом String и если есть равенство, то можно переписать ссылочку внутри Stirng на один общий byte[] 
- Но самих объектов String не уменьшилось. 
![[Pasted image 20250402154122.png]]