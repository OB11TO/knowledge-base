---
title: Побег ссылки this на этапе конструирования
tags:
  - JavaSE
related_topics:
  - "[[Неизменяемый класс]]"
created: 2024-09-09 15:17
modified: 2024-09-09T15:19:55+03:00
difficulty: 
questions: 
notes: 
links: 
---
"Побег ссылки `this` на этапе конструирования" (или "escape of `this` during construction") — это ситуация, когда объект начинает использоваться до того, как его конструктор завершил работу. Это может привести к неожиданным и потенциально опасным последствиям, потому что объект еще не полностью инициализирован. В результате методы объекта или его внутренние состояния могут использоваться в некорректном или незаконченном виде.

### Почему это происходит?

<mark class="hltr-yellow">Когда вы передаете ссылку на текущий объек</mark>т (`this`) из конструктора, <mark class="hltr-yellow">например, в другой поток, метод или возвращаете её наружу, объект может начать использоваться до завершения процесса конструирования</mark>.<mark class="hltr-red"> В это время его состояние может быть не консистентным (неполностью инициализированным).</mark>

### Пример проблемы

Рассмотрим следующий код:

```java
class EventListener {
    public EventListener() {
        register(this);
    }

    public void onEvent() {
        System.out.println("Event received!");
    }

    private void register(EventListener listener) {
        // Имитация регистрации, где объект начинает использоваться
        new Thread(() -> listener.onEvent()).start();
    }
}

class MyObject {
    private final int value;

    public MyObject() {
        value = 42;
        new EventListener();  // передаёт this в другой объект
    }

    public void doSomething() {
        System.out.println("Value: " + value);
    }
}

```

В этом примере объект `EventListener` регистрирует себя с использованием ссылки `this` в момент конструирования. Однако, <mark class="hltr-yellow">если другой поток попытается использовать этот объект через метод </mark>`onEvent()` <mark class="hltr-yellow">до того, как конструктор завершит инициализацию, то он может получить доступ к частично инициализированному объекту, что может привести к непредсказуемым результатам или даже к ошибкам.</mark>

### В чем опасность?

- **Неполная инициализация**: Если объект используется до завершения конструктора, поля могут оставаться неинициализированными или находиться в промежуточных состояниях. Например, если доступ к методу происходит до того, как установлены финальные поля, это может привести к сбоям.
- **Проблемы с многопоточностью**: В многопоточных приложениях побег ссылки `this` может привести к гонкам данных и нарушению целостности объекта, поскольку другой поток может получить доступ к объекту до того, как он будет полностью создан.

### Как избежать побега ссылки `this`?

1. **Не передавайте `this` из конструктора**: Избегайте передачи текущего объекта до завершения его конструирования, особенно в другие потоки или контексты, которые могут использовать объект до его полной инициализации.
    
2. **Используйте фабричные методы**: Вместо передачи `this` во время конструирования, можно использовать фабричные методы для создания объектов, которые зарегистрируют ссылку после завершения создания объекта.

```java
class SafeEventListener {
    private SafeEventListener() {
        // приватный конструктор
    }

    public static SafeEventListener createAndRegister() {
        SafeEventListener listener = new SafeEventListener();
        listener.register(listener);  // регистрация после полной инициализации
        return listener;
    }

    private void register(SafeEventListener listener) {
        // безопасная регистрация
    }
}

```
`
    
3. **Используйте отложенные действия (lazy initialization)**: Если регистрация или передача `this` необходима, её можно отложить до тех пор, пока конструктор не завершит свою работу.
    

### Вывод

Побег ссылки `this` на этапе конструирования — это потенциально опасная практика, так как объект может быть использован до его полной инициализации. Чтобы избежать проблем, связанных с этим, важно следить за тем, как и когда вы передаете или используете ссылку на текущий объект.