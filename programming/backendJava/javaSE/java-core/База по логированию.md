---
title: База по логированию
tags:
  - JavaSE
related_topics: 
created: 2025-01-22 17:25
modified: 2025-01-22T18:11:23+03:00
questions: 
notes: 
links: 
---


![[Pasted image 20250122173440.png]]


### Что такое логирование?

Логирование — это процесс записи информации о работе приложения в виде сообщений в лог-файлы или другие хранилища. Это позволяет:

1. **Отслеживать ошибки**: Помогает находить и исправлять баги.
2. **Диагностировать проблемы**: Показывает, что происходило в приложении до и после возникновения проблемы.
3. **Собирать аналитические данные**: Позволяет анализировать поведение пользователей и производительность системы.
4. **Аудит и безопасность**: Хранит важную информацию для анализа нарушений или подозрительных действий.

---

### Основные элементы логирования

1. **Уровни логов**:
    
    - `TRACE`: Подробная отладочная информация. Обычно включает информацию для детального анализа работы приложения.
    - `DEBUG`: Менее подробная информация, чем `TRACE`. Используется для отладки.
    - `INFO`: Общая информация о работе приложения, например, "Сервер запущен".
    - `WARN`: Предупреждения о потенциальных проблемах.
    - `ERROR`: Ошибки, которые не приводят к остановке приложения.
    - `FATAL`: Критические ошибки, которые могут привести к остановке приложения.
2. **Компоненты системы логирования**:
    
    - **Logger**: Компонент, который отправляет сообщения.
    - **Appender** (или Handler): Определяет, куда отправляются логи (файл, консоль, база данных, удалённый сервер и т.д.).
    - **Layout**: Определяет формат сообщения (например, JSON, текст, XML).


----

### Основные библиотеки логирования и их особенности

#### **1. SLF4J (Simple Logging Facade for Java)**

- **Что это**: Это фасад для логирования. Он не выполняет логирование самостоятельно, а предоставляет API, к которому можно подключить любую из библиотек (например, Log4j или Logback).
- **Преимущества**:
    - Унифицированный интерфейс для разных библиотек.
    - Упрощает смену логгеров (например, с Log4j на Logback).
- **Пример**:
```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class Example {
    private static final Logger logger = LoggerFactory.getLogger(Example.class);

    public static void main(String[] args) {
        logger.info("Hello, SLF4J!");
    }
}
```

#### **2. Log4j (Apache Log4j)**

- **Что это**: Популярная библиотека для логирования, основанная на конфигурации через XML или свойства.
- **Версии**:
    - Log4j 1.x: Старая версия, считается устаревшей.
    - Log4j 2.x: Полностью переписанная версия с улучшенной производительностью и функциональностью.
- **Особенности**:
    - Асинхронное логирование (в версии 2.x).
    - Поддержка плагинов.
    - Конфигурация через XML, JSON, YAML или Java-код.
- **Недостатки**:
    - Log4j 1.x не поддерживается.
- **Пример конфигурации (Log4j 2)**:
```java
<Configuration>
    <Appenders>
        <Console name="Console" target="SYSTEM_OUT">
            <PatternLayout pattern="%d [%t] %-5level: %msg%n%throwable"/>
        </Console>
    </Appenders>
    <Loggers>
        <Root level="info">
            <AppenderRef ref="Console"/>
        </Root>
    </Loggers>
</Configuration>

```

#### **3. Logback**

- **Что это**: Современная библиотека логирования, разработанная как преемник Log4j.
- **Особенности**:
    - Использует SLF4J как фасад.
    - Улучшенная производительность.
    - Конфигурация через XML или Groovy.
    - Встроенные ротация логов и компрессия.

#### **4. JCL (Jakarta Commons Logging)**

- **Что это**: Старый фасад для логирования.
- **Недостатки**:
    - Проблемы совместимости с классами.
    - Мало используется в современных приложениях.

#### **5. JUL (Java Util Logging)**

- **Что это**: Встроенный механизм логирования в Java.
- **Особенности**:
    - Не требует сторонних библиотек.
    - Ограниченная функциональность.
    - Сложнее в настройке, чем Log4j или Logback.


----
### Зачем так много библиотек?

1. **Историческое развитие**:
    
    - JUL был первым, но оказался неудобным и ограниченным.
    - Log4j стал стандартом, но затем устарел.
    - Logback появился как замена Log4j с улучшениями.
    - SLF4J и JCL — попытки создать универсальный фасад для работы с разными библиотеками.
2. **Разные требования**:
    
    - JUL подходит для простых приложений.
    - Logback или Log4j 2 — для высоконагруженных приложений.

### Кто чем пользуется сейчас?

- **Logback**: Один из самых популярных выборов для новых проектов.
- **Log4j 2**: Используется, особенно если уже была настройка старой версии Log4j.
- **SLF4J**: Используется как стандартный фасад в большинстве приложений.
- **JUL**: Редко используется в крупных проектах.

------

# Тонкости в Логировании

![[Pasted image 20250122175338.png]]

- <mark class="hltr-yellow">Это главный интерфейс у Appender</mark> 

![[Pasted image 20250122175415.png]]
 - <mark class="hltr-purple">Задача каждого логгера переопределить метод doAppend() </mark> для своей реализации

------

###### Правило хорошего тонна не делать конкатенацию строк в логировании наших параметров
![[Pasted image 20250122175842.png]]

<mark class="hltr-green2">Лучше всего сделать вот так, так как конкатенация будет происходить после проверки, что делает буст на производительности.</mark>
![[Pasted image 20250122175940.png]]
![[Pasted image 20250122175957.png]]


----

![[Pasted image 20250122180807.png]]
- <mark class="hltr-orange">Чтобы не дублировать сообщения </mark>


-----

#### **Объяснить, как настроить ротацию логов в Logback.**

Ротация (архивация старых логов) может быть настроена через `RollingFileAppender`. Пример:

```xml
<appender name="ROLLING_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
    <file>logs/app.log</file>
    <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
        <fileNamePattern>logs/app.%d{yyyy-MM-dd}.log</fileNamePattern>
        <maxHistory>30</maxHistory>
    </rollingPolicy>
    <encoder>
        <pattern>%d [%thread] %-5level %logger{36} - %msg%n</pattern>
    </encoder>
</appender>
<root level="info">
    <appender-ref ref="ROLLING_FILE" />
</root>

```

- Логи будут сохраняться в файл `logs/app.log`.
- Каждый день создается новый файл с датой в названии.
- Хранятся только последние 30 файлов.

-----

**Настроить логирование для вывода в файл и консоль**
```xml
<appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
    <encoder>
        <pattern>%d [%thread] %-5level %logger{36} - %msg%n</pattern>
    </encoder>
</appender>

<appender name="FILE" class="ch.qos.logback.core.FileAppender">
    <file>logs/app.log</file>
    <encoder>
        <pattern>%d [%thread] %-5level %logger{36} - %msg%n</pattern>
    </encoder>
</appender>

<root level="info">
    <appender-ref ref="CONSOLE" />
    <appender-ref ref="FILE" />
</root>

```


---

#### **1. Чем отличается Log4j от Logback?**

|**Функция**|**Log4j 2**|**Logback**|
|---|---|---|
|Производительность|Высокая, поддерживает асинхронность.|Высокая, но уступает Log4j 2.|
|Конфигурация|XML, JSON, YAML, программно.|XML, Groovy.|
|Ротация логов|Встроена.|Встроена.|
|Поддержка SLF4J|Есть.|Есть (Logback — это стандарт SLF4J).|
|Популярность|Чуть менее популярна.|Широко используется.|

#### **2. Почему стоит использовать SLF4J вместо конкретной библиотеки?**

- Унифицированный API: Позволяет переключаться между разными библиотеками (Log4j, Logback) без изменения кода.
- Удобство: Позволяет не зависеть от реализации логирования, сохраняя гибкость.

#### **3. Какие есть преимущества асинхронного логирования?**

- Увеличение производительности: Логирование выполняется в отдельных потоках, что снижает задержки в основном приложении.
- Минимизация влияния на время выполнения: Даже при большом объёме логов производительность остаётся стабильной.

----
![[Pasted image 20250122181127.png]]
