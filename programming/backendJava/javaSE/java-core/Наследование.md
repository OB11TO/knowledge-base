---
title: Наследование
tags:
  - JavaSE
  - OOP
related_topics: 
created: 2024-08-30 12:47
modified: 2025-03-26T12:49:30+03:00
difficulty: easy
questions: 
notes: 
links: 
---

## Краткое описание
==Наследование в Java== - это механизм <mark class="hltr-green2">объектно-ориентированного программирования</mark>, который <mark class="hltr-green2">позволяет</mark> `создавать новый класс на основе существующего (родительского) класса`. Класс, который `наследует свойства и методы `<mark class="hltr-red">от другого класса, называется подклассом или</mark> <mark class="hltr-green">производным</mark> классом, а класс, от которого наследуются свойства и методы, называется родительским классом или суперклассом.

## Полное описание
Процесс наследования <mark class="hltr-yellow">позволяет</mark> создавать `иерархии классов, где подклассы наследуют общие характеристики и поведение от своего родительского класса`. Подклассы могут расширять функциональность родительского класса, добавляя новые поля и методы или переопределяя существующие.

==Наследовать и переопределять можно только нестатические методы.== Статические методы не наследуются и, следовательно, не переопределяются.

У переопределенного метода должны быть те же аргументы, что и у метода родителя, а также а должен быть тот же тип возвращаемого значения, что и у метода родителя. Но ==если ставить аннотацию @Overide, то у неё должно быть и метод одинаково называться==.
```java
public class Animal {
   public void voice(String s) {
       System.out.println("Голос! " + s);
   }
}

public class Cat extends Animal {
   @Override//ошибка!
   public String voice() {    // String вместо void, нет аргументов
       System.out.println("Мяу!");
		return null;
   }
}
```
При наследовании и переопределении можно расширять видимость, но не сужать, а также сужать тип возвращаемого результата, но не расширять.
```java
class Cat
{
 protected String getName() {
  return "Васька"; }

public Cat getMyParent() {
  return this.parent;
 }
}

class Tiger extends Cat
{
 public String getName() //расширили видимость  {
  return "Василий Тигранович";  }

 public Tiger getMyParent() { // сужение с Cat до Tiger
  return (Tiger) this.parent;
 }
}
```

**В Java** не поддерживает **множественное** **наследование** классов. Не поддерживает он его из-за вероятности столкнуться с «проблемой алмаза» и вместо этого предпочитает обеспечивать некий комплексный подход для его решения, используя лучшие варианты из тех, которыми мы можем достичь аналогичный результат **наследования**.

**==Ромбовидное наследование==** — ситуация в объектно-ориентированных языках программирования с поддержкой множественного наследования, когда два класса B и C наследуют от A, а класс D наследует от обоих классов B и C.

При этой схеме наследования !!!!!!!!!`может возникнуть неоднозначность: если объект класса D вызывает метод, определённый в классе A (и этот метод не был переопределен в классе D), а классы B и C по-своему переопределили этот метод, то от какого класса его наследовать: B или C?`

Проблема ромба получила своё название благодаря очертаниям диаграммы наследования классов в этой ситуации.

```Plain Text
	     +--------+
         |   A    |
         | Foo    |
         | Bar    |
         +--------+
            /  \
           /    \
          /      \
+--------+        +--------+
|   B    |        |   C    |
| Foo    |        | Foo    |
+--------+        +--------+
          \      /
           \    /
            \  /
         +--------+
         |   D    |
         |        |
         +--------+
```



------

<mark class="hltr-red">Сокрытие</mark> - это когда <mark class="hltr-green2">дочерний класс определяет статический метод с такой же сигнатурой, что содержится в родительском классе.</mark>

```java

Есть класс:

  public class Test1 {

      public static void test() {

          System.out.println("Hello from test1");

      }

  }

  и его наследник:

  public class Test2 extends Test1 {

      public static void test() {

          System.out.println("Hello from Test2");

      }

  }

  и main метод   public static void main(String[] args) {

                 Test1 t = new Test2();

                 t.test();

             }

```


- Для <mark class="hltr-red">STATIC</mark> <mark class="hltr-green2">методов будет не подлежат переопределению, а скрываются (hiding).</mark>
Переменная `t` <mark class="hltr-yellow">имеет тип</mark> `Test1`, поэтому <mark class="hltr-purple">во время компиляции вызывается метод, определённый в</mark> `Test1`, даже если объект фактически является экземпляром `Test2`.

- Но для <mark class="hltr-red">обычных методов</mark> <mark class="hltr-green2">будет переопределен вызов и вызовется метод из</mark> `Test2`

----

![[Pasted image 20250326124724.png]]

-----

<mark class="hltr-red">Виртуальная функция в Java </mark>— **это функция (метод), которая может быть переопределена наследником**.  [1](https://github.com/ElviraSemenova/Java)

----

