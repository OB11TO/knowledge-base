---
title: Быстрый гайд по String выжимка
tags:
  - JavaSE
related_topics: 
created: 2025-02-07 16:17
modified: 2025-03-24T11:55:26+03:00
questions: 
notes: 
links: 
---

----

### 1. Исторические кодировки: ASCII и Latin-1

**ASCII (American Standard Code for Information Interchange):**

- <mark class="hltr-red">Это старая кодировка, использующая 7 бит для представления символов, что позволяет закодировать 128 символов </mark>(буквы латинского алфавита, цифры, знаки препинания, управляющие символы).
- Если хранить символы ASCII <mark class="hltr-purple">в 8-битном байте, самый старший бит всегда равен нулю.</mark>

**Latin-1 (ISO/IEC 8859-1):**

- Это<mark class="hltr-red"> расширённая 8-битная кодировка, которая включает 256 символов.</mark>
- Первые 128 символов совпадают с ASCII, а оставшиеся 128 добавляют символы, необходимые для записи многих западноевропейских языков (например, буквы с диакритическими знаками, различные знаки валюты и т.п.).

----

### Универсальный стандарт Unicode

**Unicode** – это <mark class="hltr-red">стандарт, цель которого — обеспечить уникальное кодирование для каждого символа, используемого во всех языках мира.</mark>

- В Unicode каждому символу присваивается уникальный номер (кодовая точка), например, U+0041 для буквы «A».
- <mark class="hltr-pink">Благодаря этому стандарту можно работать с тысячами символов, гораздо большими, чем в ASCII или Latin-1.</mark>

Однако<mark class="hltr-red"> Unicode сам по себе лишь определяет набор кодовых точек (номеров) для символов</mark>. <mark class="hltr-green2">Чтобы хранить или передавать текст в формате Unicode, нужно перевести эти номера в последовательность байтов. Именно для этого существуют форматы кодирования.</mark>

------

### Форматы кодирования Unicode: UTF-8 и UTF-16

**UTF-8:**
- Это переменная длина кодировки. <mark class="hltr-green2">Один символ кодируется от 1 до 4 байт</mark>.
    - <mark class="hltr-purple">Если символ входит в стандартный набор ASCII</mark> (кодовые точки от U+0000 до U+007F),<mark class="hltr-purple"> он кодируется одним байтом.</mark>
    - Для остальных символов используются 2, 3 или 4 байта.
- Преимущество UTF-8 в том, что тексты, в которых преобладают английские символы, занимают меньше места, а кодировка полностью обратно совместима с ASCII.

**UTF-16:**
- Здесь<mark class="hltr-green2"> большинство символов кодируется ровно 2 байтами (16 бит).</mark>
- Однако символы, находящиеся за пределами базовой мультилингвальной плоскости (BMP) (то есть с кодовыми точками больше U+FFFF), кодируются парой 16-битных значений (так называемые суррогатные пары), что в сумме даёт 4 байта.
- В Java тип **char** имеет размер 2 байта, поэтому он представляет собой один 16-битный элемент UTF-16. Это означает, что большинство часто используемых символов (из BMP) помещаются в один char, а более редкие – требуют двух char.
----
### Как всё связано в Java

- **Java char:**
    
    - <mark class="hltr-red">Каждый элемент типа **char** занимает 2 байта (16 бит).</mark>
    - Это связано с тем, что <mark class="hltr-green2">Java использует кодировку UTF-16 для представления символов.</mark>
    - Таким образом, даже если вы пишете обычный символ, например, 'A', он хранится как число 65 (в десятичном виде), но именно в 16-битном представлении, что позволяет работать с символами из Unicode.
- **Почему 2 байта, а не 1:**
    
    - В языках вроде C/C++ тип char обычно занимает 1 байт, потому что они ориентировались на ASCII или другие однобайтовые кодировки.
    - Но чтобы обеспечить поддержку всех мировых письменных систем, Java выбрала Unicode, где большинство символов закодированы в 16 бит.
    - Именно поэтому Java char всегда имеет размер 2 байта.
----

**ASCII** – это старейшая кодировка, которая использует 7 бит для представления символов и, соответственно, может кодировать всего 128 символов (от 0 до 127). В ней входят базовые латинские буквы, цифры, знаки препинания и некоторые управляющие символы.

**UTF-8** –<mark class="hltr-green2"> это современный способ кодирования, предназначенный для представления полного набора символов Unicode</mark>. Основные отличия:

- **Переменная длина:**
    - Для символов, соответствующих стандартному набору ASCII (кодовые точки от 0 до 127), UTF-8 использует **1 байт** – таким образом, любой ASCII-текст является одновременно валидным UTF-8.
    - Для символов за пределами ASCII используются 2, 3 или даже 4 байта. Это позволяет кодировать миллионы символов, охватывающих все языки мира.
- **Расширенный диапазон:**
    - ASCII ограничен 128 символами, а UTF-8 может представлять символы из всего стандарта Unicode, что включает буквы, символы, иероглифы, эмодзи и многое другое.
- **Обратная совместимость:**
    - Первые 128 кодовых точек в UTF-8 совпадают с ASCII. Это обеспечивает плавный переход от старых систем к более универсальному представлению текста.

Таким образом, **ASCII** является ограниченным набором символов для базового английского языка, а **UTF-8** – гибкой и расширяемой кодировкой, которая может представить практически любой символ из всех мировых языков.  

-----

<mark class="hltr-red">Например, если строка содержит слово на английском языке, то 8 первых бит у каждого символа будут равны 0, поскольку символ **ASCII** может быть представлен одним байтом вместо двух.</mark>

------
**Компактные строки в Java 9**

<mark class="hltr-orange"> Когда мы создаем строку символы которой могут быть представлены с использованием одного байта – в LATIN-1, то для хранения строк будет использоваться байтовый массив. Но, если какой-либо символ требует более 8 бит для своего представления, то каждый символы сроки будет занимать два байта (UTF-16).</mark>

```java
private final byte[] value;
```

Идентификатор, отвечающий за кодировку **coder**:

```java
private final byte coder;
```

При этом идентификатор поддерживает следующие значения:

```java
static final byte LATIN1 = 0;
static final byte UTF16 = 1;
```

```java
public int indexOf(int ch, int fromIndex) {
    return isLatin1()
            ? StringLatin1.indexOf(value, ch, fromIndex)
            : StringUTF16.indexOf(value, ch, fromIndex);
} 
 
private boolean isLatin1() {
    return COMPACT_STRINGS && coder == LATIN1;
}
```

----

<mark class="hltr-red">Начиная с Java 7, пул строк размещается в куче, на которую распространяется процесс сборки мусора</mark>. Преимуществом данного подхода является снижение вероятности появления ошибки OutOfMemoryError, так как строки, на которые не будет ссылаться ни одна переменная в выполняемой программе, будут удалены сборщиком мусора из пула, что приведет к освобождению памяти.

-----

![[Pasted image 20250207184341.png]]
![[Pasted image 20250207184352.png]]
<mark class="hltr-red">ВОПРОС ПРО STRING SQL АКТУАЛЕН </mark>

------

![[Pasted image 20250207184533.png]]

------

[Дедупликация](https://openjdk.java.net/jeps/192) <mark class="hltr-red">представляет собой не что иное, как переприсваивание виртуальной машиной адресов поля _value_. Т. е. мы выполняем дедупликацию не объектов _String,_ а массивов их байт</mark>

для отслеживания всех уникальных массивов байт, используемых объектами _String,_ используется хеш-таблица. При дедупликации в этой хеш-таблице выполняется поиск идентичных массивов байт (символов).  

![[Pasted image 20250324115516.png]]

При положительном результате значение поля _value_ объекта _String_ переприсваивается так, чтобы указывать на этот существующий массив байт. Соответственно, предыдущий массив байт _value_ становится ненужным — на него ничего не ссылается и впоследствии он попадает под сборку мусора.

---
![[Pasted image 20250207190631.png]]
![[Pasted image 20250207190622.png]]