---
title: Анонимные внутренние классы
tags:
  - InnerClass
  - JavaSE
related_topics: 
created: 2024-08-30 14:03
modified: 2024-11-06T14:20:47+03:00
difficulty: easy
questions: ПОСОМТРЕТЬ ВИДЕО ПРО АНОНИМНЫЕ КЛАССЫ!
notes: 
links: 
---

### Анонимные внутренние классы

В Java анонимный внутренний класс (anonymous inner class) - это специальный вид внутреннего класса, который не имеет имени и ==создается прямо внутри метода или блока кода==. Анонимные внутренние классы предоставляют удобный способ реализации интерфейсов или расширения классов "на лету", без необходимости создавать отдельный класс для каждого случая. Их основное `применение - это реализация одноразовых или небольших функциональных блоков кода.`

Синтаксис создания анонимного внутреннего класса выглядит следующим образом:

```java
interface MyInterface {
    void doSomething();
}

public class MainClass {
    public static void main(String[] args) {
        MyInterface anonymousInnerClass = new MyInterface() {
            @Override
            public void doSomething() {
                System.out.println("Doing something in an anonymous inner class.");
            }
        };

        anonymousInnerClass.doSomething();
    }
}

```

==Плюсы использования анонимных внутренних классов:==

1. Краткость и удобство: Использование анонимных внутренних классов позволяет определить и реализовать функциональность прямо на месте, без необходимости создавать отдельный класс.
2. Обращение к внешним переменным: `Анонимный внутренний класс может обращаться к final переменным из окружающего его контекста`, что позволяет легко передавать данные в такой класс. 
>[!warning] Это ограничение, которое ввели разработчики спецификации: при создании анонимного класса происходит захват объектов по значению, а не по ссылке. В анонимном классе создаются закрытые поля, в которые копируются значения переданных переменных. То есть по сути реализована эмуляция замыканий. Добавление модификатора `final` как бы говорит программисту о том, что при использовании такого рода замыканий не будут наблюдаться побочные эффекты (представьте, что вы передали в созданный объект анонимного класса переменную, а затем изменили её "снаружи" - вы в праве ожидать, что это изменение отразится и внутри замыкания, но это не так в силу пресловутой эмуляции; однако изменение внутреннего состояния `mutable` объектов будет видно и там и там)
3. Инкапсуляция: Анонимные внутренние классы могут обращаться к закрытым полям и методам своего внешнего класса.

==Минусы использования анонимных внутренних классов:==

1. Ограниченность: Анонимные внутренние классы предназначены для реализации простых интерфейсов или расширения одного класса. Если требуется более сложное поведение, лучше использовать именованные внутренние классы или отдельные классы.
2. Читаемость кода: Если анонимные внутренние классы становятся слишком большими и сложными, код может стать менее читаемым.
3. Ограничение доступа: Анонимные внутренние классы не могут быть использованы вне области их создания, что делает их неприменимыми для повторного использования в других частях кода.

Используйте анонимные внутренние классы тогда, когда у вас есть простая функциональность, которую нужно реализовать единожды и не требуется повторного использования. В других случаях, если функциональность более сложная или может быть переиспользована, лучше использовать именованные внутренние классы или статические вложенные классы.

