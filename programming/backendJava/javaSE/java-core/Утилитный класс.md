---
title: Утилитный класс
tags:
  - JavaSE
related_topics: 
created: 2024-09-09 14:24
modified: 2024-09-09T14:29:35+03:00
difficulty: easy
questions: 
notes: 
links:
  - https://www.baeldung.com/java-helper-vs-utility-classes#java-utility-classes
---
## Вспомогательные классы Java

<mark class="hltr-red">Класс утилит в Java</mark> — это **класс, который предоставляет статические методы, доступные для использования в приложении** .<mark class="hltr-yellow"> Статические методы в классах утилит используются для выполнения общих процедур в нашем приложении.
</mark>
<mark class="hltr-green2">**Классы утилит не могут быть инстанцированы**</mark> и иногда не имеют состояния без статических переменных. Мы объявляем класс утилит как _[final](https://www.baeldung.com/java-final) ,_ и все его методы должны быть _static_ .

Поскольку мы не хотим, чтобы наши служебные классы были инстанцированы, <mark class="hltr-yellow">вводится закрытый конструктор</mark>. Наличие **закрытого конструктора означает, что Java не создаст конструктор по умолчанию для нашего служебного класса** . Конструктор может быть пустым.
Целью **служебного класса является предоставление методов для выполнения определенных функций в программе** , в то время как основной класс фокусируется на основной проблеме, которую он решает.

Доступ к методам утилиты осуществляется через имя класса. Это делает наш код более гибким для использования, оставаясь при этом модульным.
### Как создать служебный класс Java[](https://www.baeldung.com/java-helper-vs-utility-classes#1-how-to-create-a-java-utility-class)

Создание класса утилиты не сильно отличается от того, как мы создаем вспомогательный класс. Некоторые вещи делаются немного по-другому при создании класса утилиты.

Для создания класса утилиты <mark class="hltr-yellow">**мы используем модификатор доступа _public_ и также объявляем класс как _final_** </mark>. Ключевое слово _final_ , используемое при создании классов утилиты, означает, что класс останется неизменным. Его нельзя унаследовать или создать экземпляр.

Давайте создадим служебный класс под названием _MyUtilityClass_ :

```java
public final class MyUtilityClass {

    private MyUtilityClass(){}

    public static String returnUpperCase(String stringInput) {
        return stringInput.toUpperCase();
    }

    public static String returnLowerCase(String stringInput) {
        return stringInput.toLowerCase();
    }

    public static String[] splitStringInput(String stringInput, String delimiter) {
        return stringInput.split(delimiter);
    }

}
```

Еще одно правило, которое следует соблюдать, заключается в том, что в<mark class="hltr-yellow">се методы служебного класса являются _статическими_ и имеют модификатор доступа _public_ .</mark>

Поскольку внутри служебных классов у нас есть только статические методы, доступ к этим методам можно получить только через имя класса