---
title: Stack JVM
tags:
  - JavaSE
related_topics: 
created: 2024-12-18 12:58
modified: 2025-04-07T15:59:45+03:00
questions: 
notes: 
links: 
---

---
[[Статическое и динамическое связывание в java]]

---


![[Pasted image 20241218125923.png]]



Давайте разберёмся с понятием **native потоков операционной системы** и их связью с потоками в Java.

**Что такое native поток операционной системы?**

<mark class="hltr-red">Native поток</mark> (или системный поток) — <mark class="hltr-green2">это базовая единица выполнения в операционной системе. Операционная система управляет этими потоками, распределяя их выполнение между процессорами и обеспечивая многозадачность. Каждый процесс может содержать один или несколько таких потоков, которые разделяют общее адресное пространство и ресурсы процесса.</mark>

**Связь между потоками Java и native потоками ОС**

В HotSpot JVM (стандартная реализация JVM от Oracle)<mark class="hltr-green2"> каждый поток, создаваемый в Java, напрямую соответствует native потоку операционной системы</mark>. Это означает, что при создании нового потока в Java J<mark class="hltr-yellow">VM вызывает функции операционной системы для создания соответствующего системного потока</mark>. Операционная система затем управляет планированием и выполнением этого потока.

[Stack Overflow на русском](https://ru.stackoverflow.com/questions/733338/%D0%A1%D0%BE%D0%BE%D1%82%D0%BD%D0%BE%D1%88%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%B2-%D0%B2-java-%D1%81-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%B0%D0%BC%D0%B8-%D0%B2-%D0%9E%D0%A1?utm_source=chatgpt.com)

**Как считать количество потоков в операционной системе?**

Операционные системы предоставляют различные инструменты для мониторинга и управления потоками:

- **В Linux**: Команда `ps -eLf` отображает список всех процессов и их потоков. Также можно использовать `top` и нажать `H` для отображения потоков.
    
- **В Windows**: Диспетчер задач (Task Manager) показывает количество потоков для каждого процесса на вкладке "Подробности". Более подробную информацию можно получить с помощью "Монитора ресурсов" (Resource Monitor).
    

**Почему это важно для Java-разработчика?**

Понимание того, что каждый Java-поток соответствует native потоку ОС, помогает осознать:

- **Ресурсоёмкость**: Создание большого количества потоков может привести к значительной нагрузке на систему, так как каждый поток потребляет определённое количество памяти и других ресурсов.
    
- **Планирование**: Планировщик операционной системы управляет выполнением потоков, что влияет на производительность и поведение многопоточных Java-приложений.
    
- **Отладка и мониторинг**: Понимание связи между Java-потоками и системными потоками облегчает диагностику проблем производительности и состояния приложения.
    

**Пример:**

Предположим, вы разработали Java-приложение, которое создает 1000 потоков для параллельной обработки задач. Поскольку каждый Java-поток соответствует native потоку ОС, операционная система должна управлять всеми этими 1000 потоками одновременно. Это может привести к высокой нагрузке на планировщик ОС, увеличению потребления памяти и снижению общей производительности системы.

Для эффективного управления большим количеством задач в Java рекомендуется использовать пулы потоков (`ThreadPoolExecutor`), которые ограничивают количество одновременно работающих потоков и повторно используют их для выполнения новых задач.

Таким образом, понимание того, что Java-потоки напрямую связаны с native потоками операционной системы, позволяет более эффективно разрабатывать, оптимизировать и отлаживать многопоточные приложения.

При создании в Java количества потоков, превышающего возможности операционной системы, могут возникнуть следующие ситуации:

- **Неудача при создании новых потоков**: JVM может выбросить исключение `OutOfMemoryError: unable to create new native thread`, указывающее на невозможность создания нового потока из-за исчерпания системных ресурсов.
    
- **Снижение производительности**: Избыточное количество потоков приводит к частым переключениям контекста, увеличивая накладные расходы и снижая общую производительность системы.
    
- **Нестабильность системы**: Чрезмерное использование потоков может привести к нестабильной работе приложения и даже всей системы.
    

**Примерные ограничения на количество потоков в операционных системах**:

- **Windows**: Максимальное количество потоков зависит от доступной памяти и настроек системы. Например, в 32-битных системах ограничение может быть ниже из-за меньшего адресного пространства.
    
- **Linux**: Ограничение определяется параметром `threads-max`, который можно узнать с помощью команды `cat /proc/sys/kernel/threads-max`. Это значение можно изменить при наличии соответствующих привилегий, но следует быть осторожным, чтобы не истощить системные ресурсы.
    

**Рекомендации**:

- **Использование пулов потоков**: Ограничьте количество одновременно выполняемых потоков с помощью пулов (`ExecutorService`), что позволит контролировать нагрузку на систему.
    
- **Оптимизация задач**: Разделяйте задачи на более крупные блоки, чтобы уменьшить количество создаваемых потоков и снизить накладные расходы на их управление.
    
- **Мониторинг ресурсов**: Регулярно отслеживайте использование системных ресурсов, чтобы предотвратить их исчерпание и обеспечить стабильную работу приложения.


----

Поток — это поток выполнения программы. JVM позволяет приложению иметь несколько потоков выполнения одновременно (concurrently). В Hotspot JVM существует прямое соответствие между Java потоком и native потоком операционной системы.<mark class="hltr-red"> После подготовки всех компонентов Java потока таких как thread‑local хранилище, allocations буферы, объекты синхронизации, стеки и программные счётчики будет создан native поток.</mark> Native поток (операционной системы) освобождается как только Java поток завершается[1](https://habr.com/ru/articles/739338/#native-vs-java-thread). Операционная система ответственна за планировку и распределение потоков на любом доступном процессоре. Как только native поток инициализирован он вызывает метод run() в Java потоке. Когда run() метод возвращает значение, обрабатываются неперехваченные исключения, потом native поток подтверждает нужно ли завершить работу JVM (needs to be terminated) после завершения потока (напр. последний non‑daemon thread — main). Когда поток завершается все ресурсы native потока и Java потока освобождаются.

Давайте подробно рассмотрим упомянутые термины, связанные с управлением потоками в Java и их взаимодействием с нативными потоками операционной системы:

**1. Thread-local хранилище**

**Thread-local хранилище** (Thread-local storage, TLS) — <mark class="hltr-yellow">это механизм, позволяющий каждому потоку иметь собственные экземпляры переменных, изолированные от других потоков</mark>. В Java для этого используется класс `ThreadLocal`. <mark class="hltr-green2">Он обеспечивает хранение данных, специфичных для конкретного потока, без необходимости явной синхронизации. Это особенно полезно, когда нужно избежать состояния гонки при доступе к общим данным.</mark>

_Пример использования `ThreadLocal` в Java_:

```java
public class UserContext {
    private static ThreadLocal<String> userId = ThreadLocal.withInitial(() -> null);

    public static void setUserId(String id) {
        userId.set(id);
    }

    public static String getUserId() {
        return userId.get();
    }
}
```

В этом примере каждый поток будет иметь собственное значение `userId`, независимое от других потоков.

[Baeldung](https://www.baeldung.com/java-threadlocal?utm_source=chatgpt.com)

**2. Allocation буферы**

**Allocation буферы** — <mark class="hltr-purple">это области памяти, выделенные для управления распределением памяти в контексте потоков</mark>. В Java это реализуется через **Thread Local Allocation Buffers** (TLAB). <mark class="hltr-yellow">Каждый поток получает свой собственный TLAB для выделения новых объектов. Это уменьшает конкуренцию между потоками при выделении памяти и повышает производительность, поскольку каждый поток может выделять память без необходимости синхронизации с другими потоками.</mark>

**3. Объекты синхронизации**

**Объекты синхронизации** <mark class="hltr-green2">используются для управления доступом к разделяемым ресурсам в многопоточных приложениях, предотвращая состояния гонки</mark> и обеспечивая корректность данных. В Java для этих целей применяются:

- **Ключевое слово `synchronized`**: Обеспечивает эксклюзивный доступ к методам или блокам кода.
    
- **Классы из пакета `java.util.concurrent.locks`**: Предоставляют более гибкие механизмы блокировки, такие как `ReentrantLock`.
    

_Пример использования `synchronized`_:
```java
public synchronized void increment() {
    count++;
}
```

В этом примере метод `increment` может быть выполнен только одним потоком одновременно, обеспечивая корректное обновление переменной `count`.

**4. Стеки**

**Стек** — <mark class="hltr-red">это структура данных, используемая для хранения информации о вызовах методов и локальных переменных в процессе выполнения программы</mark>. <mark class="hltr-green2">Каждый поток в Java имеет свой собственный стек, что обеспечивает изоляцию контекста выполнения между потоками.</mark> Стек хранит:

- **Адреса возврата**:<mark class="hltr-yellow"> Указывают, куда вернуться после завершения метода.</mark>
    
- **Локальные переменные**:<mark class="hltr-yellow"> Переменные, объявленные внутри методов</mark>.
    
- **Параметры методов**:<mark class="hltr-yellow"> Аргументы, переданные в метод.</mark>
    

**5. Программные счётчики**

**Программный счётчик** (Program Counter, PC) —<mark class="hltr-purple"> это регистр, который хранит адрес следующей инструкции, подлежащей выполнению</mark>. В Java <mark class="hltr-yellow">каждый поток имеет свой собственный программный счётчик, что позволяет JVM отслеживать выполнение кода в каждом потоке независимо</mark>. Это особенно важно для реализации многозадачности и управления потоками в виртуальной машине.

Понимание этих компонентов помогает глубже разобраться в том, как Java управляет потоками и обеспечивает эффективное и безопасное многопоточное выполнение программ.

---


Если использовать jconsole или любой отладчик, то можно увидеть несколько потоков запущенных в фоновом режиме. Эти фоновые потоки запускаются в дополнении к основному потоку, который создаётся как часть вызова  
`public static void main(String[])` и любого потока созданного основным потоком.

|                                                      |                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| ---------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **Вид потока**                                       | **Описание**                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| Потоки виртуальной машины                            | Ожидают появления операций, которые нужны JVM для достижения безопасной точки (safe-point). Причина, по которой эти операции должны выполняться в отдельном потоке, заключается в том, что все они требуют, чтобы JVM находилась в безопасной точке, где модификации кучи не могут произойти. Тип операций, выполняемых этим потоком сборка мусора "stop-the-world", дамп стека потока, приостановка потока (thread suspension) и biased locking revocation. |
| Поток периодической задачи                           | Отвечает за события таймера (прерывания), которые используются для планирования выполнения периодических задач.                                                                                                                                                                                                                                                                                                                                              |
| GC                                                   | Сборки мусора различного типа, которые появляются в JVM                                                                                                                                                                                                                                                                                                                                                                                                      |
| Потоки компилятора                                   | Компилируют байт-код в машинный код при выполнении программы (runtime)                                                                                                                                                                                                                                                                                                                                                                                       |
| Поток диспетчера сигналов (signal dispatcher thread) | Получает сигналы отправленные JVM процессу и обрабатывает их внутри JVM, вызывая соответствующие JVM методы.--                                                                                                                                                                                                                                                                                                                                               |

---

### Компоненты потока

<mark class="hltr-red">Каждый поток выполнения состоит из следующих компонентов:</mark> программный счётчик (ПС), стек, native стек.

#### 1.2.1 Программный счётчик (ПС)

Если <mark class="hltr-yellow">текущий метод является native методом, тогда ПС не определён, иначе содержит адрес текущей инструкции</mark> (или опкод). <mark class="hltr-green2">Все процессоры имеют программный счётчик, обычно ПС инкрементируется после каждой инструкции и, таким образом, хранит адрес следующей инструкции, которая должна быть выполнена. </mark>JVM использует ПС для отслеживания того, где она выполняет инструкции, ПС на самом деле будет указывать на адрес памяти в области методов.
#### 1.2.2 Стек

Каждый поток<mark class="hltr-yellow"> имеет свой собственный стек, в котором хранится фрейм для каждого метода, выполняющегося в этом потоке</mark>. Стек это LIFO (Last In First Out — последний пришел, первый вышел) структура данных, поэтому текущий выполняющийся метод находится на вершине стека. <mark class="hltr-red">При каждом вызове метода создаётся новый фрейм</mark>.

<mark class="hltr-green2">Напрямую стек не модифицируют, кроме как добавления (push) и удаления (pop) объектов фрейма</mark> и <mark class="hltr-red">поэтому объекты фрейма могут быть аллоцированы в куче </mark>(Heap) <mark class="hltr-red">и нет необходимости в том, чтобы память под эти объекты была непрерывной</mark> (contiguous).

#### 1.2.3 Native стек

<mark class="hltr-purple">Не все JVM поддерживают native методы, однако те, которые поддерживают обычно создают native стек на каждый Java поток</mark>. Если JVM была реализована используя C‑linkage модель для Java Native Invocation (JNI) тогда native стек будет как в Си. В этом случае порядок аргументов и возвращаемое значение будет точно такие же как и в обычной программе на языке Си. Native метод обычно может (зависит от реализации JVM) вызывать Java метод в JVM. Такой вызов будет происходить на Java стеке. Поток покинет native стек и создаст новый фрейм в Java стеке.

----
#### Ограничения стека

<mark class="hltr-yellow">Стек может быть фиксированного или переменного размера</mark>. В случае когда поток запрашивает стек большего размера, чем разрешено, то произойдёт ошибка StackOverflowError. Если поток запрашивает новый фрейм, а памяти для его выделения не хватает, тогда произойдёт ошибка OutOfMemoryError.

#### 1.2.5 Фрейм

<mark class="hltr-yellow">Новый фрейм создаётся и добавляется (pushed) на вершину стека при каждом вызове метода</mark>. Фрейм удаляется (popped), когда метод штатно завершается, или, если во время выполнения метода возникло необработанное исключение. Более подробная информация по обработке исключений будет дана в Таблице Исключений.

<mark class="hltr-red">Каждый фрейм содержит:</mark>

1. <mark class="hltr-green2">Массив локальных переменных</mark>
    
2. <mark class="hltr-yellow">Возвращаемое значение</mark>
    
3. <mark class="hltr-blue">Стек операндов</mark>
    
4. <mark class="hltr-orange">Ссылку на runtime constant pool для класса текущего метода</mark>
    

#### 1.2.6 Массив локальных переменных

<mark class="hltr-green2">Массив локальных переменных содержит все переменные, которые нужны при выполнении метода, включая ссылку на</mark> `this`, <mark class="hltr-green2">все параметры метода и другие локальные переменные</mark>
Для методов класса (статических методов) параметры метода отсчитываются от нуля, однако для метода экземпляра класса нулевой слот зарезервирован для `this`.

Локальные переменные могут иметь следующий тип:<mark class="hltr-green2"> boolean, byte, char, long, short, int, float, double, ссылка (reference), возвращаемый адрес (returnAddress).</mark>

Все типы занимают один слот в массиве локальных переменных, исключая long и double, которые занимают два последовательных слота так как эти типы имеют размер 64 бита, вместо 32 бит.

#### 1.2.7 Стек операндов

<mark class="hltr-blue">Cтек операндов используется во время выполнения инструкций байт‑кода и работает подобно регистрам общего назначения в процессоре</mark>. Большая часть <mark class="hltr-blue">JVM байт‑кода содержит операции со стеком операндов, добавляя (push), удаляя(pop), дублируя, меняя местами (swap) или выполняя операции, которые производят или потребляют значения</mark>. Таким образом, <mark class="hltr-red">инструкции, которые перемещают значения между массивом локальных переменных и стеком операндов очень часто встречаются в байт‑коде</mark>. Например, простая инициализация переменной будет представлена в виде двух инструкций байт‑кода, которые взаимодействуют со стеком операндов.

`int i;` компилируется в следующий байт-код:

```
 0: iconst_0  // добавить 0 на вершину стека операндов 
 1: istore_1  // считать значение из стека операндов и сохранить как локальную переменную с номером 1.
```


---
#### Динамическое связывание

<mark class="hltr-red">Каждый фрейм содержит ссылку на runtime constant pool. Ссылка указывает на constant pool для выполняемого метода класса этого фрейма. Эта ссылка реализует динамическое связывание.</mark>

<mark class="hltr-cyan">Символические ссылки</mark> — <mark class="hltr-pink">это ссылки, которые не указывают напрямую на адрес в памяти, а описывают имя класса, метод, его сигнатуру и т.п</mark>.

Cи/Cи++ код обычно компилируется в объектный файл, потом несколько объектных файлов компонуются вместе в один артефакт, вроде исполняемого файла или библиотеки. Во время фазы компоновки символические ссылки на каждый объект заменяются реальными адресами памяти. В Java эта фаза компоновки выполняется динамически во время исполнения (at runtime).

<mark class="hltr-green2">Когда Java класс скомпилирован, все ссылки на переменные и методы хранятся в class constant pool как символические ссылки.</mark> <mark class="hltr-blue">Символические ссылки это логические ссылки, и они не указывают на адреса физической памяти</mark>. <mark class="hltr-red">JVM реализация может выбрать когда произвести замену ссылок на адреса (resolve), это может произойти когда класс прошёл верификацию, после загрузки, так называемое статическое связывание, или же это может произойти при первом вызове (позднее) связывание.</mark>

Однако JVM придётся вести себя так, как будто связывание произошло при первом использовании ссылки, и выбрасывать ошибки связывания, которые произойдут в этот момент [2](https://habr.com/ru/articles/739338/#primechaniya)
JVM нужно произвести замену символической ссылки на ссылку на класс или метод. Этот процесс происходит при первом использовании, а не при компиляции или загрузке в память. Если при выполненнии JVM выявляет ошибку (например класс на который ссылались не существует), то будет брошено исключение. Таким образом возможна ситуация, когда JVM запущена, но при выполнении кода возникли ошибки.


<mark class="hltr-purple">Binding это процесс когда поле, метод или класс и соответствующие им символические ссылки будут заменены на прямые ссылки</mark>, <mark class="hltr-green2">это случается только один раз потому что символические ссылки будут полностью заменены на адреса физической памяти.</mark> <mark class="hltr-yellow">Если символическая ссылка ссылается на класс, который ещё не был загружен, то этот класс загружается</mark>. Каждая прямая ссылка хранится как смещение в памяти ассоциированная с расположением метода или переменной во время исполнения.


--------
##### **Статический constant pool (.class файл) vs. runtime constant pool (Metaspace)**

- В **.class файле** constant pool – это набор литералов и символических ссылок, созданный компилятором. Это _"сырые данные"_, которые содержат информацию о классах, методах, полях и константах, необходимую для работы программы. 📄✨

- Когда JVM загружает класс, она создаёт **runtime constant pool** в Metaspace. Здесь происходит _разрешение_ символических ссылок – то есть они преобразуются в "живые" ссылки, готовые к использованию во время выполнения. 🔄💥


--------

- **Зачем нужны обе структуры?**

- **Статический constant pool** в .class файле сохраняет неизменный исходный набор данных, с которым работал компилятор. Это позволяет обеспечить независимость компиляции и выполнения. 🎯

```java
// Пример байт-кода (javap -v)
Constant pool:
  #1 = Methodref    #5.#14  // java/lang/Object."<init>":()V
  #2 = String       #15     // "Hello, JVM!"
  #3 = Fieldref     #16.#17 // java/lang/System.out:Ljava/io/PrintStream;
  #4 = Methodref    #18.#19 // java/io/PrintStream.println:(Ljava/lang/String;)V
```

Эти записи — просто текстовые метки, которые JVM не может использовать напрямую. Они нужны только для описания связей между классами, методами и полями.

------

**Metaspace** — это область памяти в JVM (ранее PermGen), где хранится метаинформация о загруженных классах:

- Имена классов, методов, полей.
- Таблицы виртуальных методов (vtable).
- <mark class="hltr-yellow">Разрешенные ссылки (замененные символические ссылки из Constant Pool).
</mark>
- Аннотации, generics-информация и т.д.


![[Pasted image 20250328143414.png]]

----------

  **Runtime constant pool** – это уже оптимизированная структура, адаптированная к текущему выполнению программы. Она поддерживает динамическое связывание, кеширование и оптимизацию (например, интернирование строк). Это помогает ускорить работу программы и облегчает динамическое обновление ссылок во время выполнения. 🚀💡

---
###  **Почему нельзя хранить всё в .class файле**

- **Эффективность памяти**:  
    В `.class` файле Constant Pool содержит избыточные данные (например, полные имена классов в виде строк). В Metaspace информация хранится в оптимизированном виде (например, как указатели или индексы).
    
- **Динамическая природа JVM**:  
    Классы могут быть загружены, перезагружены или удалены (через ClassLoaders). Metaspace позволяет JVM гибко управлять метаданными в памяти.
    
- **Производительность**:  
    Доступ к памяти (Metaspace) на порядки быстрее, чем парсинг байт-кода из `.class` файла.

-----

### **Пример: жизнь символической ссылки**

```java
public class User {
    public void print() {
        System.out.println("I'm a user!");
    }
}
```
В `.class` файле:
```java
Constant pool:
  #1 = Methodref #5.#14 // java/lang/Object."<init>":()V
  #2 = Fieldref #15.#16 // java/lang/System.out:Ljava/io/PrintStream;
  #3 = String #17 // "I'm a user!"
  #4 = Methodref #18.#19 // java/io/PrintStream.println:(Ljava/lang/String;)V
```

#### Загрузка в JVM
- JVM загружает класс `User`, парсит его Constant Pool.
- Для `System.out` (`#2`):
    - Загружает класс `java/lang/System`, если он еще не загружен.
    - Находит поле `out` и запоминает его **реальный адрес** в Metaspace.

#### Выполнение
- При первом вызове `print()`:
    - `System.out` заменяется на сохраненный адрес из Metaspace.
    - `println` разрешается в указатель на код метода.
- Все последующие вызовы используют данные из Metaspace напрямую.

---------

### **Динамическое связывание в действии**

```java
class Animal { void sound() { ... } }
class Dog extends Animal { void sound() { ... } }
```

В байт-коде вызов `animal.sound()` выглядит как `invokevirtual #X` (ссылка на метод `sound`).  
**В рантайме**:
- JVM определяет реальный тип объекта (например, `Dog`).
- Ищет метод `sound` в vtable класса `Dog`.    
- Подменяет символическую ссылку на адрес `Dog.sound()`.

**Без Metaspace** JVM пришлось бы каждый раз искать метод в иерархии классов, что крайне неэффективно.


******
### ** Constant Pool в Metaspace**

- **Переносимость**: Байт-код не привязан к конкретной JVM или окружению.
- **Оптимизация**: Разрешенные ссылки хранятся в памяти для мгновенного доступа.
- **Гибкость**: Классы могут динамически загружаться и выгружаться.
- **Безопасность**: Проверка прав доступа (например, `private` методы) происходит при разрешении ссылок.



-----

![[Pasted image 20250404142512.png]]
![[Pasted image 20250404142522.png]]

### 🔥 **Где хранится связь между `Test` и Metaspace?**

✅ У каждого загруженного класса есть **Class Object в Metaspace**, который содержит **указатель на Runtime Constant Pool**.  
✅ У каждого объекта есть **ссылка на свой Class Object**.  
✅ Поэтому JVM сначала идёт в объект → `klass` → `runtime_cp` и находит нужный метод! 🚀


------
