---
title: Байт-код Java
tags:
  - JavaSE
related_topics: 
created: 2025-04-02 16:01
modified: 2025-04-02T17:41:32+03:00
questions: 
notes: 
links:
  - https://habr.com/ru/articles/264919/
---


![[Pasted image 20250402162334.png]]
- Библотека для дефакто стандарт для работы с байт кодом

----
- <mark class="hltr-green2"> Запись в поиске аннотаций </mark>

![[Pasted image 20250402162533.png]]
![[Pasted image 20250402162550.png]]

----

![[Pasted image 20250402162624.png]]

----
![[Pasted image 20250402162811.png]]

------
![[Pasted image 20250402163137.png]]
- <mark class="hltr-yellow">Если кладем на 0 значение, то это значит мы в статическом методе, иначе нужно было класть от 1 и более, так как 0 всегда содержит this</mark>

----
![[Pasted image 20250402163321.png]]

![[Pasted image 20250402163342.png]]

----

![[Pasted image 20250402163401.png]]
![[Pasted image 20250402163416.png]]
![[Pasted image 20250402163428.png]]

------
![[Pasted image 20250402163522.png]]

- Реальный пример
![[Pasted image 20250402163549.png]]

-----
![[Pasted image 20250402163653.png]]
- <mark class="hltr-green2">Фреймы</mark> 

----
![[Pasted image 20250402163737.png]]
![[Pasted image 20250402163821.png]]
![[Pasted image 20250402163832.png]]
![[Pasted image 20250402163936.png]]

-----

![[Pasted image 20250402165218.png]]


-----
![[Pasted image 20250402165426.png]]
![[Pasted image 20250402165522.png]]
![[Pasted image 20250402165507.png]]

------------

**Стековая машина** для вычислений использует только стек, постоянно добавляя на него новые значения либо снимая старые, что приводит к непрерывному изменению вершины стека.  [1](https://ps-group.github.io/compilers/stack_and_register)

**Регистровая машина** может использовать стек, но кроме него использует также независимые регистры, распределяя и переиспользуя их для последовательных вычислений.

------

Абстрактная стековая машина — это модель вычислений, основанная на стеке данных. Все операции выполняются с использованием стека: операнды помещаются на стек, операции извлекают их, выполняют вычисления и возвращают результат обратно на стек. Примеры таких машин включают виртуальные машины (JVM, CPython) и некоторые языки низкого уровня (Forth).

---

#### **Основные концепции**

1. **Стек операндов** (Operand Stack):  
    Основная структура данных, где хранятся значения для операций. Работает по принципу **LIFO** (Last In, First Out).
    
2. **Инструкции**:  
    Команды, которые манипулируют стеком: добавляют/удаляют элементы, выполняют вычисления, управляют потоком выполнения.
    
3. **Отсутствие регистров**:  
    Все операции выполняются через стек, что упрощает архитектуру, но может увеличить количество инструкций.
    

---

#### **1. Управление стеком операндов**

Инструкции для манипуляции данными на стеке (LIFO-структура):

- **`push`-подобные**:
    
    - `iconst_0`, `bipush`, `ldc` — помещают константы на стек.
        
    - Пример: `ldc "Hello"` → загружает строку "Hello" на стек.
        
- **`pop`-подобные**:
    
    - `pop`, `pop2` — удаляют верхние элементы стека.
        
- **Дублирование и обмен**:
    
    - `dup`, `dup_x1`, `swap` — дублируют или меняют элементы.


```java
iload_1     // Загружает int из локальной переменной 1 на стек
iload_2     // Загружает int из локальной переменной 2 на стек
iadd        // Складывает два верхних int-значения
istore_3    // Сохраняет результат в локальную переменную 3
```

#### **2. Арифметические операции**

Инструкции для математических вычислений:

- **Целочисленные**:
    
    - `iadd`, `isub`, `imul`, `idiv`, `irem` (остаток).
        
- **Вещественные**:
    
    - `fadd`, `dsub` и т.д. (для `float` и `double`).
        
- **Битовые операции**:
    
    - `ishl` (сдвиг влево), `iand` (логическое И).
        

```java
iload_0
iconst_2
imul       // Умножает значение из переменной 0 на 2
```


#### **3. Работа с локальными переменными и памятью**

Инструкции для чтения/записи данных:

- **Локальные переменные**:
    
    - `iload`, `istore` — для `int`.
        
    - `aload`, `astore` — для ссылочных типов.
        
- **Массивы**:
    
    - `iaload`, `iastore` — доступ к элементам массива.
        
    - `arraylength` — длина массива.

```java
aload_0         // Загружает ссылку на объект (this) на стек
getfield #5     // Извлекает поле объекта
```

#### **. Управление потоком выполнения**

Инструкции для ветвлений и циклов:

- **Безусловные переходы**:
    
    - `goto`, `jsr` (устаревший).
        
- **Условные переходы**:
    
    - `ifeq` (если равно 0), `if_icmplt` (сравнение int).
        
- **Вызов методов**:
    
    - `invokevirtual`, `invokestatic`, `invokeinterface`.

```java
iload_1
iload_2
if_icmpge Label // Переход, если переменная 1 >= переменной 2
```

#### **5. Работа с объектами**

Инструкции для создания и управления объектами:

- **Создание объектов**:
    
    - `new` — выделяет память под объект.
        
    - `invokespecial` — вызывает конструктор.
        
- **Доступ к полям**:
    
    - `getfield`, `putfield` — нестатические поля.
        
    - `getstatic`, `putstatic` — статические поля.
        

```java
new java/lang/StringBuilder   // Создает объект
dup                           // Дублирует ссылку (для конструктора)
invokespecial StringBuilder.<init>() // Вызов конструктора
```

#### **6. Обработка исключений**

Инструкции для работы с исключениями:

- `athrow` — генерирует исключение.
    
- Блоки `try-catch` реализуются через таблицы исключений в метаданных класса (не через явные инструкции).

```java
try_start:
  aload_0
  invokevirtual readFile()V
try_end:
  ...
catch (IOException e) {
  // Обработка в байт-коде через таблицу исключений
}
```

#### **7. Синхронизация**

Инструкции для многопоточности:

- `monitorenter` — захват монитора объекта (начало synchronized-блока).
    
- `monitorexit` — освобождение монитора.

```java
aload_1           // Загружает объект для синхронизации
monitorenter      // Захват монитора
...               // Критическая секция
monitorexit       // Освобождение
```

-----------

![[Pasted image 20250402172026.png]]

![[Pasted image 20250402172121.png]]

Хотя class-файл напрямую не человекочитаемый, в JDK есть инструмент под названием **javap**, который выводит его содержимое в удобном формате.  
  
Давайте напишем простую программу на Java, указанную ниже.

![[Pasted image 20250402172227.png]]
![[Pasted image 20250402172242.png]]
![[Pasted image 20250402172349.png]]

------

https://habr.com/ru/articles/264919/

----

### **Constant Pool (пул констант) в Java: как он связан с ограничением в 65535**

Пул констант — это специальная структура данных внутри Java-класса (`.class` файла), которая хранит все константы, используемые в классе. Сюда входят:

- Строковые литералы (например, `"Hello, World!"`).
    
- Имена классов, методов и полей.
    
- Сигнатуры методов.
    
- Числовые константы (`int`, `float`, `long`, `double`).
    
- Ссылки на другие классы и методы.


### **Как работает пул констант**

1. **Структура**:  
    Каждая константа в пуле имеет уникальный индекс (начиная с 1). Например:
    
    - `#1 = Class ...` (ссылка на класс).
        
    - `#2 = String ...` (строка).
        
    - `#3 = Methodref ...` (ссылка на метод).
        
2. **Использование в байт-коде**:  
    Инструкции байт-кода ссылаются на константы через их индексы. Например:

```java
ldc #2  // Загружает строку из пула констант с индексом 2.
```
**Особые типы**:

- `long` и `double` занимают **два слота** в пуле (из-за их 64-битной природы).  
    Например, константа `double 3.14` будет использовать индексы `#5` и `#6`.

----
### **Почему ограничение 65535?**

- Индексы констант в байт-коде хранятся как **16-битные беззнаковые числа** (от 1 до 65535).
    
- Если количество констант превысит 65535, компилятор выдаст ошибку:  
    `Constant pool for class has grown past JVM limit of 0xFFFF`.

-----

### **Как возникает проблема при генерации кода?**

При автоматической генерации Java-кода (например, через ASM, Javassist или аннотации) пул констант может переполниться из-за:
**Большого количества строк**:
1. **Множества классов и методов**:  
    Каждое имя класса, метода или поля добавляет записи в пул.
    
2. **Динамической генерации**:  
    Например, создание классов через `javac` или инструменты вроде Lombok, которые генерируют код на лету.
    
3. **Аннотаций**:  
    Аннотации с параметрами добавляют константы в пул.

------
