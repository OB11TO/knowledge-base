---
title: Флаги JVM
tags:
  - JavaSE
related_topics: 
created: 2025-04-02 16:08
modified: 2025-04-02T16:08:29+03:00
questions: 
notes: 
links: 
---



### Подробное описание JVM флагов и их настройки

---

#### **1. `-XX:-OmitStackTraceInFastThrow`**

- **Назначение**: JVM по умолчанию может оптимизировать повторяющиеся исключения, заменяя их на "быстрые" исключения без стека. Этот флаг отключает оптимизацию, сохраняя полный стектрейс.
    
- **Когда использовать**:
    
    - В продакшене для отладки, если возникают исключения без стека (например, `NullPointerException`, `ArrayIndexOutOfBoundsException`).
        
    - Пример: приложение логирует ошибку `NullPointerException`, но стектрейс отсутствует.
        
- **Риски**: Увеличивает накладные расходы на генерацию исключений.
    
- **Аналог**: `-XX:+OmitStackTraceInFastThrow` (включено по умолчанию).
    

---

#### **2. `-Xmx` и `-Xms`**

- **Назначение**:
    
    - `-Xmx` (максимальный размер хипа): Указывает максимальный объем памяти, который JVM может использовать.
        
    - `-Xms` (начальный размер хипа): Указывает начальный размер памяти.
        
- **Пример**: `-Xms4G -Xmx16G` — старт с 4 ГБ, расширение до 16 ГБ.
    
- **Когда использовать**:
    
    - Для предотвращения частого изменения размера хипа (установите `-Xms=-Xmx`, если возможен резкий рост нагрузки).
        
    - При `OutOfMemoryError` — увеличить `-Xmx`.
        
- **Риски**: Слишком большой `-Xmx` может привести к длительным паузам GC.
    

---

#### **3. `-Xmn`**

- **Назначение**: Размер молодого поколения (Young Generation) в хипе.
    
- **Пример**: `-Xmn2G` — выделяет 2 ГБ под молодое поколение.
    
- **Когда использовать**:
    
    - Для настройки баланса между частотой minor GC и длительностью пауз.
        
    - Уменьшение `-Xmn` увеличивает частоту minor GC, но сокращает паузы.
        
- **Риски**: Слишком большой размер может сократить место для старшего поколения (Old Gen), провоцируя частые Full GC.
    

---

#### **4. `-XX:NativeMemoryTracking=[summary | detail]`**

- **Назначение**: Включает отслеживание нативной памяти (вне хипа), например, память под метаспейс, стеки потоков, буферы NIO.
    
- **Пример**: `-XX:NativeMemoryTracking=detail`.
    
- **Когда использовать**:
    
    - Диагностика утечек нативной памяти (например, `java.lang.OutOfMemoryError: Native memory`).
        
    - Анализ с помощью `jcmd <pid> VM.native_memory summary/detail`.
        
- **Риски**: Накладные расходы на сбор статистики (~5-10% производительности).
    

---

#### **5. `-XX:MaxMetaspaceSize`**

- **Назначение**: Максимальный размер Metaspace (хранит метаданные классов).
    
- **Пример**: `-XX:MaxMetaspaceSize=512M` — ограничение до 512 МБ.
    
- **Когда использовать**:
    
    - При `OutOfMemoryError: Metaspace` (например, из-за утечки классов при горячем деплое).
        
    - По умолчанию Metaspace не ограничен, что может привести к исчерпанию памяти ОС.
        
- **Риски**: Слишком маленькое значение может вызвать ошибки при загрузке классов.
    

---

#### **6. `-XX:MinMetaspaceFreeRatio` и `-XX:MaxMetaspaceFreeRatio`**

- **Назначение**:
    
    - `MinMetaspaceFreeRatio` (по умолчанию 40%) — минимальный процент свободного места в Metaspace. Если меньше — JVM увеличивает размер.
        
    - `MaxMetaspaceFreeRatio` (по умолчанию 70%) — если свободно больше — JVM уменьшает размер.
        
- **Когда использовать**:
    
    - Для контроля за динамическим изменением размера Metaspace.
        
    - Пример: `-XX:MinMetaspaceFreeRatio=50 -XX:MaxMetaspaceFreeRatio=80`.
        

---

#### **7. `-XX:CompressedClassSpaceSize`**

- **Назначение**: Размер области памяти для сжатых указателей (compressed oops) классов. Максимум — 3 ГБ.
    
- **Пример**: `-XX:CompressedClassSpaceSize=2G`.
    
- **Когда использовать**:
    
    - При использовании 64-битной JVM с большим количеством классов.
        
    - По умолчанию — 1 ГБ.
        

---

#### **8. `-XX:+PrintGCDetails` / `-Xlog:gc*`**

- **Назначение**: Логирование информации о сборке мусора.
    
- **Пример**:
    
    - Старый формат: `-XX:+PrintGCDetails -Xloggc:gc.log`.
        
    - Новый (Java 9+): `-Xlog:gc*,heap=info:file=gc.log:time`.
        
- **Когда использовать**:
    
    - Для анализа пауз GC и оптимизации хипа.
        
    - Выявление частых Full GC или долгих пауз.
        

---

#### **9. `-XX:InitialCodeCacheSize` и `-XX:ReservedCodeCacheSize`**

- **Назначение**: Управление размером кэша JIT-компилированного кода.
    
- **Пример**: `-XX:ReservedCodeCacheSize=512M`.
    
- **Когда использовать**:
    
    - При ошибках `CodeCache is full` — увеличить `ReservedCodeCacheSize`.
        
    - Для приложений с большим количеством динамически генерируемого кода (например, через ASM).
        

---

#### **10. `-Xss`**

- **Назначение**: Размер стека потока.
    
- **Пример**: `-Xss256k` (по умолчанию 1 МБ в Linux).
    
- **Когда использовать**:
    
    - При `StackOverflowError` — увеличить значение.
        
    - Для экономии памяти при большом количестве потоков.
        
- **Риски**: Слишком маленький стек может вызвать `StackOverflowError`.
    

---

#### **11. `-XX:MaxDirectMemorySize`**

- **Назначение**: Максимальный размер прямой памяти (NIO Buffers).
    
- **Пример**: `-XX:MaxDirectMemorySize=2G`.
    
- **Когда использовать**:
    
    - При `OutOfMemoryError: Direct buffer memory`.
        
    - Если приложение активно использует `ByteBuffer.allocateDirect()`.
        

---

#### **12. `-XX:+DisableExplicitGC`**

- **Назначение**: Игнорировать вызовы `System.gc()`.
    
- **Когда использовать**:
    
    - Для предотвращения внеплановых Full GC (например, в библиотеках, вызывающих `System.gc()`).
        
- **Риски**: Может привести к утечкам прямой памяти, если `System.gc()` используется для её очистки.
    

---

#### **13. `-XX:+ExplicitGCInvokesConcurrent`**

- **Назначение**: Выполнять `System.gc()` в фоновом режиме (например, с использованием CMS или G1).
    
- **Когда использовать**:
    
    - Если `System.gc()` необходим, но нужно избежать длительных пауз.
        

---

#### **14. `-XX:+UseLargePages`**

- **Назначение**: Использование больших страниц памяти (2 МБ вместо 4 КБ).
    
- **Когда использовать**:
    
    - Для снижения TLB-промахов и улучшения производительности.
        
    - Требует настройки ОС (например, Linux: `sudo sysctl -w vm.nr_hugepages=2048`).
        

---

#### **15. `-XX:+UseBiasedLocking` и `-XX:BiasedLockingStartupDelay`**

- **Назначение**: Оптимизация синхронизации для мониторов, используемых одним потоком.
    
- **Пример**: `-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0` (включить сразу).
    
- **Когда использовать**:
    
    - В приложениях с высокой конкуренцией за блокировки.
        
    - В Java 15+ biased locking удалён, флаги игнорируются.
        

---

### **Реальный кейс: Оптимизация Spring Boot-приложения**

**Проблема**: Приложение падает с `OutOfMemoryError: Metaspace` после нескольких деплоев на сервере.  
**Анализ**:

- При деплое создаются новые класслоадеры, которые не выгружаются, что приводит к росту Metaspace.
    
- GC не очищает Metaspace, так как класслоадеры не удаляются.
    

**Решение**:

1. Установить ограничение:  
    `-XX:MaxMetaspaceSize=512M` — предотвращает исчерпание памяти ОС.
    
2. Включить выгрузку классов для CMS/G1:  
    `-XX:+CMSClassUnloadingEnabled` (для CMS)  
    `-XX:+ClassUnloading` (по умолчанию включено для G1).
    
3. Настроить Native Memory Tracking для мониторинга:  
    `-XX:NativeMemoryTracking=detail`.
    
4. Проверить логи GC:  
    `-Xlog:gc*,metaspace=debug:file=gc.log:time`.
    

**Результат**: Metaspace перестал расти бесконтрольно, ошибки прекратились.