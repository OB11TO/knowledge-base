---
title: Garbage Collector
tags:
  - JavaSE
related_topics: 
created: 2025-01-27 17:54
modified: 2025-02-03T12:58:55+03:00
questions: 
notes: 
links:
  - https://ziginsider.github.io/Garbage_Collector_Java/
---



-----
[[Serial GC и Parallel GC]]
[[CMS и G1]]

------

## Garbage Collector
Поиском и освобождением ненужных участков в памяти в `JVM` занимается специальный процесс, который называется `garbage collector` или коротко `GC`. У `Garbage Collector` всего две задачи - это `обнаружение` и `очистка` мусора.

> <mark class="hltr-red">Мусор</mark> - это все объекты, <mark class="hltr-yellow">которые не относятся к корневому множеству</mark> (<mark class="hltr-purple">объекты в статических полях, объекты доступные из стека, объекты из JNI ссылок на нативные методы</mark>), 
> <mark class="hltr-yellow">и на которые не ссылаются живые</mark>.

Существует несколько реализаций `GC`, работающих по различным алгоритмам, каждый из которых по своему решает проблему отслеживания и уничтожения уже ненужных объектов. Какие-то реализации лучше работают на больших размерах `heap`-а, какие-то лучше работают на средних размерах и меньше.

> При этом по спецификации нет никаких правил для реализации `GC`, кроме соблюдения корректности - это значит, что нельзя собирать объекты, которые в будущем в приложении будут использоваться.

Мы уже много раз сказали слово "ненужные" объекты. Но как определить, что объект ненужен, что объект не используется и это мусор?

<mark class="hltr-red">Существует несколько подходов для поиска мусора:</mark>
- Reference counting
![[Pasted image 20250128132215.png]]
![[Pasted image 20250128132253.png]]


## Tracing
Этот подход вводит новое поняте - `GC Root` или корень, якорь(чуть ниже мы поясним что это такое).

Главную идею подхода можно сформулировать как:

> Живые объекты - это те, до которых мы можем добраться от корня (`GC Root`), в то время как все остальные являются мусором.
> 
> Все что доступно с живого объекта - также живое.

```java
Person p = new Person();
p.setFlat(new Flat());
p.setCar(new Car());
p.getCar().setEngine(new Engine());
p.getCar().setHorn(new Horn())
```
![[Pasted image 20250128132413.png]]
![[Pasted image 20250128132520.png]]


---

### Очистка памяти

Очистка памяти процесс довольно сложный, поэтому было также разработано несколько алгоритмов, выполняющих эту задачу.

Рассмотрим какие алгоритмы очистки существуют.

#### Copying collectors
![[Pasted image 20250128133334.png]]




------



![[Pasted image 20250128133745.png]]



-----

![[Pasted image 20250128133937.png]]
![[Pasted image 20250128151917.png]]



----


![[Pasted image 20250128134846.png]]

![[Pasted image 20250128134940.png]]

-----

![[Pasted image 20250128135001.png]]

-----

![[Pasted image 20250128135558.png]]

![[Pasted image 20250128135610.png]]


------

![[Pasted image 20250128135633.png]]



-----

![[Pasted image 20250128135756.png]]

-----

![[Pasted image 20250128135810.png]]



-----

![[Pasted image 20250128135839.png]]


-----

![[Pasted image 20250128135857.png]]



-----

![[Pasted image 20250128135916.png]]
![[Pasted image 20250128135928.png]]
![[Pasted image 20250128135946.png]]


-----


![[Pasted image 20250128141550.png]]




----


![[Pasted image 20250128141717.png]]

### Что такое escape analysis и как она влияет на аллокацию объектов?

- **Escape analysis** позволяет JVM определить, «выходит» ли ссылка на созданный объект за пределы метода или потока. Если JVM докажет, что объект не «убегает» (то есть не сохраняется в переменной, которая потом используется за пределами текущего метода, не возвращается из метода, не передается в другой поток и т.д.), то она может:
    - Либо полностью исключить выделение объекта («scalar replacement»): вместо создания объекта JVM просто подставляет его поля (значения примитивных типов или даже ссылки) прямо в регистрах или в локальном стеке.
    - Либо выделить объект на стеке вместо кучи. Тогда объект «прилипает» к фрейму метода, и после выхода из метода память для него освобождается автоматически без необходимости работы сборщика мусора.

### При каких условиях это возможно?

1. **Объект должен быть локальным**  
    Он создаётся внутри метода, и ни одна его ссылка не покидает этот метод. Если объект не передаётся как параметр в другие методы, не сохраняется в полях других объектов или в глобальных структурах, то JVM может считать, что его жизненный цикл ограничен текущим фреймом стека.
    
2. **Отсутствие «утечек» (escape)**  
    Если объект не «убегает» — то есть ссылка на него не сохраняется в переменной, которая может использоваться вне метода (например, возвращается из метода или записывается в поле, доступное из другого потока) — то JVM имеет возможность применить данную оптимизацию.
    
3. **Кратковременность объекта**  
    Объект, который используется только в рамках одного метода (или даже в рамках одного внутреннего цикла), является кандидатом для таких оптимизаций, поскольку его жизненный цикл строго ограничен.
    

### Итог

- **Стандартное поведение:** Оператор new всегда создаёт объект в куче, и ссылка на него хранится в стеке.
- **Оптимизация через escape analysis:** Если JVM обнаружит, что объект не покидает метод (то есть он «не сбегает»), то она может либо вообще не выделить память для этого объекта (scalar replacement), либо выделить его в стеке. Эти оптимизации происходят на уровне JIT-компиляции и являются внутренним решением JVM, недоступным для прямого управления со стороны программиста.

Также стоит отметить, что такие оптимизации являются особенностью конкретной реализации JVM (например, Oracle HotSpot поддерживает escape analysis с достаточно агрессивными оптимизациями), и программист не может явно указать, чтобы объект был выделен на стеке.

Таким образом, в Java объекты могут быть «стековыми» неявно благодаря escape analysis, если они:

- создаются локально внутри метода,
- не покидают этот метод (не сохраняются в более долговечных структурах) и
- используются кратковременно.

Эта оптимизация помогает уменьшить нагрузку на сборщик мусора и повысить производительность за счёт более быстрого выделения и освобождения памяти.




-----


## **Основные понятия**

4. **Heap (куча)** — основная область памяти, где хранятся объекты.
5. **Generational Hypothesis** — гипотеза, согласно которой большинство объектов живут недолго ("молодые" объекты), а долгоживущие объекты редко умирают.
6. **Stop-the-World (STW)** — пауза, во время которой все потоки приложения останавливаются для выполнения сборки мусора.
7. **Concurrent** — процесс, который выполняется параллельно с работой приложения, минимизируя STW-паузы.


-----

![[Pasted image 20250129161653.png]]

