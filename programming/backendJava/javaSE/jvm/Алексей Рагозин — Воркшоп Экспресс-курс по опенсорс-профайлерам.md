---
title: Алексей Рагозин — Воркшоп Экспресс-курс по опенсорс-профайлерам
tags:
  - JavaSE
related_topics: 
created: 2025-04-04 16:46
modified: 2025-04-07T14:19:25+03:00
questions: 
notes: 
links: 
---


----

![[Pasted image 20250404164647.png]]


![[Pasted image 20250404171934.png]]

- <mark class="hltr-pink"> В топе видим методы</mark>, которые <mark class="hltr-red">либо тратят много времени</mark> на выполнения <mark class="hltr-orange">или которые вызываются слишком часто </mark>
Но Cunncurnt GET() не может тратить много времени, значит он вызывается лишком часто<mark class="hltr-purple">, как часто ????</mark> <mark class="hltr-yellow">НО ЧЕРЕЗ СЕМПЛИРОВАНИЕ  мы посмотреть это не сможем </mark>


- <mark class="hltr-green2">Для этого есть ТРАССИРОВКА </mark>
- Она делается через вкладку <mark class="hltr-yellow">Profiler</mark>  



-----

**JFR, JMH, бенчмарки и другие инструменты для анализа производительности в Java**

### 1. **JFR (Java Flight Recorder)**

- **Что это?**  
    JFR — это встроенный в JVM (Java Virtual Machine) инструмент для сбора диагностических данных о работе приложения в реальном времени. Он позволяет записывать события (например, использование CPU, памяти, блокировки, GC-паузы) с минимальными накладными расходами.
    
- **Зачем нужен?**  
    Для анализа производительности, поиска узких мест (bottlenecks), утечек памяти, проблем с многопоточностью. Часто используется вместе с **JMC (Java Mission Control)** для визуализации данных.
    
- **Пример использования:**  
    Запуск JFR для веб-приложения под нагрузкой, чтобы выявить долгие SQL-запросы или частые GC-паузы.
    

---

### 2. **JMH (Java Microbenchmark Harness)**

- **Что это?**  
    Фреймворк для написания микротестов производительности (микробенчмарков). Разработан командой OpenJDK для точного измерения времени выполнения небольших фрагментов кода.
    
- **Почему именно JMH?**  
    Обычные замеры через `System.currentTimeMillis()` ненадежны из-за оптимизаций JVM (JIT-компиляция, прогрев кода), влияния окружения (GC, другие процессы). JMH решает эти проблемы:
    
    - Учет прогрева (warmup-итерации).
        
    - Защита от оптимизаций (например, «съедание» неиспользуемых результатов).
        
    - Статистическая обработка данных.
        
- **Пример кода:**
    
```java
@Benchmark
@BenchmarkMode(Mode.AverageTime)
@OutputTimeUnit(TimeUnit.NANOSECONDS)
public void testMethod() {
    // Код, который нужно измерить
}
```

    
- **Запуск:**  
    Через Maven/Gradle или отдельный JAR-файл.
    

---

### 3. **Бенчмарки (тесты производительности)**

- **Что это?**  
    Тесты для оценки производительности системы или её компонентов. Бывают:
    
    - **Микробенчмарки:** <mark class="hltr-green2">Измерение скорости работы небольшого фрагмента кода</mark> (например, сортировки массива). Инструмент: **JMH**.
        
    - **Макробенчмарки:** <mark class="hltr-yellow">Тестирование всей системы под нагрузкой</mark> (например, скорость обработки HTTP-запросов). Инструменты: **JMeter**, **Gatling**.
        
- **Лучшие практики:**
    
    - Избегать «синтетических» тестов, максимально приближать к реальным условиям.
        
    - Учитывать влияние JVM (прогрев, GC).
        
    - Проводить замеры многократно и на разных версиях кода.
        

---

### 4. **Связь JFR и JMH**

- **JMH** используется для точного измерения производительности конкретного кода.
    
- **JFR** помогает анализировать общее поведение приложения во время выполнения бенчмарков (например, обнаружить, что GC «съедает» 30% времени).
    

---

### 5. **Другие инструменты**

- **Профилировщики:**  
    Async Profiler, VisualVM, YourKit — для анализа использования CPU и памяти.
    
- **Нагрузочное тестирование:**  
    JMeter, Gatling, wrk — для тестирования API, веб-приложений.
    
- **Мониторинг:**  
    Prometheus + Grafana, New Relic — для сбора метрик в реальном времени.
    

---

### Пример рабочего процесса:

1. Написать микробенчмарк через **JMH** для спорного алгоритма.
    
2. Запустить его, убедиться в стабильности результатов.
    
3. Если производительность низкая, использовать **JFR** для детального анализа.
    
4. Исправить код, повторить тесты.
    

---

**Итог:**  
JFR и JMH — ключевые инструменты для оптимизации Java-приложений. JMH дает точные замеры на микроуровне, а JFR помогает понять системные проблемы. Используйте их вместе для глубокого анализа производительности.