---
title: Статическоaе и динамическое связывание в java
tags:
  - JavaSE
related_topics: 
created: 2024-12-18 17:15
modified: 2024-12-18T19:27:12+03:00
questions: 
notes: 
links: 
---


### Динамическое связывание в Java и его отличие от C/C++

#### 1. **Общее понимание связывания**

**Связывание (binding)** — это процесс установления связи между символической ссылкой в коде и конкретным объектом, методом или полем в памяти.

- В C/C++ это обычно происходит **на этапе компоновки (linking)**, когда все символы заменяются на их физические адреса в памяти. Это называется **статическое связывание**.
- В Java процесс связывания происходит **динамически**, во время выполнения программы (runtime). Это называется **динамическое связывание (late binding)**.

---

#### 2. **Как работает динамическое связывание в Java**

Когда компилируется Java-класс:

1. Все ссылки на методы и переменные сохраняются в **constant pool** класса в виде символических ссылок.
    - **Символическая ссылка** — это логическая ссылка, которая описывает, например, имя метода, его параметры, класс, к которому он принадлежит, но не содержит физического адреса в памяти.
2. Символическая ссылка не указывает на реальный объект или метод в памяти до тех пор, пока это не потребуется во время исполнения программы.

---

#### 3. **Ключевые этапы связывания в JVM**

##### (а) **Constant Pool**

Каждый класс в Java имеет **runtime constant pool**, который хранит:

- Информацию о символических ссылках на поля, методы и классы.
- Ссылки на строковые литералы и другие константы.

Каждый метод или поле, которое использует класс, сначала обращается к этому constant pool.

##### (б) **Решение символических ссылок (resolution)**

Когда ссылка должна быть использована:

1. JVM проверяет, загружен ли нужный класс.
    - Если класс ещё не загружен, он загружается и проходит этапы верификации и подготовки.
2. Символическая ссылка заменяется на **прямую ссылку** (direct reference).
    - Прямая ссылка указывает на конкретный объект, метод или поле в памяти, с учетом смещения.

##### (в) **Порядок связывания**

Связывание в Java может происходить:

1. **Раннее связывание (early binding)** — выполняется для статических методов, статических полей и методов `final`. Здесь ссылки могут быть разрешены сразу после загрузки класса.
2. **Позднее связывание (late binding)** — выполняется для виртуальных методов, чтобы поддерживать полиморфизм. Для них ссылка разрешается при первом вызове метода.

---

#### 4. **Отличие от C/C++**

В C/C++ связывание происходит на этапе компоновки:

- Компилятор генерирует объектные файлы, содержащие символы для всех функций и переменных.
- Компоновщик (linker) связывает эти символы с конкретными адресами в памяти, создавая единый исполняемый файл.
- Адреса методов и переменных фиксируются до запуска программы.

В Java:

- Все ссылки остаются символическими вплоть до исполнения.
- Это позволяет JVM подгружать классы по мере необходимости, а также заменять ссылки на методы (например, при использовании динамического полиморфизма).

---

#### 5. **Пример динамического связывания**

**Пример кода:**

```java
class Animal {
    void sound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    void sound() {
        System.out.println("Dog barks");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal a = new Dog();
        a.sound(); // Какой метод вызовется?
    }
}

```
- Переменная `a` типа `Animal` ссылается на объект типа `Dog`.
- Метод `sound()` разрешается на этапе выполнения, а JVM вызывает реализацию из класса `Dog`. Это возможно благодаря позднему связыванию.

---

#### 6. **Ошибки связывания**

Если JVM не может разрешить символическую ссылку во время исполнения, это вызывает ошибки связывания:

- **NoClassDefFoundError** — класс, на который ссылается код, не найден.
- **NoSuchMethodError** — метод, на который ссылается код, отсутствует в классе.

---

#### 7. **Преимущества динамического связывания в Java**

- **Гибкость:** Позволяет реализовать полиморфизм, загружать классы во время выполнения, заменять их реализации.
- **Модульность:** Позволяет обновлять отдельные части приложения (например, библиотеки) без перекомпиляции всей программы.
- **Поддержка безопасности:** JVM проверяет доступность методов и полей перед разрешением ссылок, что делает программы более безопасными.

---

Динамическое связывание в Java — это важный механизм, который обеспечивает гибкость и динамическую природу платформы, в отличие от фиксированных адресов в C/C++.

, в Java **статическое связывание (early binding)** тоже имеет место. Это происходит в случаях, когда JVM может заранее определить, какой именно метод или поле будет вызвано, ещё до выполнения программы.

### **Когда в Java происходит статическое связывание?**

#### 1. **Статические методы**

Статические методы привязываются к классу, а не к объекту. Поэтому их вызов можно определить на этапе компиляции.

Пример:
```java
class Parent {
    static void display() {
        System.out.println("Static method in Parent");
    }
}

class Child extends Parent {
    static void display() {
        System.out.println("Static method in Child");
    }
}

public class Main {
    public static void main(String[] args) {
        Parent.display(); // вызовется метод Parent
        Child.display();  // вызовется метод Child
    }
}

```
Статические методы вызываются через имя класса (`Parent.display()`), и их связывание происходит во время компиляции.
#### 2. **Методы или поля с модификатором `final`**

Методы и поля, объявленные с модификатором `final`, не могут быть переопределены в наследуемых классах. JVM может безопасно связать их вызов во время компиляции.


```java
class Parent {
    final void show() {
        System.out.println("Final method in Parent");
    }
}

class Child extends Parent {
    // Ошибка: нельзя переопределить метод show()
    // void show() { 
    //     System.out.println("Attempting override");
    // }
}

public class Main {
    public static void main(String[] args) {
        Parent obj = new Parent();
        obj.show(); // статическое связывание
    }
}

```

#### 3. **Приватные методы**

Приватные методы являются доступными только внутри класса, где они объявлены. Они не могут быть переопределены, и их вызов также определяется во время компиляции

```java
class Parent {
    private void display() {
        System.out.println("Private method in Parent");
    }
}

public class Main {
    public static void main(String[] args) {
        Parent obj = new Parent();
        // Метод display() привязывается к классу Parent на этапе компиляции
    }
}

```
#### 4. **Поля (переменные класса и экземпляра)**

Ссылка на переменные (как статические, так и экземпляра) всегда определяется на этапе компиляции.

```java
class Parent {
    int x = 10;
}

class Child extends Parent {
    int x = 20;
}

public class Main {
    public static void main(String[] args) {
        Parent obj = new Child();
        System.out.println(obj.x); // 10, связывание переменной происходит статически
    }
}

```
- Даже если объект принадлежит классу `Child`, переменная `x` из класса `Parent` будет использоваться, потому что поля не поддерживают полиморфизм.

---

#### **Отличия статического и динамического связывания в Java**

|**Критерий**|**Статическое связывание**|**Динамическое связывание**|
|---|---|---|
|**Время связывания**|Во время компиляции|Во время выполнения|
|**Что связано**|Статические методы, приватные методы, поля|Виртуальные методы (включая переопределённые)|
|**Поддержка полиморфизма**|Нет|Да|
|**Примеры**|`static`, `final`, `private`|Переопределение методов в наследовании|

---

### **Итог**

- **Статическое связывание** в Java происходит в случаях, когда вызываемые методы или поля могут быть однозначно определены на этапе компиляции.
- Примеры: статические методы, приватные методы, `final` методы и поля.
- **Динамическое связывание**, напротив, используется для работы с виртуальными методами, что является основой полиморфизма в Java.

----

## Различия между ранним и поздним связыванием в языке Java

Теперь, когда вы разобрались и понимаете, как в языке Java связываются вызовы методов и как функционирует статическое и динамическое связывание, давайте еще раз перечислим ключевые различия между ранним и поздним связыванием в языке Java:

1. <mark class="hltr-green2">Статическое связывание происходит во время компиляции, а динамическое – во время выполнения.</mark>
  
3. Поскольку статическое связывание происходит на ранней стадии жизненного цикла программы, его называют ранним связыванием. Аналогично, динамическое связывание называют также поздним связыванием, поскольку оно происходит позже, во время работы программы.
  
5. <mark class="hltr-red">Статическое связывание используется в языке Java для разрешения перегруженных методов</mark>, в то время как <mark class="hltr-orange">динамическое связывание используется в языке Java для разрешения переопределенных методов.</mark>
  
7. Аналогично,<mark class="hltr-green2"> приватные, статические и терминальные методы разрешаются при помощи статического связывания</mark>, поскольку их нельзя переопределять, а <mark class="hltr-yellow">все виртуальные методы разрешаются при помощи динамического связывания.</mark>
  
9. В случае статического связывания используются не конкретные объекты, а информация о типе, то есть для обнаружения нужного метода используется тип ссылочной переменной. С другой стороны, при динамическом связывании для нахождения нужного метода в Java используется конкретный объект.

### Логическая точка зрения

  
<mark class="hltr-red">С логической точки зрения, на этапе компиляции вызываемый метод рассматривается как относящийся к типу ссылки. Но во время выполнения будет вызываться метод объекта, на который указывает ссылка.
</mark>

Перегруженные методы (overload) не называются полиморфными и резолвятся во время компиляции. Хотя иногда перегрузку методов называют **полиморфизмом времени компиляции или ранним/статическим связыванием**.  
  
Переопределенные методы (override) резолвятся во время выполнения, так как компилятор не знает, есть ли переопределенные методы в объекте, который присваивается ссылке.


----

Ваш вопрос затрагивает тонкости работы JVM, связанной с **разрешением символьных ссылок** и различием между статическим и динамическим связыванием. Давайте разберемся по порядку.

### 1. **Что такое статическое связывание на этапе компиляции?**

На этапе компиляции (в Java, например, с помощью `javac`) происходит **статическое связывание**:

- Компилятор использует **сигнатуры методов, полей и классов**, чтобы определить, что именно вызывает код.
- Символьные ссылки (например, имя метода, имя класса, имя поля) остаются в байт-коде. Эти ссылки записываются в **постоянную область класса (constant pool)** в виде строковых литералов или других структур данных.

Но при этом компилятор **не привязывает вызовы методов или доступ к полям к конкретным адресам в памяти**. Вся информация о том, какой именно метод будет вызван, разрешается на более поздних этапах.

### 2. **Что происходит при загрузке класса в JVM?**

Когда класс загружается в JVM, происходит следующее:

#### Этапы загрузки:

1. **Загрузка (Loading)**:
    
    - JVM читает файл `.class`, загружает его содержимое в память.
    - Внутри JVM формируется структура класса, и символьные ссылки из пула констант остаются пока что **нераспрешенными**.
2. **Проверка (Verification)**:
    
    - JVM проверяет байт-код на корректность, чтобы избежать ошибок выполнения.
3. **Подготовка (Preparation)**:
    
    - JVM выделяет память для статических полей класса и инициализирует их значениями по умолчанию.
4. **Разрешение (Resolution)**:
    
    - На этом этапе JVM начинает **разрешать символьные ссылки** из пула констант.  
        Это означает, что JVM пытается найти **реальные ссылки на классы, методы и поля**, указанные в байт-коде. Например:
        - Ссылка на имя класса преобразуется в конкретный объект `Class`.
        - Ссылка на метод преобразуется в указатель на его реализацию (в таблице методов класса).
    - **Разрешение символьных ссылок может быть отложенным** (lazily), если JVM решает, что данный элемент не нужен в данный момент.

Таким образом, **на этапе загрузки класса происходит разрешение символьных ссылок, но не динамическое связывание!**

### 3. **Что такое динамическое связывание?**

Динамическое связывание происходит во время выполнения программы, когда JVM:

- Определяет, какой именно метод нужно вызвать, основываясь на **типе объекта в рантайме**.
- Это особенно актуально для вызовов виртуальных методов (методов, не объявленных как `static` или `final`).


```java
class A {
    void display() { System.out.println("A"); }
}

class B extends A {
    @Override
    void display() { System.out.println("B"); }
}

public class Test {
    public static void main(String[] args) {
        A obj = new B(); // Объект типа B
        obj.display();   // JVM определяет реализацию display() во время выполнения
    }
}

```

Здесь на этапе компиляции известно, что будет вызван метод `display()`. Однако только во время выполнения JVM определяет, что нужно вызвать `B.display()`.

### 4. **Почему необходимо разрешение ссылок, если уже было статическое связывание?**

Несмотря на статическое связывание на этапе компиляции, разрешение ссылок в JVM необходимо из-за особенностей Java:

- **Модульность и загрузчики классов:** Классы могут быть загружены разными загрузчиками (ClassLoaders). Реальное местоположение класса в памяти JVM может быть известно только во время выполнения.
- **Полиморфизм и интерфейсы:** Выбор метода часто зависит от типа объекта в рантайме.
- **Динамическое обновление:** Некоторые классы могут быть заменены (например, при использовании Java Agents или в системах с горячей заменой кода).

Таким образом, статическое связывание на этапе компиляции предоставляет общую информацию (сигнатуры, типы), но JVM должна выполнить дополнительные действия для обеспечения корректного выполнения программы.

### Резюме

1. На этапе компиляции происходит **статическое связывание**, которое фиксирует сигнатуры и символьные ссылки.
2. На этапе загрузки класса JVM разрешает символьные ссылки из пула констант, чтобы подготовить класс к выполнению.
3. Во время выполнения происходит **динамическое связывание**, которое учитывает типы объектов в рантайме для выбора методов и полей.

Эти этапы обеспечивают гибкость, безопасность и полиморфизм в Java.


#### **Статическое связывание на этапе компиляции:**

- Компилятор (например, `javac`) определяет:
    - **Какая сигнатура метода или поля используется**.
    - Проверяет, что данный метод/поле существует и доступно.
    - В результате, в байт-коде остаются **символьные ссылки** (например, "метод `doSomething` в классе `A`").

Но компилятор **не создает прямых ссылок на память или конкретные реализации методов**, так как в байт-коде используется символьная информация. Эти ссылки остаются **символическими** до момента выполнения программы.

#### **Статическое связывание на этапе загрузки классов в JVM:**

- На этапе загрузки классов (или при выполнении отложенного разрешения ссылок) происходит **разрешение символьных ссылок**.
- Например:
    - Символическая ссылка на `doSomething` из класса `A` разрешается в конкретный метод, хранящийся в памяти JVM.
    - Для методов, помеченных как `static`, `final` или `private`, разрешение происходит раз и навсегда.

Итак, термин "статическое связывание" может применяться к обоим этапам, но в литературе чаще подчёркивается **компиляторная часть**, поскольку там впервые фиксируется информация о вызовах.

---

### **Почему статическое связывание упоминают на этапе компиляции?**

Это связано с тем, что на этапе компиляции:

1. **Компилятор знает всё, что нужно для определения метода/поля:**
    
    - Компилятор однозначно проверяет:
        - Типы объектов (на уровне объявленных типов, а не реальных).
        - Сигнатуры методов.
        - Статический контекст (например, статические методы и поля).
    - Например, для вызовов `static`, `private` и `final` методов компилятор знает, какой метод будет вызван, **независимо от типа объекта в рантайме**.
2. **Байт-код содержит статическую информацию:**
    
    - После компиляции в байт-коде остаются ссылки, которые будут разрешены при загрузке класса.
    - Хотя адреса или реальные ссылки ещё не известны, связь между вызовом и сигнатурой уже зафиксирована.

**Пример статического связывания:**

```java
class Example {
    static void staticMethod() { System.out.println("Static method"); }
    public static void main(String[] args) {
        Example.staticMethod(); // Статическое связывание
    }
}

```


Компилятор уже "знает", что вызов `Example.staticMethod()` однозначно связан с методом `staticMethod()` класса `Example`.

---

### **Почему статическое связывание на этапе загрузки?**

На этапе загрузки JVM окончательно разрешает символьные ссылки:

- JVM понимает, где в памяти находится метод или поле.
- Для статических методов/полей, а также для вызовов конструктора это разрешение происходит **только один раз**, и ссылка становится неизменной.

---

### **Разница между компиляцией и загрузкой:**

|Этап|Что происходит|
|---|---|
|**Компиляция**|Символьные ссылки фиксируются (сигнатуры методов и полей), проверяется их существование и доступность.|
|**Загрузка классов**|JVM разрешает символьные ссылки, переводя их в конкретные ссылки на методы и поля в памяти.|

---

### **Почему терминология сложная?**

Термин "статическое связывание" больше относится к **статическим аспектам работы программы**, где связь между вызовом и элементом определяется заранее, до выполнения программы.

1. **На этапе компиляции** это статическое в том смысле, что компилятор знает, какой метод/поле вызывается.
2. **На этапе загрузки** это статическое в том смысле, что разрешение выполняется только один раз и не меняется в процессе выполнения программы.

Однако, принято говорить, что **"статическое связывание" происходит на этапе компиляции**, так как с точки зрения разработчика оно уже предопределено компилятором. Этап загрузки в JVM часто воспринимается как техническая деталь.

---

### **Вывод**

- **Термин "статическое связывание" используется для простоты**, чтобы указать, что связь между вызовом и элементом фиксируется заранее (ещё до выполнения программы).
- На самом деле, статическое связывание начинается на этапе компиляции (определение сигнатур) и завершается на этапе загрузки (разрешение символьных ссылок).
- Говорят о "статическом связывании" на этапе компиляции, чтобы подчеркнуть, что этот процесс **не зависит от информации рантайма**, в отличие от динамического связывания.
