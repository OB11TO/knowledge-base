---
title: Heap JVM
tags:
  - JavaSE
related_topics: 
created: 2024-12-13 17:44
modified: 2024-12-25T16:29:29+03:00
questions: 
notes: 
links: 
---


----




---

<mark class="hltr-red">Heap в JVM (Java Virtual Machine)</mark> — это о<mark class="hltr-green2">бласть памяти, выделенная для объектов и JRE (Java Runtime Environment) во время выполнения программы.</mark> Он играет центральную роль в управлении памятью в Java,<mark class="hltr-yellow"> предоставляя инфраструктуру для выделения и управления памятью объектов</mark>. Расскажу обо всех аспектах Heap, включая его устройство, внутреннюю организацию, и полезные детали для работы.

---

### **1. Основы Heap в JVM**

Heap — это память<mark class="hltr-yellow">, используемая для хранения всех объектов, которые создаются с использованием ключевого слова</mark> `new`. <mark class="hltr-purple">Управляется сборщиком мусора (Garbage Collector, GC), чтобы автоматически освобождать память, занятую объектами, которые больше не используются.</mark>

- **Выделение памяти на Heap**:
    
    - При запуске JVM, Heap выделяется из памяти операционной системы. Его размер можно задать через параметры JVM:
        - `-Xms`: минимальный размер Heap.
        - `-Xmx`: максимальный размер Heap.
    - Например: `java -Xms512m -Xmx1024m MyApp`.
- **Области Heap**: Heap делится на несколько регионов:
    
    - **Young Generation (Молодое поколение)**:
        - Содержит объекты, которые только что созданы.
        - Подразделяется на:
            - Eden Space (Сад Эдема) — для новых объектов.
            - Survivor Spaces (S0, S1) — для объектов, переживших один или несколько циклов GC.
    - **Old Generation (Старшее поколение)**:
        - Хранит долгоживущие объекты (пережившие несколько циклов GC).
    - **Metaspace** (с Java 8):
        - Хранит метаданные классов (раньше использовалась область PermGen).
    - **Large Objects (если есть)**:
        - <mark class="hltr-blue">Большие объекты, которые сразу помещаются в Old Generation, чтобы избежать перемещения в Young Generation.</mark>

---

### **2. Организация памяти и сборка мусора**

JVM использует несколько алгоритмов для управления памятью Heap и очистки ненужных объектов:

#### **Алгоритмы сборки мусора**

1. **Mark-and-Sweep**:
    
    - "Отметь и очисти" — объекты помечаются как доступные или недоступные, затем недоступные удаляются.
    - Используется в Old Generation.
2. **Copying (Копирование)**:
    
    - Применяется в Young Generation.
    - Живые объекты копируются из Eden Space в Survivor Space, освобождая память.
3. **Compacting (Компактирование)**:
    
    - Устраняет фрагментацию памяти, перемещая объекты в компактный блок.
4. **Generational Garbage Collection**:
    
    - Делит память на поколения (Young, Old) и использует разные подходы к сборке мусора для каждого поколения.
    - Молодое поколение очищается чаще и быстрее (Minor GC), старшее — реже, но медленнее (Major GC).
5. **Concurrent Garbage Collectors**:
    
    - **G1 (Garbage First):**
        - Делит Heap на регионы и очищает наиболее заполненные регионы сначала.
    - **ZGC (Z Garbage Collector):**
        - Фокусируется на низкой паузе. Эффективен для больших Heap (до терабайтов).
    - **Shenandoah GC:**
        - Уменьшает паузы GC, работая параллельно с приложением.

---

### **3. Важные детали внутреннего устройства Heap**

#### **HotSpot JVM и его оптимизации**

1. **Card Table и Write Barrier**:
    
    - Для отслеживания изменений объектов в Old Generation используется `Card Table`.
    - Write Barrier позволяет эффективно находить модифицированные объекты при сборке мусора.
2. **TLAB (Thread Local Allocation Buffer)**:
    
    - Каждый поток имеет локальный буфер для быстрого выделения памяти. Уменьшает конкуренцию между потоками.
3. **Escape Analysis**:
    
    - Анализирует объекты, чтобы определить, могут ли они быть локализованы в стеке (Stack Allocation) вместо Heap.
4. **Compressed Oops**:
    
    - Для экономии памяти ссылки на объекты (object pointers, oops) сжимаются до 32 бит, если Heap меньше 32 ГБ.

---

### **4. Полезные параметры JVM для Heap**

- **Анализ производительности и сборки мусора**:
    
    - `-XX:+PrintGCDetails`: детальная информация о сборке мусора.
    - `-XX:+PrintGC`: простая информация о GC.
    - `-XX:+PrintGCTimeStamps`: временные метки для событий GC.
    - `-XX:+HeapDumpOnOutOfMemoryError`: создать дамп Heap при переполнении памяти.
- **Управление поколениями**:
    
    - `-XX:NewRatio=2`: соотношение между Old и Young Generation.
    - `-XX:SurvivorRatio=8`: соотношение между Eden и Survivor Spaces.
- **GC Тюнинг**:
    
    - `-XX:+UseG1GC`: включить G1 GC.
    - `-XX:+UseZGC`: включить ZGC.

---

### **5. Практические советы**

1. **Диагностика утечек памяти**:
    
    - Используйте инструменты: VisualVM, JConsole, Eclipse MAT для анализа Heap Dump.
    - Настройка параметра `-XX:+HeapDumpOnOutOfMemoryError` помогает найти причины утечек.
2. **Оптимизация производительности**:
    
    - Анализируйте частоту и длительность GC, оптимизируйте размер Young Generation.
    - Избегайте объектов, живущих дольше, чем требуется.
3. **Тестирование и профилирование**:
    
    - Тестируйте приложение с различными нагрузками.
    - Профилируйте память, чтобы найти горячие точки выделения объектов.

---

### **6. Знание под капотом: интересные детали**

1. **Разбиение Heap на регионы (G1 и ZGC)**:
    
    - В G1 Heap делится на фиксированные регионы. Это улучшает производительность за счет локальной компактизации.
    - В ZGC регионы могут быть размечены как "неактивные", позволяя работать с очень большими объемами памяти.
2. **Pinned Objects**:
    
    - Объекты, которые нельзя перемещать, такие как массивы, используемые в JNI.
3. **Object Header**:
    
    - Каждый объект в Heap имеет заголовок (Header), содержащий метаданные: hash-код, ссылки на класс, состояние синхронизации.
4. **GC Root и их роль**:
    
    - `GC Roots` — это точки входа для определения достижимости объектов. Примеры:
        - Локальные переменные в стеке.
        - Статические переменные классов.
        - Потоки.



----

Параметры `-XX:NewRatio` и `-XX:SurvivorRatio` используются для настройки размера различных областей памяти в **Heap** JVM. Они определяют, как Heap делится между **Old Generation**, **Young Generation** и подчастями **Young Generation** (Eden и Survivor Spaces). Рассмотрим подробно.

---

### **1. `-XX:NewRatio=2`**

Этот параметр определяет соотношение размера **Old Generation** (старшего поколения) и **Young Generation** (молодого поколения).

#### **Как работает?**

- Формула:
    
    yaml
    
    Копировать код
    
    `Размер Old Generation : Размер Young Generation = NewRatio : 1`
    
- Пример с `-XX:NewRatio=2`:
    - Это означает, что **Old Generation** будет в 2 раза больше, чем **Young Generation**.
    - Если весь Heap равен 300 МБ, JVM делит его так:
        - **Old Generation**: 23×300 МБ=200 МБ\frac{2}{3} \times 300 \, \text{МБ} = 200 \, \text{МБ}32​×300МБ=200МБ.
        - **Young Generation**: 13×300 МБ=100 МБ\frac{1}{3} \times 300 \, \text{МБ} = 100 \, \text{МБ}31​×300МБ=100МБ.

#### **Когда использовать?**

- Увеличить `NewRatio`, если ваше приложение создаёт много долгоживущих объектов.
- Уменьшить `NewRatio`, если приложение активно использует краткоживущие объекты, чтобы больше памяти отводилось для Young Generation.

---

### **2. `-XX:SurvivorRatio=8`**

Этот параметр определяет соотношение между размером **Eden Space** и суммарным размером **Survivor Spaces** (S0 и S1) в **Young Generation**.

#### **Как работает?**

- Формула:
    
    mathematica
    
    Копировать код
    
    `Размер Eden Space : Размер одной Survivor Space = SurvivorRatio : 2`
    
- Пример с `-XX:SurvivorRatio=8`:
    - Eden Space будет в **8 раз больше**, чем каждая из Survivor Spaces.
    - Если Young Generation равен 100 МБ:
        - Eden Space: 810×100 МБ=80 МБ\frac{8}{10} \times 100 \, \text{МБ} = 80 \, \text{МБ}108​×100МБ=80МБ.
        - Каждая Survivor Space: 110×100 МБ=10 МБ\frac{1}{10} \times 100 \, \text{МБ} = 10 \, \text{МБ}101​×100МБ=10МБ.

#### **Когда использовать?**

- Увеличить `SurvivorRatio`, если большинство объектов быстро становится мусором (чтобы Eden Space был больше).
- Уменьшить `SurvivorRatio`, если много объектов перемещаются между Eden и Survivor Spaces (чтобы Survivor Spaces были больше).

---

### **3. Связь между параметрами**

Оба параметра взаимосвязаны, так как управление Old и Young Generation и их внутренней структурой напрямую влияет на производительность приложения.

- **Пример:**
    - Если у вас приложение с множеством короткоживущих объектов:
        - Настройка: `-XX:NewRatio=1` (Old и Young одинаковые по размеру) и `-XX:SurvivorRatio=8` (большой Eden).
    - Если у вас много долгоживущих объектов:
        - Настройка: `-XX:NewRatio=4` (Old больше) и `-XX:SurvivorRatio=4` (увеличенные Survivor Spaces).

---

### **Практические советы**

1. Используйте профилировщики (например, VisualVM или Java Mission Control), чтобы понять характер вашего приложения:
    - Если Minor GC (в Young Generation) слишком часты, увеличьте размер Young Generation (`-XX:NewRatio` или `-Xmn`).
    - Если слишком много объектов перемещается в Old Generation, настройте Survivor Spaces (`-XX:SurvivorRatio`).
2. Тестируйте изменения параметров на боевом приложении с реальной нагрузкой.

---

Таким образом, `-XX:NewRatio` и `-XX:SurvivorRatio` предоставляют гибкость в настройке памяти Heap, помогая достичь оптимальной производительности JVM для конкретного приложения