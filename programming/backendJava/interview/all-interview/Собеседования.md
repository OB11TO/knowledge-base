---
modified: 2024-09-02T15:31:48+03:00
---
### Прохождение

https://docs.google.com/document/d/199tlgjxPB0wOb8IckJYtyVphDh5HcQheaDPhFbpX1jY/edit

### Как получить пользователей, у которых нет заказов, если заказы вынесены в другую таблицу и в заказх есть колонка user_id, не используя JOIN.

Для вывода пользователей, у которых нет заказов, вы можете воспользоваться оператором `NOT IN` или `NOT EXISTS`, не применяя явное объединение (JOIN). Вот два способа с использованием этих операторов:

```SQL
SELECT id, name
FROM person
WHERE id NOT IN (SELECT DISTINCT user_id FROM заказы);

В этом запросе внутренний подзапрос выбирает уникальные user_id из таблицы заказы, а внешний запрос выбирает пользователей из таблицы person, у которых id не находится в результатах подзапроса.
```

  

```SQL
SELECT id, name
FROM person p
WHERE NOT EXISTS (SELECT 1 FROM заказы z WHERE p.id = z.user_id);
В этом запросе внутренний подзапрос проверяет, существуют ли записи в таблице заказы, где user_id совпадает с id пользователя из таблицы person. Внешний запрос выбирает пользователей, у которых не существует соответствующих записей в таблице заказы.
```

1. Что выведет следующее?

```Java
StringBuilder builder = new StringBuilder("String");
String line = new String("String");
System.out.println(line.equals(builder)); //true или false?
```

Выведет false, так как это разные объекты, нужно привести билдер к String через toString();

### Где можно использовать аннотацию @Autowired?

- В полях класса:
    
    ```Java
    @Autowired
    private SomeService someService;
    ```
    
- В методах класса (как сеттеры):
    
    ```Java
    private SomeService someService;
    
    @Autowired
    public void setSomeService(SomeService someService) {
        this.someService = someService;
    }
    ```
    
- В конструкторах класса:
    
    ```Java
    private final SomeService someService;
    
    @Autowired
    public MyClass(SomeService someService) {
        this.someService = someService;
    }
    ```
    
- В параметрах методов:
    
    ```Java
    @Autowired
    public void doSomethingWithService(SomeService someService) {
        // ...
    }
    ```
    
- В параметрах конструкторов:
    
    ```Java
    @Autowired
    public MyClass(@Qualifier("specificService") SomeService someService) {
        this.someService = someService;
    }
    ```
    
- В аргументах методов для обработки событий (`@EventListener`):
    
    ```Java
    @EventListener
    public void handleEvent(SomeEvent event, @Autowired SomeService someService) {
        // ...
    }
    ```
    

### Что из себя представляетHashMap?

В основе HashMap лежит массив. Элементами данного массива (бакеты) являются LinkedLists. Эти LinkedLists заполняются данными, которые мы кладем в HashMap.

![[images/Untitled 157.png|Untitled 157.png]]

  

Вот как `HashMap` работает под капотом:

Если key = 0, то сразу помещается в нулевой index. В нулевой index помещается элемент содержащий ключ значение. Пара становится элементов LinkedLista на первой его позиции.

Если key не равен 0, вычисляется hashcode. На основании этого hascode (обычным делением) вычисляется остаток, это и будет индексом.

В index 3 (например) помещается LinkedList содержащий hashcode, key, value и ссылку на следующий LinkedList(нода), для первого помещаемого значения ссылка будет null.

Если добавить следующий элемент, снова вычисляется hashcode и индекс, в который нужно поместить LinkedList. Если индекс уже хранит значение, то сравниваентся hashcode, если он равен вызывается equals, если и equals вернул true, то ключи одинаковые и элемент будет перезаписан.

Если hashcode разные или equals вернул false, то добавляется новый эелемент в LinkelList, а предыдущий эелемент начинает хранить ноду( ссылку) на этот вновь добавленный элемент.

Если в index уже содержится значение, то сравнивается hachode, если они не равны, то помещается на последнюю позицию вызывается метод equals

1. **Управление коллизиями:** Если в бакете обнаруживается коллизия (когда несколько ключей имеют одинаковый хэш-код), `HashMap` использует методы разрешения коллизий для размещения элементов. В более ранних версиях Java (до Java 8), использовался метод цепочек, где каждая ячейка содержала связанный список элементов. В Java 8 и последующих версиях была внедрена оптимизация, которая позволяет использовать деревья (красно-черные деревья) для бакетов с большим количеством элементов, что улучшает производительность в случае большого числа коллизий.
2. **Динамическое изменение размера:** `HashMap` автоматически увеличивает размер своей внутренней таблицы, когда количество элементов превышает определенный порог (называемый "порогом загрузки"). Это позволяет поддерживать эффективное распределение данных и уменьшить вероятность коллизий. При увеличении размера таблицы все элементы перехэшируются и перемещаются в новые бакеты.

### Какой изначальный размер HashMap и как она расширяется?

Изначальный размер 16 бакетов, но можно передать в параметре конструктора капасити, также есть LOAD_FACTOR, который изначально равен 0.75f. Это эффективное значение между коллизиями и слишком частым расширением мапы. То есть при изначальном капасити при добавлении 12 LinkedLista в бакет. Значения будут перехешированы и мапа увкеличится в 2 раза.

### Что из себя представляетSet?

Set в своей основе содержит Map, только в качестве значения value находится заглушка/ константа

### Почему HashSet, в который добавили 3 1 2. Выведет 1,2,3?HashSet Ведь set не гарантирует определенного порядка элементов, и в большинстве случаев они могут быть отображены в случайном порядке при выводе.

  
Ответ: Выведет 1, 2, 3, потому что hashcode будет соответствовать примитивным типам в данным случае.  
  
Если вам действительно важен порядок элементов, вам следует использовать  
`LinkedHashSet`, который сохраняет порядок добавления элементов, или явно сортировать элементы перед выводом, как было показано в предыдущем ответе.

### Дерево Exceptions

Класс Throwable, от которого наследуются два класса Exception и Errors. Класс Errors необходим для описания критических ошибок, проблем JVM. Такие ошибки разработчик не обрабатывают, приложение падает.

От Exceptions наследуется RuntimeException. RuntimeException - unchecked исключения, обработка ошибки возлагается на разработчика, компилятор не будет ругаться. Exception - checked компилятор будет ругаться.

### Как устроена память в Java

В целом память можно разделить на три участка. Стэк, хип и спэйс.

В стеке хранятся примитивные типы, ссылки на объекты и методы, в хипе хранятся сами объекты. В спэйсе классы, служебная информация.

### На какие части делится хип для эффективной работы garbage collector?

![[images/Untitled 1 18.png|Untitled 1 18.png]]

На верхнем уровне хип делится на young generation и old generation. Делится по принципу выживаемости объекта. Чем больше живет объект, тем дальше он сдвигается к той области, где объекты живут дольше.

Молодое поколение (Young Generation) в хипе Java делится на две части: поколение Eden и два поколения выживания (Survivor Generations). Давайте более подробно разберем каждое из этих поколений:

1. **Поколение Eden (Eden Generation)**: Это место, где создаются все новые объекты. Когда вы создаете объект с помощью оператора `new`, он размещается в области Eden. Объекты, которые выживают несколько циклов сборки мусора в молодом поколении, переносятся в одно из поколений выживания.
2. **Поколение выживания 1 (Survivor Generation 1)**: После каждого цикла сборки мусора объекты, которые остаются в Eden, а также некоторые объекты из предыдущего поколения выживания, перемещаются в первое поколение выживания. Это место служит промежуточным хранилищем для объектов, которые еще не готовы к перемещению в постоянное поколение (Old Generation).
3. **Поколение выживания 2 (Survivor Generation 2)**: Это также промежуточное хранилище, но оно используется для объектов, которые пережили более одного цикла сборки мусора в первом поколении выживания. Опять же, после нескольких циклов сборки мусора, некоторые из этих объектов могут быть перемещены в постоянное поколение (Old Generation).
4. **Постоянное поколение (Old Generation)**: Это место, где хранятся объекты, которые существуют достаточно долго и пережили несколько циклов сборки мусора в молодом поколении и поколении выживания. Это самое старшее поколение в хипе Java. Как правило, объекты в постоянном поколении более стабильны и долгоживущи.

Цель разделения хипа на поколения заключается в оптимизации сборки мусора. Поскольку большинство объектов быстро становятся недостижимыми и могут быть освобождены в молодом поколении, это позволяет уменьшить нагрузку на сборку мусора и улучшить производительность программы. Только самые долгоживущие объекты переносятся в постоянное поколение, что делает сборку мусора в этом поколении менее частой и более эффективной.

### Какие объекты самые долгоживущие для GarbageCollector?

Singletons

### В чем разница static и не статичных методов? Что быстрее?

Static вызывается на классе. Не статика на экземпляре этого класса. Static быстрее, так как как минимум нужно найти ссылку на экземпляр класса в памяти.

### Правила переопределения equals

Объект сравниваемый не должен быть равен null.

Если сравниваемый объект тот же самый по ссылке, то равен.

Объект должен быть того же класса, что и тот, с которым сравнивается.  
Дальше идет кастинг к классу и логика.  

### Singleton

Создание синглтона (singleton) в Java с использованием перечисления (enum) является одним из наиболее безопасных и простых способов. Вот пример того, как это можно сделать:

```Java
public enum Singleton {
    INSTANCE; // Это единственный экземпляр перечисления

    // Добавьте здесь любые поля и методы, которые должны принадлежать синглтону

    public void doSomething() {
        // Ваш код здесь
    }
}

```

Теперь ваш синглтон `Singleton` создан и гарантировано обеспечивает единственный экземпляр этого класса. Вы можете обратиться к нему следующим образом:

```Java
Singleton singleton = Singleton.INSTANCE;

```

Преимущества использования синглтона через перечисление:

1. **Гарантированное единство**: Java обеспечивает, что каждое значение перечисления создается только один раз, что делает этот подход к синглтону потокобезопасным и более надежным.
2. **Прозрачность сериализации**: Когда вы сериализуете и десериализуете синглтон через перечисление, Java обеспечивает сохранение его единственного экземпляра.
3. **Легкость в использовании**: Синглтон, реализованный через перечисление, имеет простой синтаксис доступа и не требует дополнительной работы по управлению потоками или ленивой инициализации.
4. **Защита от рефлексии**: Синглтон на основе перечисления надежно защищен от создания дополнительных экземпляров с использованием рефлексии.

### Какие правила при работе с транзакциями? ACID

- A -Атомарность.  
    Если есть несколько операциий. Внутри каждой операции мы работаем с БД. Внутри одной из них произошла ошибка. А все операции объединены в транзацкию. Откатятся все, а не только та, в которой произошла ошибка  
    
- C Согласованность.  
    Самый банальный пример с переводом денег. С одного счета снимаем на другой пополняем. Если сняли, должны пополнить. Если не получилось пополнить, должны откатить первую операцию  
    
- I Изолированность. Уровни изоляций позволяют видеть изменения других операций или не видеть.

1. Read Uncommitted. Не защищает от грязного чтения. Одна транзакция пишет данные, другая читает, та что читает может получить необновленные данные
2. Read Committed Защищает от грязного чтения. Дожидается пока одна транзакция пишет, другая считает обновленные данные.
3. Repetable read позволяет избежать проблемы non repetable read. Эта проблема возникает, когда одна транзакция читает данные из базы данных, а затем другая транзакция изменяет или удаляет эти данные и подтверждает свои изменения. Если первая транзакция попытается прочитать эти данные еще раз, она получит другой результат.  
    Частный случай last commit wins:  
    Подход "last commit wins" предполагает, что если одна транзакция изменяет данные, которые были прочитаны другой транзакцией, то последние изменения должны быть сохранены в базе данных, а изменения, сделанные первой транзакцией, будут потеряны.  
    
4. Serializable позволяет избежать фантомного чтения. Эта проблема возникает, когда одна транзакция выполняет запрос на чтение и получает набор результатов, а затем другая транзакция вставляет, обновляет или удаляет данные, которые соответствуют этому запросу, и подтверждает свои изменения. Если первая транзакция выполняет этот же запрос еще раз, она получит другой набор результатов.

- D Надежность или долговечность. Если транзакция закомичена, данные отправлены БД. Внешние проблемы, такие как отключение электричества не должны позволить потерять наши закомиченные данные.

Уровни изоляции

  

### Чем @Controller отличается от @RestController

@RestController содержит аннотацию @ResponseBody, которая позволяет возвращать тело результата из контроллера, @Controller обращается к ресурсу, а @RestController позволяет запросить данные.

  

### Какие бывают скоупы бинов. Чем отличается синглтон от прототайп

Синглтон, прототайп, реквест, сессион.

Синглтон находится в IOC контейнер, прототайп конфигурируется спрингом, инжектится куда надо, в IOC контейнер не кладется прототайп.

  

### IOC и DI

IOC - это передача конфигурации спрингу.

DI - процесс, который позволяет управлять зависимостями, который позволяет встраивать зависимости из ioc контейнер.

### Для чего нужен @Transactional

Аннотация нужна чтобы обеспечивать принцип атомарности. @

### Из чего состоит HTTP пакет

Состоит из заголовка

### Статусы сущности в Hibernate

**transient** — экземпляр сущности был создан, но не  
связан с persistence context. Он не сохранён в базе данных и обычно не  
имеет идентификатора.  

**managed** или **persistent** — сущность  
связана с persistence context и имеет связанный с ней идентификатор. Она  
может как существовать в базе данных, так и пока отсутствовать в ней.  

**detached** — с сущностью связан идентификатор, но она  
больше не связана с persistence context (обычно из-за того, что  
persistence context был закрыт, либо экземпляр был удалён из него)  

**removed** — сущность имеет идентификатор и связана с persistence context, но она запланирована к удалению из базы данных.

  

### Selenium/Jmeter

### View/Materialized View

  

### Explain, Analyze, JProfile

### идемпотетность api

### Liquidbase

### Абстрактные вопросы

### Красно-черное дерево

Красно-чёрное дерево (Red-Black Tree) — это один из видов самобалансирующихся бинарных деревьев поиска. Это означает, что в процессе добавления или удаления узлов в дереве оно автоматически перебалансируется, чтобы сохранить определенные свойства, которые гарантируют эффективность операций поиска, вставки и удаления.

Основные свойства красно-чёрного дерева:

1. **Каждый узел дерева окрашен либо в красный, либо в черный цвет**.
2. **Корень дерева всегда черный**.
3. **Все листья (NIL-узлы) дерева также окрашены в черный цвет**.
4. **Если узел красный, то его дети должны быть черными (то есть красный узел не может иметь красных детей)**.
5. **Для каждого узла все простые пути от узла до листьев содержат одинаковое количество черных узлов**. Это свойство гарантирует, что самое длинное возможное простое путь не более чем вдвое длиннее самого короткого.

Эти свойства гарантируют, что красно-чёрное дерево имеет ограниченную высоту, что в свою очередь обеспечивает эффективные операции поиска, вставки и удаления.

Операции вставки и удаления в красно-чёрном дереве включают в себя различные случаи, которые могут нарушить свойства дерева, и соответствующие операции перебалансировки, чтобы восстановить эти свойства. Вставка и удаление в красно-чёрном дереве могут быть сложными, но за счёт соблюдения вышеперечисленных свойств эффективность операций поддерживается.

### CMS or G1

CMS (Concurrent Mark-Sweep) и G1 (Garbage First) - это два различных алгоритма сборки мусора, используемых в виртуальной машине Java (JVM) для управления памятью и сборки неиспользуемых объектов.

Вот основные отличия между ними:

1. **Алгоритм сборки мусора**:
    - **CMS (Concurrent Mark-Sweep)**: CMS использует алгоритм "mark-sweep" для сборки мусора. Он разделяется на два этапа: "mark" (пометка) и "sweep" (очистка). На этапе пометки он помечает все доступные объекты в памяти как живые, затем на этапе очистки он удаляет недоступные объекты.
    - **G1 (Garbage First)**: G1 также использует сборку мусора по алгоритму "mark-sweep", но его подход более эвристический и предназначен для работы с большими кучами памяти. G1 разбивает кучу на регионы, что позволяет ему эффективно собирать мусор в небольших частях, а также выбирать области с наибольшим количеством мусора для сборки в первую очередь.
2. **Параллельность**:
    - **CMS**: CMS является конкурентным сборщиком мусора, что означает, что он пытается минимизировать простои приложения, позволяя сборке мусора происходить параллельно с выполнением приложения.
    - **G1**: G1 также является конкурентным сборщиком мусора, но он основан на параллелизме и делает упор на уменьшение времени простоя приложения.
3. **Управление памятью**:
    - **CMS**: CMS не управляет памятью так эффективно, как G1, особенно при больших объемах кучи, и может столкнуться с проблемами фрагментации памяти.
    - **G1**: G1 обычно более эффективно управляет памятью и обладает более предсказуемым поведением в сравнении с CMS, особенно при работе с кучами большого размера.

В целом, оба алгоритма обеспечивают эффективное управление памятью и сборку мусора в виртуальной машине Java, но G1 обычно предпочтительнее для больших и сложных приложений из-за его более современного подхода к управлению памятью и параллелизма.