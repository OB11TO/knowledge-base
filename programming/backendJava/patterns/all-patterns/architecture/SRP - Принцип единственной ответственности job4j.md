---
title: Принцип единственной ответственности job4j
tags:
  - Pattern
  - Architecture
related_topics: 
created: 2025-02-17 12:31
modified: 2025-02-17T14:18:11+03:00
questions: 
notes: 
links: 
---


 Данный принцип гласит: <mark class="hltr-red">программная сущность (класс, пакет, модуль) должна иметь только одну ответственность.</mark>


Прежде чем начать детальное объяснение, <mark class="hltr-purple">нужно отметить две вещи</mark>:

1. _Принципы между собой связаны_, <mark class="hltr-green2">поэтому понимание отдельно взятого принципа зависит от комплексного понимания всех принципов</mark>
2. Принципы SOLID <mark class="hltr-cyan">базируются на основных принципах ООП</mark>. Возможно, вы встречали, что в некоторых источниках выделяют такой принцип как _абстракция_. Без выделения абстракций невозможно воспринимать принципы SOLID. Программными абстракциями являются интерфейсы и абстрактные классы. Если косвенно это соотнести с принципом SRP, то интерфейсы и абстрактные классы должны отвечать за абстракцию, а реализации должны уже отвечать за представление этих абстракций. Также это основа для соблюдения принципа OCP, о котором мы поговорим потом.

-----


**Плохой пример:

```java
package ru.job4j.ood.srp;

import java.util.List;

public interface SequenceGenerator<T> {
    List<T> generate(int size);
    void print(List<T> numbers);
}
```

```java
package ru.job4j.ood.srp;

import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.Random;

public class SimpleSequenceGenerator implements SequenceGenerator<Integer> {
    @Override
    public List<Integer> generate(int size) {
        Random random = new Random();
        return IntStream.range(0, size)
                .map(i -> random.nextInt()).boxed()
                .collect(Collectors.toList());
    }

    @Override
    public void print(List<Integer> numbers) {
        numbers.forEach(System.out::println);
    }
}
```

**Найти нарушения принципа SRP

1. Первое, что приходит на ум, это то, что реализации SequenceGenerator <mark class="hltr-yellow">имеют различный функционал</mark>. Они умеют и генерировать последовательность, и выводить куда-либо. А если нужно просто вывести? А если нужно просто сгенерировать? Клиенту придется реализовывать этот функционал. Это результат некорректного выделения абстракции, каждая абстракция должна отвечать только за представления своего функционала, что тоже можно косвенно отнести к принципу SRP. В этом проявляется связь с принципом ISP. <mark class="hltr-green2">Разделим интерфейсы</mark>



----

1. Обращать внимание на функционал, предоставляемый классом.<mark class="hltr-green2"> У класса должна быть только одна цель.</mark>

2. Обращать внимание на создаваемые объекты. <mark class="hltr-red">Если класс умеет их создавать и инициализировать, то это скорее всего нарушает принцип SRP</mark>

3. Обращать<mark class="hltr-purple"> внимание на используемые операции, которые используются без зависимости.</mark> Как в случае с генератором. Это могут быть неявные преобразования. Здесь антипаттерном служат статические библиотеки, не предоставляющие стандарт языка. Например, вы выводите дату в определенном формате, преобразование в формат есть преобразование, которое может поменяться. В качестве примера можно также привести проверку условий, диктуемых извне. Например, поиск по файловой системе должен быть по предикату.


----

![[Pasted image 20250217135910.png]]
- Прикольный пример про Температуру =)

-----

## Определение 1. Единая ответственность.

Человек-программист пишет код для человека-обезьяны, а человек-обезьяна невнимателен, глуп и вечно куда-то спешит. Он может удержать и понять около 3 — 7 термов в один момент времени.  
В случае выпивохи этих термов три. Однако если мы напишем код одной простыней, то в нем появятся руки, стаканы, мордобои и бесконечные споры о политике. И все это будет в теле одного метода. Уверен — вы видели такой код в своей практике. Не самое гуманное испытание для психики.

Так вот, **SRP — это принцип, объясняющий КАК декомпозировать, то есть где провести линию разделения**. <mark class="hltr-red">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</mark>

-----
## Определение 2. Единая изменчивость.
![[Pasted image 20250217141121.png]]
В подходе "Вперед и только вперед", все что можно поменять — меняется только в методе **Act**. Это может быть читабельно и эффективно в случае, когда логики немного и она редко меняется, но зачастую это кончается ужасными методами по 500 строк в каждом.

-----
## Определение 3. Локализация изменений.

"**Схожие для изменения вещи должны храниться в одном месте**". или “**То, что изменяется вместе, должно храниться в одном месте**”
Это очень важный момент — так как все объяснения SRP, которые были выше, говорили о том, что надо дробить типы, пока они дробятся, то есть накладывало "ограничение сверху" на размер объекта, а теперь мы говорим уже и об "ограничении снизу". Иными словами, **SRP не только требует "дробить пока дробится", но и не перестараться — "не раздробить сцепленные вещи"**. Не усложнять без надобности. Это великая битва бритвы Оккама с человеком-обезьяной!

-----


