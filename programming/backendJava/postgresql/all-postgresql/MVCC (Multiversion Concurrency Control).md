---
title: MVCC (Multiversion Concurrency Control)
tags:
  - PostgreSql
related_topics: 
created: 2024-09-26 17:40
modified: 2024-10-02T16:08:54+03:00
questions: 
notes: 
links: 
---

----
[[Помощь в MVCC]]
[[Откат транзакции и запись на диск]]


---

### MVCC (Multiversion Concurrency Control) в PostgreSQL: Обзор

**MVCC (Multiversion Concurrency Control)** — это <mark class="hltr-yellow">механизм управления конкурентным доступом к данным в базе данных PostgreSQL</mark>. Он п<mark class="hltr-green2">озволяет нескольким транзакциям одновременно читать и изменять данные без блокировок и при этом гарантировать изоляцию и согласованность данны</mark>х. PostgreSQL использует этот механизм для обеспечения высокой производительности при конкурентном доступе к данным и минимизации блокировок транзакций.

#### Основные концепции MVCC:

1. **Многоверсионность**: <mark class="hltr-yellow">PostgreSQL сохраняет несколько версий одной и той же строки (tuple) данных</mark>.<mark class="hltr-purple"> Каждая транзакция видит версию данных, актуальную на момент начала этой транзакции, что обеспечивает **изоляцию** транзакций друг от друга.</mark>
    
2. **Снимки (Snapshots)**: <mark class="hltr-red">Каждая транзакция получает свой собственный "снимок" базы данных на момент ее начала</mark>. Это <mark class="hltr-yellow">гарантирует, что она будет видеть только те изменения, которые были зафиксированы другими транзакциями до начала этой транзакции, и не видит изменений, сделанных параллельными незавершенными транзакциями.</mark>
    
3. **Отсутствие блокировок при чтении**: Благодаря MVCC, т<mark class="hltr-yellow">ранзакции, которые выполняют только операции чтения</mark> (например, `SELECT`), <mark class="hltr-yellow">могут выполняться одновременно с изменяющими транзакциями</mark> (`INSERT`, `UPDATE`, `DELETE`), <mark class="hltr-red">не блокируя друг друга.</mark>
    

#### Зачем нужен MVCC?

Основная цель MVCC — это улучшение производительности и обеспечение высокой параллельности доступа к данным, сохраняя при этом требования транзакционной целостности (ACID).

<mark class="hltr-orange">MVCC помогает решать несколько проблем:</mark>

- **Избежание блокировок при чтении**: <mark class="hltr-green2">Традиционные механизмы блокировок (lock) могут привести к блокировкам при чтении и изменении данны</mark>х. <mark class="hltr-yellow">MVCC позволяет транзакциям читать данные без ожидания завершения других транзакций, что значительно повышает параллелизм.</mark>
- **Изоляция транзакций**: PostgreSQL<mark class="hltr-purple"> через MVCC обеспечивает уровень изоляции "чтение-фиксация" (snapshot isolation),</mark> при котором <mark class="hltr-green2">транзакция видит фиксированное состояние базы данных на момент её старта.</mark>
- **Поддержка разных уровней изоляции**: <mark class="hltr-pink">MVCC поддерживает разные уровни изоляции транзакций,</mark> такие как `READ COMMITTED` и `REPEATABLE READ`, <mark class="hltr-green">предоставляя гибкость </mark>в настройке изоляции данных для различных бизнес-сценариев.

### Как работает MVCC в PostgreSQL?

Для понимания работы MVCC в PostgreSQL важно знать о том, как база данных хранит версии строк и как происходит их "видимость" для разных транзакций.
#### 1. **Версии строк (tuples)**:

<mark class="hltr-yellow">Когда данные изменяются, PostgreSQL не перезаписывает строки сразу, а сохраняет новую версию строки</mark>.<mark class="hltr-purple"> Каждая строка (tuple) содержит две скрытые метаинформации:</mark>

- **`xmin`** — идентификатор транзакции, которая создала эту версию строки.
- **`xmax`** — идентификатор транзакции, которая удалила или изменила эту строку. Если строка ещё жива, то `xmax` пусто.

#### Пример:

<mark class="hltr-green">Предположим, у нас есть таблица с одной строкой, и транзакция T1 обновляет эту строку:</mark>

- **Исходная версия строки**: `{data: "old_value", xmin: T0, xmax: null}` — старая версия строки (до изменений).
- **Новая версия строки**: `{data: "new_value", xmin: T1, xmax: null}` — новая версия строки, созданная транзакцией T1.

<mark class="hltr-cyan">Когда транзакция T2 начнет работу:</mark>

- Она увидит старую версию строки, если она началась `до фиксации транзакции T1.`
- `После фиксации T1, она увидит новую версию строки.`

В PostgreSQL не поддерживается уровень изоляции **READ UNCOMMITTED**, который позволяет видеть изменения, внесенные незавершенными транзакциями. Минимальный поддерживаемый уровень изоляции в PostgreSQL — это **READ COMMITTED**. Давайте рассмотрим разницу между уровнями изоляции и ситуацию, о которой вы спрашиваете
#### 2. **Снимки (snapshots)**:

<mark class="hltr-yellow">Когда транзакция начинается, PostgreSQL захватывает текущий снимок данных.</mark> Этот<mark class="hltr-green2"> снимок включает информацию о том, какие транзакции были завершены (committed), какие транзакции еще выполняются, и какую версию каждой строки может видеть эта транзакция.
</mark>
Снимок данных позволяет транзакции:

- <mark class="hltr-pink">Видеть только те строки, которые были **созданы** до начала транзакции и не были удалены до её начала.</mark>
- <mark class="hltr-yellow">Игнорировать строки, которые были изменены или удалены транзакциями, начатыми после текущей транзакции.</mark>

#### Пример:

1. **Транзакция T1** начинает выполнение и обновляет строку:
    
    - `{data: "new_value", xmin: T1, xmax: null}`
2. **Транзакция T2** начинает выполнение параллельно с T1:
    
    - Она получит снимок данных, в котором версия строки от T1 будет невидима, поскольку транзакция T1 еще не зафиксирована.
    - Транзакция T2 продолжит видеть старую версию строки (до изменений T1).
3. <mark class="hltr-red"> Если T1 зафиксируется до завершения T2, то T2 всё равно будет работать с той версией данных, которая была актуальна на момент её начала. T2 не увидит изменения от T1 до тех пор, пока сама не завершится и не начнет новую транзакцию.</mark>
    

#### 3. **Удаление и очистка старых версий строк**:

<mark class="hltr-orange">Так как PostgreSQL сохраняет старые версии строк, чтобы поддерживать MVCC, возникает вопрос: что происходит с этими версиями после завершения транзакций?</mark>

- **Автоочистка (VACUUM)**: <mark class="hltr-red">PostgreSQL использует процесс **VACUUM** для очистки старых версий строк, которые больше не нужны никаким транзакциям. Когда все транзакции, которые могли бы увидеть старую версию строки, завершаются, эта старая версия становится ненужной и может быть удалена.</mark>
- **HOT Updates (Heap-Only Tuples)**: Для оптимизации хранения данных PostgreSQL поддерживает механизм **HOT Updates**, который позволяет обновлять строки в том же месте на диске, если определенные условия выполняются. Это снижает фрагментацию и уменьшает нагрузку на VACUUM.

### Пример использования MVCC на практике:

Предположим, что у вас есть система управления заказами, в которой несколько пользователей одновременно работают с данными:

- Один пользователь изменяет информацию о заказе.
- Другой пользователь просматривает текущие заказы.

Без механизма MVCC, при отсутствии блокировок, пользователь, который просматривает данные, мог бы увидеть незавершенные изменения, что приведет к несогласованности информации.

С MVCC:

- Пользователь, который просматривает данные, видит **согласованное состояние** на момент начала своей транзакции, даже если кто-то параллельно изменяет данные.
- Пользователь, изменяющий данные, работает с собственными изменениями, и они станут видны другим только после фиксации (COMMIT).

### Преимущества MVCC:

1. **Изоляция транзакций**: MVCC позволяет транзакциям видеть согласованное состояние базы данных без необходимости блокировать доступ к данным для других транзакций.
2. **Устранение блокировок на чтение**: Чтение и запись данных могут происходить параллельно, не блокируя друг друга, что существенно повышает производительность.
3. **Повышение производительности**: MVCC позволяет выполнять большее количество транзакций одновременно, уменьшая конфликтность при доступе к данным.

### Уровни изоляции транзакций в PostgreSQL с MVCC:

1. **READ COMMITTED**: Это уровень по умолчанию. Транзакция видит только те данные, которые были зафиксированы до начала выполнения каждой команды внутри транзакции. Изменения других транзакций, зафиксированные во время выполнения транзакции, могут быть видны при следующем запросе.
    
2. **REPEATABLE READ**: Транзакция видит снимок данных на момент её начала. Даже если другие транзакции вносят изменения и фиксируют их во время выполнения этой транзакции, она не увидит эти изменения до своего завершения.
    
3. **SERIALIZABLE**: Самый строгий уровень изоляции, который гарантирует, что транзакции будут выглядеть так, будто они выполняются последовательно, одна за другой. Это достигается за счет проверки конфликтов между транзакциями и возможного отката транзакций в случае нарушения изоляции.
    

### Заключение

**MVCC в PostgreSQL** — это сложный и мощный механизм, обеспечивающий изоляцию транзакций и высокую производительность при работе с конкурентными запросами. Основная идея MVCC заключается в том, что каждая транзакция работает со "снимком" базы данных, обеспечивая согласованное чтение данных и минимизируя блокировки при одновременном чтении и записи. Этот подход позволяет PostgreSQL поддерживать высокую степень параллелизма и производительности, что особенно важно для приложений с высокой нагрузкой на базу данных.


### Уровни изоляции в PostgreSQL:

1. **READ COMMITTED (чтение зафиксированных данных)**:
    
    - Это уровень по умолчанию в PostgreSQL.
    - Транзакция видит только те изменения, которые были зафиксированы на момент выполнения каждой отдельной команды (`SELECT`, `UPDATE` и т. д.).
    - Незавершенные транзакции остаются невидимыми для текущей транзакции.
2. **REPEATABLE READ (повторяемое чтение)**:
    
    - Транзакция получает "снимок" базы данных на момент своего начала.
    - Все запросы внутри транзакции видят одну и ту же версию данных, даже если параллельно другие транзакции вносят изменения и фиксируют их.
3. **SERIALIZABLE (сериализуемая изоляция)**:
    
    - Транзакции исполняются так, будто они выполняются последовательно, одна за другой, без параллельного изменения данных.
    - Этот уровень изоляции обеспечивает максимальную изоляцию транзакций и предотвращает возникновение аномалий в конкурентных запросах.

### Уровень изоляции **READ UNCOMMITTED**:

В некоторых других СУБД (например, в MySQL) существует уровень изоляции **READ UNCOMMITTED**, который позволяет транзакции видеть изменения, даже если они еще не зафиксированы другой транзакцией. Это может привести к проблемам вроде **грязного чтения** (dirty reads), когда транзакция видит несогласованные данные, которые могут быть откатаны.

Однако PostgreSQL **не поддерживает** этот уровень изоляции, что исключает возможность грязного чтения. Даже если вы явно установите уровень изоляции `READ UNCOMMITTED`, PostgreSQL по факту будет использовать **READ COMMITTED**.

### Почему в PostgreSQL транзакция не видит незавершенные изменения?

В PostgreSQL, при использовании механизма **MVCC**, каждая транзакция видит только те версии строк, которые были зафиксированы до начала выполнения конкретной команды. Незавершенные транзакции, такие как T1 в вашем примере, остаются невидимыми для других транзакций, пока не произойдет явная фиксация (COMMIT). В этом и заключается суть уровня изоляции **READ COMMITTED**: он предотвращает **грязные чтения**, что гарантирует, что данные всегда будут согласованными.

### Когда транзакция **T2** может увидеть незавершенные изменения?

В **PostgreSQL**, транзакция T2 **не может увидеть незавершенные изменения**, потому что:

- **MVCC** гарантирует, что каждая транзакция работает с версией данных, актуальной на момент начала её операции, и не видит незавершенных транзакций.
- Независимо от уровня изоляции (даже если это был бы условный `READ UNCOMMITTED`), в PostgreSQL транзакция видит только зафиксированные данные.

### Ответ на вопрос:

**В PostgreSQL транзакция T2 не сможет увидеть изменения от транзакции T1 до тех пор, пока T1 не зафиксирует свои изменения (COMMIT)**. Даже если бы был установлен уровень изоляции **READ UNCOMMITTED** (который PostgreSQL всё равно "понизил" бы до **READ COMMITTED**), это не дало бы возможности транзакции T2 увидеть изменения до фиксации.

Таким образом, в PostgreSQL такого случая, когда транзакция видит незавершенные изменения, не произойдет из-за особенностей реализации уровней изоляции и механизма MVCC.