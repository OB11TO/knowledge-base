---
title: GiST Generalized Search Tree
tags:
  - PostgreSql
related_topics: 
created: 2024-12-03 16:56
modified: 2024-12-05T16:57:23+03:00
questions: 
notes: 
links: 
---


![[Pasted image 20241203165711.png]]



![[Pasted image 20241203165823.png]]

 ![[Pasted image 20241203173343.png]]
 ![[Pasted image 20241203173407.png]]
 ![[Pasted image 20241203173436.png]]
![[Pasted image 20241203173511.png]]
![[Pasted image 20241203173522.png]]


---------------------------------


![[Pasted image 20241203173759.png]]
![[Pasted image 20241203173821.png]]

 ![[Pasted image 20241203173906.png]]

-----------------

![[Pasted image 20241203174243.png]]
![[Pasted image 20241203174305.png]]
- <mark class="hltr-red">Это плохо так делать !!!!!!!!!!!!</mark>
![[Pasted image 20241203174331.png]]

![[Pasted image 20241203174430.png]]
![[Pasted image 20241203174525.png]]

![[Pasted image 20241203175205.png]]

----------------------

 GiST — сбалансированное по высоте дерево, состоящее из узлов-страниц. Узлы состоят из индексных записей.  
  
Каждая запись листового узла (листовая запись) содержит, если говорить в самом общем виде, некий _предикат_ (логическое выражение) и ссылку на строку таблицы (TID). Индексированные данные (ключ) должны удовлетворять этому предикату.

Каждая запись внутреннего узла (внутренняя запись) также содержит _предикат_ и ссылку на дочерний узел, причем все индексированные данные дочернего поддерева должны удовлетворять этому предикату. Иными словами, предикат внутренней записи _включает_ в себя предикаты всех дочерних записей. Это важное свойство, заменяющее индексу GiST простую упорядоченность B-дерева.

**GiST (Generalized Search Tree)** — это обобщенная структура индекса в PostgreSQL, которая подходит для работы с данными, требующими сложных запросов, например, геометрическими, полнотекстовыми или многомерными данными. Это мощный и универсальный инструмент для создания индексов для нестандартных типов данных.

---

### Что такое GiST?

**GiST** (Generalized Search Tree) — это **обобщённая структура дерева** для поиска, которая позволяет PostgreSQL поддерживать произвольные типы данных и запросы. По сути, GiST предоставляет основу (или API), которая позволяет разработчикам добавлять собственные типы данных и логику поиска.

---

### Основные характеристики GiST

1. **Обобщённость**:
    
    - GiST можно настроить для любых типов данных, если реализовать специфические функции сравнения.
    - Это "платформа" для создания индексов.
2. **Иерархическая структура**:
    
    - Индекс построен как сбалансированное дерево (например, B-Tree), где каждая ветка дерева покрывает определённый диапазон или свойство данных.
3. **Гибкость**:
    
    - Поддерживает множество типов данных: геометрические объекты, JSON, полнотекстовые данные, IP-адреса и многое другое.
4. **Пользовательская логика**:
    
    - Разработчики могут написать свои алгоритмы для управления индексом (например, как определить пересечение для геометрических данных).

---

### Из чего состоит GiST

1. **Узлы дерева**:
    
    - Каждый узел хранит **ключи (предикаты)**, которые определяют, какие данные могут находиться в его подузлах.
    - Например, для геометрического индекса узел может хранить **минимальный ограничивающий прямоугольник (bounding box)**.
2. **Листовые узлы**:
    
    - Хранят ссылки на строки таблицы, удовлетворяющие условиям из предикатов.
3. **Обобщенные операции**:
    
    - Каждый тип данных определяет свои операции:
        - Например, "пересечение" для геометрии, "поиск подстроки" для текстов и т.д.

---

### Как GiST работает под капотом?

1. **Добавление данных**:
    
    - Когда добавляется новая строка, система определяет, в какой узел дерева её поместить.
    - Узел определяется с помощью **пользовательских функций** сравнения.
2. **Запрос данных**:
    
    - При запросе обходится только часть дерева (подходящие узлы).
    - Например, при поиске точек внутри прямоугольника будет обходиться только узлы, чьи "bounding box" пересекаются с прямоугольником.
3. **Балансировка дерева**:
    
    - GiST является сбалансированным деревом. Когда узел заполняется, он разбивается на две части (split).
4. **Пользовательские функции**:
    
    - GiST использует определённые пользователем функции для управления:
        - **Union**: объединяет несколько значений в один ключ.
        - **Compress/Decompress**: сжатие и восстановление данных.
        - **Penalty**: вычисляет, насколько новый ключ "плох" для текущего узла.
        - **PickSplit**: решает, как разбить узел, если он переполнен.

---

### Где применяется GiST?

1. **Геометрические данные**:
    
    - Для поиска пересечений, ближайших объектов, например, в GIS (геоинформационные системы).
    - Пример: найти все дома в радиусе 10 км.
2. **Полнотекстовый поиск**:
    
    - Поиск совпадений слов или фраз в текстах.
3. **Многомерные данные**:
    
    - Индексация данных с несколькими параметрами, например, временные ряды.
4. **Данные, имеющие сложные свойства**:
    
    - Например, поиск IP-адресов в сетях.

---

### Отличия GiST от GIN

|**Характеристика**|**GiST**|**GIN**|
|---|---|---|
|**Тип данных**|Подходит для произвольных данных.|Подходит для данных с большим количеством вложенных элементов (массивы, JSON).|
|**Универсальность**|Очень универсален: поддерживает геометрические, текстовые и др. данные.|Специализирован для массивов и полнотекстового поиска.|
|**Производительность вставки**|Медленнее при вставке, так как дерево нужно постоянно балансировать.|Быстрее при вставке, так как использует другую структуру индекса.|
|**Производительность запроса**|Лучше для диапазонов, пересечений и сложных запросов.|Быстрее для поиска точных значений в массивах/текстах.|
|**Использование памяти**|Использует меньше памяти для хранения индекса.|Требует больше памяти для построения индекса.|

---

### Когда применять GiST, а когда GIN?

- **Применять GiST**:
    
    - Для геометрических данных (поиск по областям, пересечения).
    - Для сложных запросов, работающих с многомерными или непредсказуемыми данными.
    - Если вы разрабатываете собственный тип данных с особыми условиями поиска.
- **Применять GIN**:
    
    - Для массивов, JSON, полнотекстового поиска.
    - Когда важно быстро искать точные совпадения в большом количестве вложенных элементов.

---

### Преимущества и недостатки GiST

#### Преимущества:

1. **Универсальность**:
    - Подходит для широкого спектра данных.
2. **Иерархическая структура**:
    - Поддерживает сложные запросы (диапазоны, пересечения).
3. **Расширяемость**:
    - Разработчики могут добавить поддержку новых типов данных.

#### Недостатки:

1. **Медленнее вставка**:
    - Построение дерева требует дополнительных операций.
2. **Требует разработки пользовательских функций**:
    - Нужно реализовать специфические операции для работы с данными.
3. **Не оптимален для массивов и полнотекстового поиска**:
    - Здесь лучше подходит GIN.


```sql
CREATE TABLE shapes ( id SERIAL PRIMARY KEY, geom GEOMETRY ); 
-- Создание GiST индекса 
CREATE INDEX idx_shapes_geom ON shapes USING gist (geom); 
-- Поиск объектов в радиусе 
SELECT * FROM shapes WHERE ST_DWithin(geom, ST_MakePoint(10, 20)::geometry, 1000);
```

```sql
CREATE TABLE documents ( id SERIAL PRIMARY KEY, content TEXT );
-- Создание GiST индекса для текстового поиска 
CREATE INDEX idx_docs_content ON documents USING gist (to_tsvector('english', content));
-- Поиск по тексту 
SELECT * FROM documents WHERE to_tsvector('english', content) @@ to_tsquery('example');
```


Да, **GiST индекс** можно использовать для работы с `JSONB`, так как он универсален и поддерживает широкий спектр операций. Однако, для `JSONB` в PostgreSQL чаще используется **GIN (Generalized Inverted Index)**, поскольку он лучше оптимизирован для таких задач. Рассмотрим, почему использование GiST для `JSONB` не является предпочтительным, и в каких случаях это всё же имеет смысл.

---

### Почему GIN лучше для `JSONB`?

1. **Оптимизация для вложенных структур**:
    
    - `JSONB` часто содержит множество вложенных ключей и значений. GIN индекс предназначен для индексации большого числа элементов, что делает его особенно подходящим для вложенных данных.
    - GIN индекс строится как обратный индекс, где для каждого ключа/значения хранится список строк, где они встречаются. Это позволяет очень быстро находить данные по конкретным ключам.
2. **Производительность поиска**:
    
    - GIN индекс быстрее обрабатывает запросы, связанные с конкретными ключами или значениями в `JSONB`.
    - Примеры запросов, которые GIN обрабатывает эффективно:
        - Поиск всех строк, где `JSONB` содержит определённый ключ.
        - Поиск всех строк, где значение ключа равно указанному значению.
3. **Размер индекса**:
    
    - GIN индекс, хотя и занимает больше памяти, строится более компактно, чем GiST при индексации сложных структур данных. В случае больших таблиц это важно для экономии пространства.
4. **Специфические функции для JSONB**:
    
    - PostgreSQL предоставляет специальные операторы для работы с `JSONB` (`@>`, `?`, `?|`, `?&`), которые хорошо оптимизированы для работы с GIN.

---

### Почему GiST хуже для `JSONB`?

1. **Иерархическая структура**:
    
    - GiST построен как дерево, которое хранит диапазоны или свойства данных. Для `JSONB` это не так эффективно, потому что поиск в `JSONB` обычно не связан с диапазонами или пересечениями, а ориентирован на точные ключи/значения.
    - При индексации `JSONB` с помощью GiST потребуется обходить больше узлов дерева, что замедляет поиск.
2. **Производительность обновлений**:
    
    - GiST индекс медленнее при вставке и обновлении данных, так как требует балансировки дерева.
3. **Сложность реализации**:
    
    - Для работы с `JSONB` через GiST нужно настроить специфические функции, такие как `penalty`, `picksplit` и т.д. Встроенные возможности PostgreSQL для `JSONB` через GiST гораздо менее оптимизированы, чем для GIN.

---

### Когда можно использовать GiST для `JSONB`?

Использование GiST для `JSONB` оправдано в редких случаях, когда данные в `JSONB` требуют **поиска по диапазонам** или других специфических операций, которые GIN не поддерживает. Например:

1. **Многомерные запросы**:
    
    - Если `JSONB` содержит числовые данные (например, координаты, временные ряды), и вам нужно искать значения, попадающие в определённый диапазон.
2. **Кастомные запросы**:
    
    - Если вы разрабатываете собственные функции сравнения для `JSONB`, которые не поддерживаются GIN.

Пример:

sql

Копировать код

`CREATE INDEX idx_gist_jsonb ON my_table USING gist (jsonb_column jsonb_path_ops);`

---

### Минусы использования GiST для `JSONB`

1. **Медленный поиск**:
    
    - При работе с большими объемами данных производительность GiST будет значительно уступать GIN.
2. **Более сложная настройка**:
    
    - GiST требует реализации дополнительных функций для сравнения значений, объединения и разделения диапазонов.
3. **Ограниченная поддержка JSONB-операций**:
    
    - Многие операторы `JSONB` (`@>`, `?`) не будут работать эффективно с GiST.

---

### Когда использовать GIN для JSONB?

1. **Частые запросы на наличие ключей**:
    
    - Например:
        
        sql
        
        Копировать код
        
        `SELECT * FROM my_table WHERE jsonb_column ? 'key';`
        
2. **Запросы по содержанию поддокумента**:
    
    - Например:
        
        sql
        
        Копировать код
        
        `SELECT * FROM my_table WHERE jsonb_column @> '{"key": "value"}';`
        
3. **Массовая индексация вложенных данных**:
    
    - Когда нужно индексировать большое количество ключей и значений.

Пример:

sql

Копировать код

`CREATE INDEX idx_gin_jsonb ON my_table USING gin (jsonb_column jsonb_path_ops);`

---

### Вывод: когда и что использовать?

1. **Используйте GIN**, если ваши запросы связаны с ключами/значениями и операторами вроде `@>` или `?`. Это самый эффективный и стандартный выбор для `JSONB`.
    
2. **Используйте GiST**, если ваши данные требуют работы с диапазонами или сложными пользовательскими функциями, где стандартный GIN не подходит.
    

**В общем случае для JSONB выбор очевиден: GIN быстрее, проще и эффективнее. GiST следует рассматривать как редкое и специфическое решение.**