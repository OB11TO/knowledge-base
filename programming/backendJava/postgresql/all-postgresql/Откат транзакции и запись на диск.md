---
title: Откат транзакции и запись на диск
tags:
  - PostgreSql
related_topics: 
created: 2024-10-02 16:08
modified: 2024-10-02T16:24:04+03:00
questions: 
notes: 
links: 
---


Этот вопрос связан с тем, как работает **MVCC (Multiversion Concurrency Control)** и управление транзакциями в **PostgreSQL**. Чтобы понять, как **прерванная транзакция** может создать новые версии строк, важно осознать несколько ключевых моментов:

### 1. **Создание новых версий строк в MVCC**:

В PostgreSQL новые версии строк создаются **сразу при изменении данных** — независимо от того, будет ли транзакция впоследствии зафиксирована (**commit**) или прервана (**rollback**). То есть при каждом изменении данных (например, `UPDATE` или `DELETE`) **сразу создаются новые версии строк** в памяти (буферах), которые могут быть записаны на диск позже. Однако эти новые версии строк становятся "видимыми" только для транзакций, которые могут их использовать на основании состояния самой транзакции, которая их создала.

### 2. **Буферизация данных и дисковое хранилище**:

Данные, измененные транзакцией, **сначала попадают в буферы в памяти** (shared buffer pool). Однако до того, как транзакция зафиксируется, PostgreSQL может записать эти изменения на диск, но они будут **невидимы для других транзакций**, пока транзакция не будет успешно завершена. Таким образом, физическая запись данных на диск может происходить до фиксации транзакции, но на логическом уровне транзакция считается завершённой только после коммита.

### 3. **Роль статуса транзакции**:

Когда транзакция изменяет строки в таблице, к каждой новой версии строки прикрепляется информация о том, какая транзакция её создала (через специальные метаданные, такие как **`xmin`** — идентификатор транзакции, которая создала строку). Когда транзакция завершена успешно (коммит), эта версия строки становится доступной для других транзакций. Если транзакция была прервана (rollback), другие транзакции могут видеть, что версия строки была создана неуспешной транзакцией, и **игнорируют её**.

Эта информация о статусе транзакций хранится в **системных таблицах**, и каждая транзакция может проверить статус транзакции, создавшей версию строки (успешно ли она завершилась или нет). Это позволяет другим транзакциям **не учитывать** изменения, сделанные транзакциями, которые были прерваны.

### 4. **Что происходит при прерывании транзакции (rollback)**:

Когда транзакция прерывается (неудачно завершается), созданные ею версии строк **физически не удаляются немедленно**. Они остаются в базе данных до тех пор, пока их не уберет **VACUUM** — процесс, который периодически очищает базу данных от "мусорных" (неактуальных) версий строк, созданных прерванными транзакциями.

До тех пор, пока не произойдет вакуумизация, информация о том, что транзакция была прервана, позволяет другим транзакциям **игнорировать** эти "мусорные" версии строк, потому что в метаданных строки хранится информация о том, что транзакция, создавшая эту версию, была неуспешной.

### 5. **Запись данных на диск и буферизация**:

Хотя данные транзакции могут находиться в буфере памяти до коммита, **PostgreSQL не дожидается коммита для записи данных на диск**. Это связано с тем, что PostgreSQL использует **write-ahead logging (WAL)** — метод, при котором сначала записываются логи изменений, и только потом данные могут быть фактически записаны на диск.

- **WAL (write-ahead log)** хранит информацию о том, что именно было изменено транзакцией. Если транзакция прерывается, WAL гарантирует, что изменения, сделанные транзакцией, не будут применены к основным данным базы данных.
- После того как транзакция завершается (commit или rollback), происходит актуализация данных — данные, записанные в WAL, применяются или игнорируются в зависимости от состояния транзакции.

### Пример:

1. **Начало транзакции**: Транзакция A делает `UPDATE` в таблице, изменяя строку X. Эта строка X получает новую версию в буфере памяти. В таблице сохраняются обе версии строки X — старая и новая (с метаданными, указывающими на транзакцию A).
    
2. **Создание новой версии строки**: Новая версия строки X может быть записана на диск (при необходимости). Однако она не будет видна другим транзакциям, пока транзакция A не завершится успешно.
    
3. **Прерывание транзакции**: Транзакция A прерывается (rollback). Новая версия строки X всё ещё физически присутствует на диске (или в буфере), но метаданные этой версии указывают на то, что транзакция A прервана.
    
4. **Поведение других транзакций**: Другие транзакции, обращающиеся к строке X, увидят старую версию, потому что они смогут узнать, что новая версия строки была создана неуспешной транзакцией, и проигнорируют её.
    
5. **VACUUM**: Позднее процесс **VACUUM** удалит новую версию строки X, так как она считается "мусорной", поскольку была создана прерванной транзакцией.
    

### Заключение:

Прерванная транзакция действительно может создать новые версии строк, которые будут находиться как в буфере, так и потенциально на диске. Эти версии строк не становятся видимыми для других транзакций, так как **метаданные о состоянии транзакции** говорят о том, что она не завершилась успешно. Только процесс **VACUUM** очищает эти неактуальные версии строк позднее, когда они уже не нужны.

----


>[!faq] Когда может быть такое, что транзакция еще работает, а строки записались из буффера на диск, а потом транзакция откатилась

Да, такая ситуация действительно возможна в **PostgreSQL**, когда данные транзакции ещё не завершены (транзакция "работает"), и при этом изменения, сделанные транзакцией, уже могут быть записаны на диск из буферов. Давайте разберём, как это возможно, почему это не нарушает целостность данных, и что происходит в случае отката транзакции.

### Механизм записи на диск в PostgreSQL:

1. **Запись в буфер (shared buffers)**: Когда транзакция изменяет данные, эти изменения сначала записываются в **буферы** в оперативной памяти (shared buffers). Это быстрый способ работы с данными перед их записью на диск.
    
2. **Запись в WAL**: Одновременно с изменением данных в буферах, транзакция **записывает соответствующие изменения в WAL** (Write-Ahead Log) — специальный журнал, который фиксирует все изменения. **Запись в WAL выполняется до записи данных на диск**, чтобы гарантировать, что даже в случае сбоя можно будет восстановить транзакцию.
    
3. **Запись данных на диск из буфера**: Данные из буферов могут быть записаны на диск **ещё до завершения транзакции** (например, при переполнении буферов, контрольных точках, или других триггерах записи). Однако это не означает, что они становятся видимыми для других транзакций — механизм контроля версий (MVCC) обеспечивает видимость данных в зависимости от состояния транзакции.
    

### Как PostgreSQL предотвращает проблемы при откате:

#### 1. **WAL как источник истины**:

Даже если данные из буферов были записаны на диск, они не считаются "действительными" до тех пор, пока транзакция не завершится. Главное, что информация о транзакции и её статус хранится в WAL.

- **WAL обеспечивает "атомарность" изменений**: Если транзакция успешно завершилась (commit), все изменения становятся постоянными. Если транзакция откатилась (rollback), данные будут проигнорированы.

#### 2. **MVCC (Multi-Version Concurrency Control)**:

PostgreSQL использует MVCC для управления версиями строк. Каждая строка в таблице имеет два метаданных:

- **xmin** — ID транзакции, которая создала эту версию строки.
- **xmax** — ID транзакции, которая "удалила" или обновила эту версию строки.

Пока транзакция работает, другие транзакции не увидят изменений, сделанных этой транзакцией, потому что система MVCC следит за тем, какие версии строк должны быть видны каждой транзакции. Если транзакция откатится, PostgreSQL просто отметит, что изменения, сделанные этой транзакцией, недействительны, и другие транзакции никогда не увидят этих изменений.

#### 3. **Откат транзакции (rollback)**:

Когда транзакция откатывается, она фактически не "удаляет" свои изменения, но помечает их как недействительные. Вот что происходит:

- **Если данные уже записаны на диск** (из буфера), они всё равно остаются на месте, но становятся невидимыми для других транзакций.
- PostgreSQL использует информацию о статусе транзакции (успешная или неуспешная) для того, чтобы игнорировать эти данные. Строки, созданные или изменённые прерванной транзакцией, не будут видны другим транзакциям.

#### 4. **VACUUM**:

Со временем PostgreSQL выполняет процесс **VACUUM**, который очищает "мёртвые" версии строк — те, которые были созданы откатившимися транзакциями или заменены новыми версиями в случае обновления строк. VACUUM не нужен немедленно при откате транзакции, так как система и так знает, что строки этой транзакции недействительны, но VACUUM убирает их для освобождения пространства и повышения производительности.

### Пример ситуации:

1. **Транзакция T1** начинает работу и делает изменения в строке:

```sql
UPDATE my_table SET value = 'new_value' WHERE id = 1;
```

1.  Изменения записываются в буферы, и одновременно информация записывается в WAL.
2. Буферы начинают заполняться, и PostgreSQL решает записать данные на диск, несмотря на то, что транзакция T1 ещё не завершилась (commit не был выполнен).
    
    - Данные попадают на диск, но остаются "невидимыми" для других транзакций, потому что транзакция T1 ещё не завершена.
3. **Транзакция T1 откатывается (rollback)**.
    
    - Несмотря на то, что данные уже были записаны на диск, они **не будут видны** другим транзакциям. PostgreSQL использует информацию о состоянии транзакции (неудачная транзакция), чтобы игнорировать эти изменения.
4. **Процесс VACUUM** позже очистит мёртвые строки, созданные транзакцией T1.
    

### Заключение:

Запись данных на диск может произойти **до завершения транзакции**. Однако это не нарушает согласованность данных благодаря:

- Механизму **WAL**, который фиксирует изменения и гарантирует восстановление состояния при сбое.
- Системе **MVCC**, которая управляет версиями строк и контролирует их видимость для других транзакций.
- Процессу **VACUUM**, который со временем очищает мёртвые строки.

Таким образом, даже если данные были записаны на диск до завершения транзакции, они не станут видимыми другим транзакциям, если транзакция откатилась.