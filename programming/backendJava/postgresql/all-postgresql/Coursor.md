---
title: Coursor
tags:
  - PostgreSql
related_topics: 
created: 2024-09-24 17:25
modified: 2024-09-24T17:30:20+03:00
questions: 
notes: 
links: 
---

Курсоры в базах данных используются для поэтапной обработки набора данных, которые возвращаются SQL-запросами. Они позволяют работать с результатами выборки по одной строке за раз, что особенно полезно для сложной обработки больших наборов данных или выполнения пошаговых операций с данными.

### Зачем нужны курсоры?

Курсоры предоставляют возможность выполнять **последовательную обработку результатов выборки** в ситуациях, когда работа с данными требует **поэтапного подхода**, например:

- **Обработка больших наборов данных**, когда выборка всей таблицы за один запрос может вызвать проблемы с памятью.
- **Построчная обработка**, когда каждая строка данных требует выполнения сложной логики, например, расчёта значений, обновления данных или вызова других процедур.
- **Изоляция операций**: можно выполнять операции над набором данных по одной записи, не загружая в память весь набор данных сразу.

### Как работают курсоры?

Курсор открывается для выполнения запроса, затем происходит чтение по одной строке данных. По мере необходимости данные могут быть изменены, удалены или обновлены.

Основные операции с курсорами:

1. **Открытие курсора** (`OPEN`) — курсор начинает выполнение запроса и становится доступным для чтения данных.
2. **Получение следующей строки данных** (`FETCH`) — извлечение следующей строки из набора данных, возвращённого запросом.
3. **Закрытие курсора** (`CLOSE`) — завершение работы курсора, освобождение всех связанных ресурсов.
4. **Обновление данных через курсор** (опционально) — в некоторых базах данных можно обновлять строки, которые были извлечены через курсор.

### Пример использования курсора

Пример курсора в SQL (например, на базе данных PostgreSQL):
```sql
DECLARE employee_cursor CURSOR FOR
SELECT employee_id, first_name, last_name, salary
FROM employees;

-- Открытие курсора
OPEN employee_cursor;

-- Получение следующей строки
FETCH NEXT FROM employee_cursor INTO @employee_id, @first_name, @last_name, @salary;

-- Закрытие курсора после обработки
CLOSE employee_cursor;

```


Этот пример демонстрирует простое использование курсора для последовательной обработки данных по строкам.

### Когда лучше использовать курсоры?

1. **Обработка больших наборов данных**: Когда выборка возвращает слишком много строк для обработки сразу, курсоры позволяют читать строки по одной и обрабатывать их без перегрузки памяти.
    
2. **Построчная обработка**: Если каждая строка требует сложных вычислений или взаимодействия с другими таблицами, курсор позволит это сделать последовательно.
    
3. **Когда требуется сложная логика**: Курсоры полезны для ситуаций, когда каждая строка должна обрабатываться отдельно, и эта обработка может включать обновление, удаление, запись данных или вызов процедур.
    

### Недостатки курсоров

1. **Низкая производительность**: Курсоры, особенно если они используются неправильно, могут значительно замедлить работу приложения. Выполнение операций по одной строке — это более медленный процесс, чем работа с данными через массовые обновления или выборки. Обычно **массовая обработка данных** (например, с использованием операторов `UPDATE` или `DELETE`) предпочтительнее.
    
2. **Удержание ресурсов**: Курсоры используют ресурсы базы данных (память, соединения), и если курсоры не закрыты вовремя, это может привести к утечкам ресурсов.
    
3. **Сложность отладки и поддержки**: Код, который использует курсоры, может быть сложнее для отладки и сопровождения, чем работа с набором данных сразу.
    

### Реальные практики использования курсоров на уровне Senior

1. **Обработка больших наборов данных**: Если у вас есть огромная таблица с миллионами записей, которую нужно обработать, но поэтапно, например, обновить данные, передать их в другую систему, рассчитать значения — курсор позволяет это сделать безопасно, не загружая все данные в память.
    
    Пример задачи:
    
    - Вы хотите обработать данные о транзакциях пользователей, делая расчёты по каждой строке транзакции. При этом каждую строку нужно обновить в исходной таблице, и нагрузка на систему должна быть распределена.
2. **Сложные циклы обработки**: Представим задачу, где для каждой строки требуется сложная бизнес-логика. Например, у вас есть заказы клиентов, и каждый заказ нужно обработать индивидуально, включая проверку данных в других таблицах, вызов других процедур или API. В этом случае курсор позволит построчно обрабатывать данные, что может быть удобнее, чем массовая обработка.
    
3. **Работа с устаревшими системами**: В устаревших системах курсоры часто используются для симуляции логики построчной обработки данных, когда системы не поддерживают массовые операции или транзакции. Например, при интеграции со старыми ERP-системами или пакетной обработке данных.
    

### Примеры с практикой:

#### Пример 1: Обработка данных с курсором в транзакции

Этот пример показывает, как можно использовать курсор для обработки данных построчно внутри транзакции.

```sql
DECLARE emp_cursor CURSOR FOR
SELECT employee_id, salary FROM employees;

-- Открываем курсор
OPEN emp_cursor;

-- Начинаем транзакцию
BEGIN;

-- Переменная для хранения результата
DECLARE @employee_id INT, @salary DECIMAL;

FETCH NEXT FROM emp_cursor INTO @employee_id, @salary;

WHILE @@FETCH_STATUS = 0
BEGIN
   -- Выполняем бизнес-логику: например, обновляем зарплату
   UPDATE employees SET salary = salary * 1.05 WHERE employee_id = @employee_id;

   -- Получаем следующую строку
   FETCH NEXT FROM emp_cursor INTO @employee_id, @salary;
END;

-- Закрываем курсор
CLOSE emp_cursor;

-- Завершаем транзакцию
COMMIT;

```

В этом примере мы увеличиваем зарплату каждого сотрудника на 5% построчно, что может быть полезно, если бизнес-логика требует индивидуальных проверок или сложных операций с каждой записью.

#### Пример 2: Использование курсора с динамическими данными

В этом примере курсор используется для последовательного выполнения запроса с динамическими изменениями в данных:

```sql
DECLARE dynamic_cursor CURSOR FOR
SELECT order_id, customer_id, status
FROM orders
WHERE status = 'pending';

-- Открываем курсор
OPEN dynamic_cursor;

-- Переменная для хранения результата
DECLARE @order_id INT, @customer_id INT, @status VARCHAR(10);

FETCH NEXT FROM dynamic_cursor INTO @order_id, @customer_id, @status;

WHILE @@FETCH_STATUS = 0
BEGIN
   -- Проверка и обновление статуса заказа
   IF (@customer_id IS NOT NULL)
   BEGIN
       UPDATE orders SET status = 'processed' WHERE order_id = @order_id;
   END;

   -- Получаем следующую строку
   FETCH NEXT FROM dynamic_cursor INTO @order_id, @customer_id, @status;
END;

-- Закрываем курсор
CLOSE dynamic_cursor;

```

В этом случае курсор помогает обработать заказы, меняя их статус только после выполнения необходимых проверок.

`**Курсор**` — это объект базы данных, который позволяет приложениям работать с записями «по одной», а не сразу с множеством, как это делается в обычных SQL командах.

Порядок работы с курсором такой:

- Определить курсор (`DECLARE`)
- Открыть курсор (`OPEN`)
- Получить запись из курсора (`FETCH`)
- Обработать запись…
- Закрыть курсор (`CLOSE`)
- Удалить ссылку курсора (`DEALLOCATE`). Когда удаляется последняя ссылка курсора, SQL освобождает структуры данных, составляющие курсор.

### Заключение:

- **Курсоры** удобны для обработки данных по одной записи, особенно если каждая строка требует выполнения сложных операций.
- Курсоры можно эффективно использовать в ситуациях, когда нельзя обработать весь набор данных одновременно.
- Основная проблема курсоров — их производительность. Поэтому они используются там, где массовые операции или другие техники обработки данных невозможны или неудобны.
- Современные базы данных имеют более эффективные способы обработки данных, такие как оконные функции и массовые операции, поэтому использование курсоров должно быть обосновано и рационально.