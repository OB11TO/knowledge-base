---
title: Почему снимки а не блокировки на разных уровнях
tags:
  - PostgreSql
related_topics: 
created: 2024-10-01 14:24
modified: 2025-04-21T14:43:20+03:00
questions: 
notes: 
links: 
---


Как мне представляется, разница между уровнями изоляции стандарта объясняется как раз количеством необходимых блокировок.  
  
Если транзакция блокирует изменяемые строки от изменения, но не от чтения, получаем уровень Read Uncommitted: потерянные изменения не допускаются, но можно прочитать незафиксированные данные.  
  
Если транзакция блокирует изменяемые строки и от чтения, и от изменения, получаем уровень Read Committed: незафиксированные данные прочитать нельзя, но при повторном обращении к строке можно получить другое значение (неповторяющееся чтение).  
  
Если транзакция блокирует и читаемые, и изменяемые строки и от чтения, и от изменения, получаем уровень Repeatable Read: повторное чтение строки будет выдавать то же значение.  
  
Но с Serializable проблема: невозможно заблокировать строку, которой еще нет. Из-за этого остается возможность фантомного чтения: другая транзакция может добавить (но не удалить) строку, попадающую под условия выполненного ранее запроса, и эта строка попадет в повторную выборку.  
  
Поэтому для реализации уровня Serializable обычных блокировок не хватает — нужно блокировать не строки, а условия (предикаты). Такие блокировки и были названы _предикатными_. Предложены они были еще в 1976 году, но их практическая применимость ограничена достаточно простыми условиями, для которых понятно, как объединять два разных предиката. До реализации таких блокировок в какой-либо системе дело, насколько мне известно, не дошло.

Со временем на смену блокировочным протоколам управления транзакциями пришел _протокол изоляции на основе снимков_ (Snapshot Isolation).

Его идея состоит в том, что каждая транзакция работает с согласованным снимком данных на определенный момент времени, в который попадают только те изменения, которые были зафиксированы до момента создания снимка.  
  
<mark class="hltr-yellow">Такая изоляция автоматически не допускает грязное чтение. Формально в PostgreSQL можно указать уровень Read Uncommitted, но работать она будет точно так же, как Read Committed. Поэтому про уровень Read Uncommitted мы дальше вообще не будем говорить.</mark>

В PostgreSQL реализован _многоверсионный_ вариант такого протокола. Идея многоверсионности состоит в том, что в СУБД могут сосуществовать несколько версий одной и той же строки. Это позволяет строить снимок данных, используя имеющиеся версии, и обходиться минимумом блокировок. Фактически блокируется только повторное изменение одной и той же строки. Все остальные операции выполняются одновременно: пишущие транзакции никогда не блокируют читающих транзакций, а читающие никогда не блокируют никого.

За счет использования снимков данных изоляция в PostgreSQL получается строже, чем того требует стандарт: уровень Repeatable Read не допускает не только неповторяющегося, но и фантомного чтения (хотя и не обеспечивает полную изоляцию). И достигается это без потери эффективности.

![[Pasted image 20241001142927.png]]



### **1. Что такое предикатная блокировка?**

**Предикат** — это условие в запросе (например, `WHERE age > 30`).  
**Предикатная блокировка** — это блокировка не конкретных строк, а **всех данных, которые удовлетворяют условию**, включая те, которых еще нет в базе.

**Цель:** предотвратить **фантомные чтения** (когда другая транзакция добавляет строки, подходящие под ваш запрос).

---

### **2. Пример: как это работает?**

Представьте, что вы работаете с таблицей `employees`:

|id|name|age|
|---|---|---|
|1|Alice|25|
|2|Bob|35|

#### **Сценарий без предикатных блокировок**

1. **Транзакция A** читает всех сотрудников старше 30 лет:  
    `SELECT * FROM employees WHERE age > 30;` → возвращает Боба (age=35).
    
2. **Транзакция B** добавляет нового сотрудника:  
    `INSERT INTO employees (name, age) VALUES ('Carol', 40);` → успешно.
    
3. **Транзакция A** снова выполняет запрос:  
    `SELECT * FROM employees WHERE age > 30;` → теперь видит Боба **и** Кэрол.
    

Это **фантомное чтение** (появилась «фантомная» строка).

---

#### **Сценарий с предикатными блокировками**

1. **Транзакция A** читает сотрудников старше 30 лет и **устанавливает предикатную блокировку** на условие `age > 30`.  
    → Теперь никто не может добавить, изменить или удалить строки, подходящие под это условие.
    
2. **Транзакция B** пытается добавить Кэрол (age=40):  
    → Система проверяет, попадает ли новая строка под заблокированный предикат (`age > 30`).  
    → Попадает! Транзакция B **ждет**, пока транзакция A не завершится.
    
3. **Транзакция A** завершается → блокировка снимается.
    
4. **Транзакция B** добавляет Кэрол.
    

Фантомных чтений нет!

---

### **3. Чем предикатные блокировки отличаются от обычных?**

- **Обычные блокировки** (например, на уровне строк или таблиц):  
    — Блокируют конкретные объекты: «строка с id=2», «вся таблица employees».  
    — Не защищают от добавления новых строк, подходящих под условие.
    
- **Предикатные блокировки**:  
    — Блокируют **логическое условие**: «все, где age > 30», включая будущие строки.  
    — Защищают от фантомных чтений.
    

---

### **4. Почему их сложно реализовать?**

#### **Проблема 1: Как определить пересечение предикатов?**

Допустим, есть две транзакции:

- Транзакция A блокирует `age > 30`.
    
- Транзакция B блокирует `age > 20`.
    

Новая строка с `age=25` подходит под оба условия.  
Система должна понимать, что предикаты пересекаются, и блокировать их корректно.  
→ Нужна сложная логика для анализа условий.

#### **Проблема 2: Производительность**

Проверка каждого нового запроса на пересечение со всеми существующими предикатами — это дорого.  
Пример:

- Если в системе 1000 активных транзакций с разными предикатами, для каждой новой строки нужно проверить 1000 условий.  
    → Замедляет работу.
    

#### **Проблема 3: Бесконечные условия**

Предикат может быть очень сложным:  
`WHERE (age > 30 AND department = 'IT') OR (salary > 100000)`  
→ Как хранить такие блокировки и проверять их на конфликты?  
→ Это требует «математического» анализа условий, что не всегда возможно.

---

### **5. Почему предикатные блокировки почти не используются?**

- **Теоретическая концепция**: Идея была предложена в 1976 году (в статье «Granularity of Locks»), но на практике реализовать ее для сложных условий оказалось почти невозможно.
    
- **Альтернативы**:  
    — **MVCC (Multiversion Concurrency Control)**: Версии данных (как в Snapshot Isolation).  
    — **SSI (Serializable Snapshot Isolation)**: Комбинирует MVCC с отслеживанием конфликтов (используется в PostgreSQL для уровня Serializable).  
    — **Пессимистичные блокировки**: Просто блокировать всю таблицу, если нужна строгая изоляция (но это замедляет работу).
    

---

### **6. Где сегодня встречается Serializable изоляция?**

- **PostgreSQL**: Использует SSI (не предикатные блокировки!).
    
- **Oracle/SQL Server**: Используют MVCC или гибридные подходы.
    

Эти системы достигают сериализуемости без предикатных блокировок, обходя их сложности.

---

### **Итог**

- **Предикатные блокировки** — это «идеальный» способ предотвратить фантомные чтения, блокируя условия.
    
- **Почему не используются**: Сложность реализации, проблемы с производительностью, есть более практичные альтернативы (SSI, MVCC).
    
- **Аналогия**: Это как запретить всем в библиотеке добавлять книги про динозавров, пока вы составляете их каталог. Технически возможно, но требует тотального контроля