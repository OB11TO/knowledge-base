---
title: Блокировки других объектов
tags:
  - PostgreSql
related_topics: 
created: 2024-11-19 16:36
modified: 2024-11-20T15:51:03+03:00
questions: 
notes: 
links: 
---


![[Pasted image 20241119170329.png]]


# Блокировки не-отношений

  
Когда требуется заблокировать ресурс, не являющийся _отношением_ в понимании PostgreSQL, используются блокировки типа object. <mark class="hltr-red">Таким ресурсом может быть почти все, что угодно: табличные пространства, подписки, схемы, роли, перечислимые типы данных… Грубо говоря все, что только можно найти в системном каталоге.  </mark>
  
Посмотрим на простом примере. Начинаем транзакцию и создаем в ней таблицу:

```sql
=> BEGIN;
=> CREATE TABLE example(n integer);
```

  
Теперь посмотрим, какие блокировки типа object появились в pg_locks:  
  

```sql
=> SELECT  database,  
(SELECT datname FROM pg_database WHERE oid = l.database) AS dbname, 
classid,  
(SELECT relname FROM pg_class WHERE oid = l.classid) AS classname,  
objid,  mode,  granted
FROM pg_locks l
WHERE l.locktype = 'object' 
AND l.pid = pg_backend_pid();
```

```
 database | dbname | classid |  classname   | objid |      mode       | granted
----------+--------+---------+--------------+-------+-----------------+---------
        0 |        |    1260 | pg_authid    | 16384 | AccessShareLock | t
    16386 | test   |    2615 | pg_namespace |  2200 | AccessShareLock | t
(2 rows)
```

  
Чтобы разобраться, что именно тут блокируется, надо смотреть на три поля: database, classid и objid. Начнем с первой строки.  
  
Database — это OID базы данных, к которой относится блокируемый ресурс. В нашем случае в этом столбце ноль. Это означает, что мы имеем дело с глобальным объектом, который не принадлежит к какой-либо конкретной базе.  
  
Classid содержит OID из pg_class, который соответствует имени таблицы системного каталога, которая и определяет тип ресурса. В нашем случае — pg_authid, то есть ресурсом является роль (пользователь).  
  
Objid содержит OID из той таблицы системного каталога, которую нам указал classid.  
  

```sql
=> SELECT rolname FROM pg_authid WHERE oid = 16384;
```

```sql
 rolname
---------
 student
(1 row)
```

  
Таким образом, заблокирована роль student, из-под которой мы работаем.  
  
Теперь разберемся со второй строкой. База данных указана, и это база test, к которой мы подключены.  
  
Classid указывает на таблицу pg_namespace, которая содержит схемы.  
  

```sql
=> SELECT nspname FROM pg_namespace WHERE oid = 2200;
```

```
 nspname
---------
 public
(1 row)
```

  
Таким образом, заблокирована схема public.  
  
Итак, мы увидели, что при создании объекта блокируются (в разделяемом режиме) роль-владелец и схема, в которой создается объект. Что и логично: иначе кто-нибудь мог бы удалить роль или схему, пока транзакция еще не завершена.  
  

```sql
=> ROLLBACK;
```



# Блокировка расширения отношения

  
Когда число строк в отношении (то есть в таблице, индексе, материализованном представлении) растет, PostgreSQL может использовать для вставки свободное место в имеющихся страницах, но, очевидно, в какой-то момент приходится добавлять и новые страницы. Физически они добавляются в конец соответствующего файла. Это и понимается под _расширением отношения_.  
  
Чтобы два процесса не кинулись добавлять страницы одновременно, этот процесс защищен специальной блокировкой с типом extend. Та же блокировка используется и при очистке индексов, чтобы другие процессы не могли добавлять страницы во время сканирования.  
  
Конечно, эта блокировка снимается, не дожидаясь конца транзакции.  
  

> Раньше таблицы расширялись только на одну страницу за раз. Это вызывало проблемы при одновременной вставке строк несколькими процессами, поэтому в версии PostgreSQL 9.6 сделали так, чтобы к таблицам добавлялось сразу несколько страниц (пропорционально числу ожидающих блокировку процессов, но не более 512).



# Блокировка страниц

  
Блокировка с типом page на уровне страницы применяется в единственном случае (если не считать предикатных блокировок, о которых позже).  
  
[GIN-индексы](https://habr.com/ru/company/postgrespro/blog/340978/) позволяют ускорять поиск в составных значениях, например, слов в текстовых документах (или элементов в массивах). Такие индексы в первом приближении можно представить как обычное B-дерево, в котором хранятся не сами документы, а отдельные слова этих документов. Поэтому при добавлении нового документа индекс приходится перестраивать довольно сильно, внося в него каждое слово, входящее в документ.  
  
Чтобы улучшить производительность, GIN-индексы обладают возможностью отложенной вставки, которая включается параметром хранения fastupdate. Новые слова сначала по-быстрому добавляются в неупорядоченный _список ожидания_ (pending list), а спустя какое-то время все накопившееся перемещается в основную индексную структуру. Экономия происходит за счет того, что разные документы с большой вероятностью содержат повторяющиеся слова.  
  
Чтобы исключить перемещение из списка ожидания в основной индекс одновременно несколькими процессами, на время переноса метастраница индекса блокируется в исключительном режиме. Это не мешает использованию индекса в обычном режиме.

# Рекомендательные блокировки

  
В отличие от других блокировок (таких, как блокировки отношений), _рекомендательные блокировки_ (<mark class="hltr-red">advisory locks</mark>)<mark class="hltr-yellow"> никогда не устанавливаются автоматически, ими управляет разработчик приложения. Их удобно использовать, например, если приложению для каких-то целей требуется логика блокирования, не вписывающаяся в стандартную логику обычных блокировок.  </mark>
   
<mark class="hltr-green2">Допустим, у нас есть условный ресурс, не соответствующий никакому объекту базы данных (который мы могли бы заблокировать командами типа SELECT FOR или LOCK TABLE). Нужно придумать для него числовой идентификатор. Если у ресурса есть уникальное имя, то простой вариант — взять от него хеш-код:  
  </mark>

```sql
=> SELECT hashtext('ресурс1');
```

```sql
 hashtext  
-----------
 243773337
(1 row)
```

  
Вот таким образом мы захватываем блокировку:  
  

```sql
=> BEGIN;
=> SELECT pg_advisory_lock(hashtext('ресурс1'));
```

  
Как обычно, информация о блокировках доступна в pg_locks:  
  

```sql
=> SELECT locktype, objid, mode, granted FROM pg_locks WHERE locktype = 'advisory' AND pid = pg_backend_pid();
```

```sql
 locktype |   objid   |     mode      | granted 
----------+-----------+---------------+---------
 advisory | 243773337 | ExclusiveLock | t
(1 row)
```

  
Чтобы блокирование действительно работало, другие процессы также должны получать его блокировку, прежде чем обращаться к ресурсу. Соблюдение этого правила, очевидно, должно обеспечиваться приложением.  
  
В приведенном примере блокировка действует до конца сеанса, а не транзакции, как обычно.  
  

```sql
=> COMMIT;
=> SELECT locktype, objid, mode, granted FROM pg_locks WHERE locktype = 'advisory' AND pid = pg_backend_pid();
```

```
 locktype |   objid   |     mode      | granted 
----------+-----------+---------------+---------
 advisory | 243773337 | ExclusiveLock | t
(1 row)
```

  
Ее нужно освобождать явно:  
  

```sql
=> SELECT pg_advisory_unlock(hashtext('ресурс1'));
```

  
Существуют большой набор функций для работы с рекомендательными блокировками на все случаи жизни:  
  

- pg_advisory_lock_shared получает разделяемую блокировку,
- pg_advisory_xact_lock (и pg_advisory_xact_lock_shared) получает блокировку до конца транзакции,
- pg_try_advisory_lock (а также pg_try_advisory_xact_lock и pg_try_advisory_xact_lock_shared) не ожидает получения блокировки, а возвращает ложное значение, если блокировку не удалось получить немедленно.

  
Набор try-функций представляет еще один способ не ждать блокировку, в дополнение к перечисленным [в прошлой статье](https://habr.com/ru/company/postgrespro/blog/463819/).

# Предикатные блокировки

Термин _предикатная блокировка_ появился давно, при первых попытках реализовать полную изоляцию на основе блокировок в ранних СУБД (уровень Serializable, хотя стандарта SQL в те времена еще не существовало). <mark class="hltr-yellow">Проблема, с которой тогда столкнулись, состояла в том, что даже блокировка всех прочитанных и измененных строк не дает полной изоляции: в таблице могут появиться _новые_ строки, попадающие под те же условия отбора, что приводит к появлению</mark> _<mark class="hltr-red">фантомов</mark>_ (см. [статью про изоляцию](https://habr.com/ru/company/postgrespro/blog/442804/)).  
  
<mark class="hltr-green2">Идея предикатных блокировок состояла в блокировке не строк, а предикатов</mark>. Если при выполнении запроса с условием _a_ > 10 заблокировать предикат _a_ > 10, это не даст добавить в таблицу новые строки, попадающие под условие и позволит избежать фантомов. Проблема в том, что в общем случае это вычислительно сложная задача; <mark class="hltr-yellow">на практике ее можно решить только для предикатов, имеющих очень простой вид.  </mark>
  
<mark class="hltr-green2">В PostgreSQL уровень Serializable реализован иначе, поверх существующей изоляции на основе снимков данных.</mark> Термин <mark class="hltr-red">_предикатная блокировка_</mark> остался, <mark class="hltr-purple">но смысл его в корне изменился. Фактически такие «блокировки» ничего не блокируют, а используются для отслеживания зависимостей по данным между транзакциями.  </mark>
  
Доказано, что изоляция на основе снимков допускает _аномалию несогласованной записи_ и _аномалию только читающей транзакции_, но никакие другие аномалии невозможны. Чтобы понять, что мы имеем дело с одной из двух перечисленных аномалией, мы можем анализировать зависимости между транзакциями и находить в них определенные закономерности.  
  
Нас интересуют зависимости двух видов:  

- одна транзакция читает строку, которая затем изменяется другой транзакцией (RW-зависимость),
- одна транзакция изменяет строку, которую затем читает другая транзакция (WR-зависимость).

  
<mark class="hltr-orange">WR-зависимости можно отследить, используя уже имеющиеся обычные блокировки, а вот RW-зависимости как раз приходится отслеживать дополнительно.  </mark>
  
Еще раз повторюсь: несмотря на название, п<mark class="hltr-yellow">редикатные блокировки ничего не блокируют. Вместо этого при фиксации транзакции выполняется проверка и, если обнаруживается «нехорошая» последовательность зависимостей, которая может свидетельствовать об аномалии, транзакция обрывается. </mark> 
  
Давайте посмотрим, как происходит установка предикатных блокировок. Для этого создадим таблицу с достаточно большим числом строк и индекс на ней.  
  

```sql
=> CREATE TABLE pred(n integer);
=> INSERT INTO pred(n) SELECT g.n FROM generate_series(1,10000) g(n);
=> CREATE INDEX ON pred(n) WITH (fillfactor = 10);
=> ANALYZE pred;
```

  
Если запрос выполняется с помощью последовательного сканирования всей таблицы, то предикатная блокировка устанавливается на всю таблицу (даже если под условия фильтрации попадают не все строки).  
  

```sql
|  => SELECT pg_backend_pid();
```

```sql
|   pg_backend_pid 
|  ----------------
|            12763
|  (1 row)
```

  

```sql
|  => BEGIN ISOLATION LEVEL SERIALIZABLE;
|  => EXPLAIN (analyze, costs off)
|    SELECT * FROM pred WHERE n > 100;
```

```sql
|                             QUERY PLAN                           
|  ----------------------------------------------------------------
|   Seq Scan on pred (actual time=0.047..12.709 rows=9900 loops=1)
|     Filter: (n > 100)
|     Rows Removed by Filter: 100
|   Planning Time: 0.190 ms
|   Execution Time: 15.244 ms
|  (5 rows)
```

  
Любые предикатные блокировки всегда захватываются в одном специальном режиме SIReadLock (Serializable Isolation Read):  
  

```sql
=> SELECT locktype, relation::regclass, page, tupleFROM pg_locks WHERE mode = 'SIReadLock' AND pid = 12763;
```

```sql
 locktype | relation | page | tuple 
----------+----------+------+-------
 relation | pred     |      |      
(1 row)
```

  

```sql
|  => ROLLBACK;
```

  
<mark class="hltr-yellow">А вот если запрос выполняется с помощью индексного сканирования, ситуация меняется в лучшую сторону. Если говорить о B-дереве, то достаточно установить блокировку на прочитанные табличные строки и на просмотренные листовые страницы индекса — тем самым мы блокируем не только конкретные значения, но и весь прочитанный диапазон.  </mark>
  

```sql
|  => BEGIN ISOLATION LEVEL SERIALIZABLE;
|  => EXPLAIN (analyze, costs off)
|    SELECT * FROM pred WHERE n BETWEEN 1000 AND 1001;
```

```sql
|                                       QUERY PLAN                                     
|  ------------------------------------------------------------------------------------
|   Index Only Scan using pred_n_idx on pred (actual time=0.122..0.131 rows=2 loops=1)
|     Index Cond: ((n >= 1000) AND (n <= 1001))
|     Heap Fetches: 2
|   Planning Time: 0.096 ms
|   Execution Time: 0.153 ms
|  (5 rows)
```

  

```sql
=> SELECT locktype, relation::regclass, page, tupleFROM pg_locks WHERE mode = 'SIReadLock' AND pid = 12763;
```

```sql
 locktype |  relation  | page | tuple 
----------+------------+------+-------
 tuple    | pred       |    3 |   236
 tuple    | pred       |    3 |   235
 page     | pred_n_idx |   22 |      
(3 rows)
```

  
#### Можно заметить несколько сложностей.  
  
Во-первых, <mark class="hltr-yellow">на каждую прочитанную версию строки создается отдельная блокировка, но потенциально таких версий может быть очень много. Общее число предикатных блокировок в системе ограничено произведением значений параметров</mark> _max_pred_locks_per_transaction_ × _max_connections_ (значения по умолчанию — 64 и 100 соответственно). <mark class="hltr-red">Память под такие блокировки отводится при запуске сервера; попытка превысить это число будет приводить к ошибкам.  </mark>
  
Поэтому для предикатных блокировок (и только для них!) используется _повышение уровня_. До версии PostgreSQL 10 действовали жестко зашитые в код ограничения, а начиная с нее повышением уровня можно управлять параметрами. Если число блокировок версий строк, относящихся к одной странице, превышает _max_pred_locks_per_page_, такие блокировки заменяются на одну блокировку уровня страницы. Вот пример:  
  

```sql
=> SHOW max_pred_locks_per_page;
```

```sql
 max_pred_locks_per_page 
-------------------------
 2
(1 row)
```

  

```sql
|  => EXPLAIN (analyze, costs off)
|    SELECT * FROM pred WHERE n BETWEEN 1000 AND 1002;
```

```sql
|                                       QUERY PLAN                                     
|  ------------------------------------------------------------------------------------
|   Index Only Scan using pred_n_idx on pred (actual time=0.019..0.039 rows=3 loops=1)
|     Index Cond: ((n >= 1000) AND (n <= 1002))
|     Heap Fetches: 3
|   Planning Time: 0.069 ms
|   Execution Time: 0.057 ms
|  (5 rows)
```

  
Вместо трех блокировок типа tuple видим одну типа page:  
  

```sql
=> SELECT locktype, relation::regclass, page, tupleFROM pg_locks WHERE mode = 'SIReadLock' AND pid = 12763;
```

```sql
 locktype |  relation  | page | tuple 
----------+------------+------+-------
 page     | pred       |    3 |      
 page     | pred_n_idx |   22 |      
(2 rows)
```

  
Аналогично, если число блокировок страниц, относящихся к одному отношению, превышает _max_pred_locks_per_relation_, такие блокировки заменяются на одну блокировку уровня отношения.  
  
Других уровней не бывает: предикатные блокировки захватываются только для отношений, страниц или версий строк, и всегда с режимом SIReadLock.  
  
Конечно, повышение уровня блокировок неизбежно приводит к тому, что большее число транзакций будет ложно завершаться ошибкой сериализации и в итоге пропускная способность системы будет снижаться. Здесь нужно искать баланс между расходом оперативной памяти и производительностью.  
  
Вторая сложность состоит в том, что при различных операциях с индексом (например, из-за расщепления индексных страниц при вставке новых строк) число листовых страниц, покрывающих прочитанный диапазон, может измениться. Но реализация это учитывает:  
  

```sql
=> INSERT INTO pred SELECT 1001 FROM generate_series(1,1000);
=> SELECT locktype, relation::regclass, page, tupleFROM pg_locks WHERE mode = 'SIReadLock' AND pid = 12763;
```

```sql
 locktype |  relation  | page | tuple 
----------+------------+------+-------
 page     | pred       |    3 |      
 page     | pred_n_idx |  211 |      
 page     | pred_n_idx |  212 |      
 page     | pred_n_idx |   22 |      
(4 rows)
```

  

```sql
|  => ROLLBACK;
```

  
К слову, предикатные блокировки не всегда снимаются сразу по завершению транзакции, ведь они нужны, чтобы отслеживать зависимости между _несколькими_ транзакциями. Но в любом случае управление ими происходит автоматически.  
  
Далеко не все типы индексов в PostgreSQL поддерживают предикатные блокировки. Раньше этим могли похвастать только B-деревья, но в версии PostgreSQL 11 ситуация улучшилась: к списку добавились хеш-индексы, GiST и GIN. Если используется индексный доступ, а индекс не работает с предикатными блокировками, то блокировка накладывается на весь индекс целиком. Конечно, это тоже увеличивает число ложных обрывов транзакций.  
  
<mark class="hltr-red">В заключение отмечу, что именно с использованием предикатных блокировок связано ограничение, что для гарантий полной изоляции _все_ транзакции должны работать на уровне Serializable. Если какая-либо транзакция будет использовать другой уровень, она просто не будет устанавливать (и проверять) предикатные блокировки.</mark>
