---
title: Группировка данных
tags:
  - PostgreSql
related_topics: 
created: 2024-09-24 16:18
modified: 2024-12-02T16:34:19+03:00
questions: 
notes: 
links: 
---

### Группировка данных

==GROUP BY и HAVING==

- `HAVING` - <mark class="hltr-yellow">доп условия на агрегирующие функции после</mark> `GROUP BY`

```SQL
SELECT department, AVG(salary) as avg_salary
FROM employees
GROUP BY department
HAVING AVG(salary) > 50000;
```

![[images/Untitled 19 3.png|Untitled 19 3.png]]


### Группировка данных (GROUP BY) и использование HAVING

**Группировка данных** — это важная часть SQL-запросов, которая<mark class="hltr-yellow"> используется для объединения строк, имеющих одинаковые значения в определённых столбцах.</mark> Это позволяет применять агрегатные функции (такие как `COUNT()`, `SUM()`, `AVG()`, `MAX()`, `MIN()` и другие) к каждой группе данных.

### Зачем нужна группировка данных?

1. **Анализ данных**: Группировка позволяет агрегировать данные по определённым критериям и выполнять расчёты для каждой группы. Это полезно для получения сводных отчетов, анализа данных, например:
    
    - Сколько заказов было сделано каждым клиентом?
    - Каков средний доход на каждом складе?
    - Какая максимальная цена по категориям товаров?
2. **Работа с агрегатными функциями**: Агрегатные функции работают с группами данных. Без группировки функции, такие как `SUM()` или `COUNT()`, применяются ко всей таблице. Если необходимо применять их к каждой подгруппе данных, используется `GROUP BY`.
    
3. **Оптимизация и упрощение запросов**: Группировка помогает сократить объем данных для анализа, что может повысить производительность запросов. Например, вместо возвращения всех транзакций за год, вы можете сгруппировать данные по месяцам и получить сводный результат.

### Пример использования `GROUP BY`

Предположим, у нас есть таблица `orders`, которая хранит информацию о заказах, и мы хотим узнать, сколько заказов сделал каждый клиент.

```sql
SELECT customer_id, COUNT(*) AS total_orders
FROM orders
GROUP BY customer_id;
```

Здесь:

- Мы используем агрегатную функцию `COUNT()` для подсчета количества заказов.
- Столбец `customer_id` используется в операторе `GROUP BY` для объединения строк по клиентам.

### Что произойдет, если **не сгруппировать данные**, но использовать агрегатные функции?

Если не использовать `GROUP BY`, но в запросе есть агрегатные функции, то эти функции будут применены ко всем строкам сразу. Например:

```sql
SELECT COUNT(*) FROM orders;
```
Этот запрос просто подсчитает общее количество строк в таблице `orders`. В данном случае нет группировки, поэтому агрегатная функция считает все записи в таблице.

Но если в запросе присутствуют как агрегатные функции, так и обычные столбцы без группировки, то это вызовет ошибку:
```sql
SELECT customer_id, COUNT(*) FROM orders;
```

<mark class="hltr-red">Ошибка возникает, потому что SQL не знает, как сопоставить столбец</mark> `customer_id` с <mark class="hltr-red">результатами агрегатной функции.</mark> Чтобы это работало корректно, нужно явно указать, как группировать данные — в данном случае по `customer_id`:
```sql
SELECT customer_id, COUNT(*)
FROM orders
GROUP BY customer_id;
```

### Использование `HAVING`

Оператор `HAVING` <mark class="hltr-yellow">используется для фильтрации данных</mark> **после применения группировки**. Это похоже на оператор `WHERE`, но `WHERE` применяется **до группировки**, а `HAVING` — **после**. `HAVING` <mark class="hltr-green2">используется для фильтрации результатов агрегатных функций.</mark>

Пример: Найдем клиентов, которые сделали больше 5 заказов:
```sql
SELECT customer_id, COUNT(*) AS total_orders
FROM orders
GROUP BY customer_id
HAVING COUNT(*) > 5;
```

Здесь:

- `GROUP BY` сначала группирует заказы по клиентам.
- `HAVING` фильтрует группы так, что в результате остаются только те клиенты, у которых количество заказов больше 5.
### Отличия между `WHERE` и `HAVING`:

- `WHERE` фильтрует строки **до** выполнения группировки, то есть до применения агрегатных функций.
- `HAVING` фильтрует строки **после** группировки и может использовать агрегатные функции для фильтрации.
#### Пример использования `WHERE` и `HAVING` вместе:
```sql
SELECT customer_id, COUNT(*) AS total_orders
FROM orders
WHERE order_date >= '2023-01-01'
GROUP BY customer_id
HAVING COUNT(*) > 5;
```
- `WHERE order_date >= '2023-01-01'` — сначала фильтрует строки, чтобы в группировку попали только заказы, сделанные после января 2023 года.
- `HAVING COUNT(*) > 5` — фильтрует группы так, что остаются только клиенты с более чем 5 заказами.

### Почему важно правильно использовать `GROUP BY`?

1. **Целостность данных**: Группировка гарантирует, что данные будут корректно агрегированы, и вы получите точные результаты анализа. Без группировки результаты агрегатных функций могут быть некорректными или вовсе не сработают.
    
2. **Уменьшение объема данных**: Вместо обработки каждой строки, группировка позволяет свести данные к определенным группам, что уменьшает объем вывода и упрощает анализ.
    
3. **Ошибки в запросах**: Если не указать `GROUP BY`, когда в запросе используются обычные столбцы вместе с агрегатными функциями, это приведет к ошибке.
    

### Лучшие практики:

- **Используйте группировку, когда нужны агрегатные данные**: Например, суммы, количество, средние значения для каждой подгруппы данных.
- **Фильтруйте с `HAVING`, если агрегатные функции участвуют в фильтрации**. Для обычной фильтрации используйте `WHERE`.
- **Группируйте только по тем столбцам, которые имеют смысл для анализа**. Избыточная группировка может усложнить запросы и ухудшить производительность.
- **Используйте индексацию**: Группировка может быть медленной при работе с большими наборами данных, поэтому индексирование столбцов, по которым производится группировка, может улучшить производительность запросов.

### Заключение:

Группировка данных с помощью `GROUP BY` позволяет эффективно анализировать данные, суммировать и агрегировать их по определённым критериям. Оператор `HAVING` помогает фильтровать агрегированные результаты, а правильное использование этих инструментов — ключ к эффективной работе с большими объемами данных и созданию точных отчетов.


![[Pasted image 20241202163420.png]]
![[Pasted image 20241202163429.png]]
