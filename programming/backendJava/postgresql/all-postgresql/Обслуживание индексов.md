---
title: Обслуживание индексов
tags:
  - PostgreSql
related_topics: 
created: 2024-12-03 13:49
modified: 2024-12-05T17:56:09+03:00
questions: 
notes: 
links: 
---


![[Pasted image 20241203140335.png]]

- <mark class="hltr-yellow">В Postgres может не быть первичного индекса. Может быть только пучек разнородных индексов.</mark>
- <mark class="hltr-green2">Каждый из них содержит адресацию к указанной странице, строчке.</mark>

![[Pasted image 20241203140503.png]]

- <mark class="hltr-red">На проде использовать Concurrently всегда, чтобы не блокировать никого.</mark>


![[Pasted image 20241203140600.png]]
- <mark class="hltr-red">Индексы расширяются и пухнут и предоставляют большой объем. Можно укатать его.   </mark>
 

Команда `REINDEX` в PostgreSQL используется для восстановления или полного пересоздания индексов в таблице. Это бывает полезно в ряде ситуаций, связанных с производительностью или консистентностью данных. Ниже описаны основные случаи, когда стоит использовать `REINDEX`.

---

### **1. Повреждение индекса**

- Индексы в PostgreSQL могут быть повреждены из-за сбоев системы, аппаратных ошибок или других непредвиденных обстоятельств.
- Если индекс больше не соответствует данным в таблице (например, из-за сбоя во время обновления), он может вернуть некорректные результаты.

### **2. Фрагментация индексов**

- При частых операциях обновления (`UPDATE`) или удаления (`DELETE`) в таблице индексы могут стать сильно фрагментированными.
- Фрагментация приводит к увеличению размера индекса и снижению производительности запросов.

**Решение:**

- `REINDEX` пересоздаёт индекс, убирая фрагментацию и уменьшая его физический размер.

### **3. Избыточное потребление места**

- Индексы могут разрастаться из-за частых модификаций данных.
- Если индекс стал занимать непропорционально много места относительно таблицы, это признак необходимости `REINDEX`.

### **4. Изменение коллатора или локали**

- Если изменяется локаль базы данных (например, для поддержки нового языкового порядка), все индексы на текстовых данных становятся некорректными, так как они зависят от коллатора.
- `REINDEX` нужен для приведения индексов в соответствие с новой локалью.

### **6. После восстановления базы данных из резервной копии**

- Если резервная копия восстановлена с потенциальными проблемами индексов, например, из-за некорректных транзакций или старого формата, индексы могут быть не полностью работоспособны.
- Рекомендуется пересоздать индексы для обеспечения их корректности.

### **7. Устаревший индекс**

- Если таблица сильно изменилась с момента создания индекса (например, данные были массово удалены), индекс может стать менее эффективным.
- `REINDEX` помогает восстановить эффективность индекса.

### **Как работает `REINDEX`?**

`REINDEX` фактически пересоздаёт индекс с нуля:

1. Удаляет старый индекс.
2. Создаёт новый с теми же параметрами.
3. Обновляет системные каталоги.



----------------------
# ВАЖНО !!!!!

- **Мониторьте состояние индексов:**
    - Используйте `pg_stat_user_indexes` и `pg_index` для анализа состояния индексов.
- **Рассмотрите `VACUUM FULL`:**
    - Если таблица и индексы сильно фрагментированы, `VACUUM FULL` может быть более подходящим решением.


------


### **Как работает очистка индексов в PostgreSQL?**

1. **Удаление строк и MVCC:**
    
    - PostgreSQL использует механизм _Multiversion Concurrency Control (MVCC)_, при котором удалённые строки или обновлённые версии строк фактически остаются в таблице, пока они не станут невидимыми для всех транзакций.
    - В индексе такие строки продолжают указываться до выполнения `VACUUM`.
2. **Очистка `VACUUM`:**
    
    - Команда `VACUUM` помечает "мёртвые" строки как доступные для перезаписи, а также удаляет ссылки на эти строки из индексов.
    - Например, если строка была удалена, то после `VACUUM` индексы перестанут указывать на неё.
3. **Очистка и фрагментация:**
    
    - Хотя `VACUUM` удаляет ссылки на мёртвые строки из индекса, он не упорядочивает и не уменьшает физический размер самого индекса.
    - Это значит, что индекс может становиться фрагментированным, занимать больше места на диске и снижать производительность.


### **Как понять, что `VACUUM` недостаточно?**

1. **Рост размера индекса:**
    
    - Если индекс занимает больше места на диске, чем сама таблица, это признак разрастания.
    - Можно проверить размер индекса с помощью

```sql
SELECT
    relname AS index_name,
    pg_size_pretty(pg_relation_size(indexrelid)) AS index_size
FROM pg_stat_user_indexes
JOIN pg_index ON pg_stat_user_indexes.indexrelid = pg_index.indexrelid
WHERE schemaname = 'public';

```

### **Когда `REINDEX` действительно нужен?**

1. **Сильная фрагментация:**
    
    - Если индекс разросся и стал разреженным, `REINDEX` полностью пересоздаёт индекс, устраняя разреженность и уменьшая его размер.
2. **Некорректность индекса:**
    
    - Если индекс повреждён (например, из-за аппаратных сбоев или багов).
3. **Смена локали или изменений в данных:**
    
    - Если изменён коллатор, сортировка или структура данных, индексы нужно пересоздать.

---

### **Что использовать: `VACUUM`, `ANALYZE`, `REINDEX`?**

|**Операция**|**Что делает?**|**Когда использовать?**|
|---|---|---|
|**VACUUM**|Удаляет мёртвые строки из таблицы и ссылок на них из индексов.|Регулярно, чтобы поддерживать актуальность данных и индексов.|
|**ANALYZE**|Обновляет статистику для планировщика запросов.|После значительных изменений данных в таблице.|
|**VACUUM FULL**|Уплотняет таблицу и пересоздаёт индексы.|При сильной фрагментации таблицы и индексов, если размер данных значительно вырос.|
|**REINDEX**|Полностью пересоздаёт индекс, удаляя фрагментацию и ошибки.|При сильной фрагментации или повреждении индекса.|


---


![[Pasted image 20241204173912.png]]



----

![[Pasted image 20241205175559.png]]