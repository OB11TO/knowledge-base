---
title: QTP-Сравнение эффективности
tags:
  - PostgreSql
related_topics: 
created: 2024-11-26 17:21
modified: 2025-04-15T14:38:11+03:00
questions: 
notes: 
links: 
---
   

![[Pasted image 20241126172252.png]]
![[Pasted image 20241126172411.png]]
Селективность в метрике от 0 до 1 определяется как отношение количества строк, возвращаемых запросом, к общему количеству строк в таблице:

Селективность=Количество выбранных строкОбщее количество строк в таблице\text{Селективность} = \frac{\text{Количество выбранных строк}}{\text{Общее количество строк в таблице}}Селективность=Общее количество строк в таблицеКоличество выбранных строк​

---

### **Высокая селективность**

- **Значение близко к 0.**
- Это означает, что запрос возвращает очень малую часть строк. Например:
    - В таблице 1 000 000 строк.
    - Запрос выбирает 1 строку.
    - Селективность: 11000000=0.000001\frac{1}{1 000 000} = 0.00000110000001​=0.000001.

**Пример:** `SELECT * FROM Users WHERE id = 12345;`

---

### **Низкая селективность**

- **Значение близко к 1.**
- Это означает, что запрос возвращает большую часть строк. Например:
    - В таблице 1 000 000 строк.
    - Запрос выбирает 900 000 строк.
    - Селективность: 9000001000000=0.9\frac{900 000}{1 000 000} = 0.91000000900000​=0.9.

**Пример:** `SELECT * FROM Users WHERE country = 'USA';` (если большинство пользователей из США).

---

### **Итог:**

- **Высокая селективность** → ближе к 0 (меньше строк возвращается).
- **Низкая селективность** → ближе к 1 (больше строк возвращается).

4o

##### Вы сказали:

а когда выполняется индекс, когда селективность стремится к 1 или к 0 ???

###### ChatGPT сказал:

ChatGPT

Индекс наиболее эффективно используется, когда **селективность стремится к 0** — то есть, когда запрос выбирает малую часть строк из таблицы. Это связано с тем, что:

1. **Индексы оптимизированы для поиска небольших подмножеств данных**:
    
    - Они устроены так, чтобы быстро находить и извлекать только нужные строки.
    - Если возвращается большинство строк (селективность близка к 1), использование индекса не дает преимущества, так как придется сканировать почти весь массив данных.
2. **Низкая селективность (ближе к 1)**:
    
    - В этом случае оптимизатор базы данных может решить, что использование индекса нецелесообразно.
    - Например, если запрос затрагивает 80–90% строк, будет быстрее выполнить **полное сканирование таблицы (Full Table Scan)**, чем переключаться между индексами и самой таблицей.

---

### **Пример:**

1. **Селективность ~ 0.01 (высокая селективность)**:
    
    sql
    
    Копировать код
    
    `SELECT * FROM Users WHERE id = 12345;`
    
    - Условие уникально (например, по первичному ключу).
    - Используется индекс, так как он позволяет быстро найти одну строку.
2. **Селективность ~ 0.9 (низкая селективность)**:
    
    sql
    
    Копировать код
    
    `SELECT * FROM Users WHERE country = 'USA';`
    
    - Если 90% пользователей из США, индекс бесполезен.
    - Оптимизатор базы данных предпочтёт полный скан таблицы.

---

### **Правило:**

- **Индекс используется при высокой селективности** (когда селективность ближе к 0).
- **Индекс не используется или малоэффективен при низкой селективности** (когда селективность ближе к 1).





![[Pasted image 20241126172439.png]]
![[Pasted image 20241126172517.png]]
![[Pasted image 20241126172542.png]]
![[Pasted image 20241126172652.png]]
![[Pasted image 20241126172709.png]]
