---
title: Использование индексов
tags:
  - PostgreSql
related_topics: 
created: 2024-12-05 15:31
modified: 2024-12-06T11:39:21+03:00
questions: 
notes: 
links: 
---


----

 Заметим, что обновление полей таблицы, по которым не создавались индексы, не приводит к перестроению индексов; этот механизм называется HOT (Heap-Only Tuples)

----
# Hash index 

Неприятной особенностью текущей реализации хеш-индекса является то, что действия с ним не попадают в журнал упреждающей записи (о чем нас и предупреждает PostgreSQL при создании индекса). Как следствие, хеш-индексы не могут быть восстановлены после сбоя и не участвуют в репликации. Кроме того, хеш-индекс значительно уступает B-дереву по универсальности применения, и его эффективность тоже вызывает вопросы. То есть сейчас применять такие индексы не имеет практического смысла.  
  
Впрочем, ситуация изменится уже этой осенью с выходом десятой версии PostgreSQL. В ней хеш-индекс снабдили наконец поддержкой журнала и дополнительно оптимизировали выделение памяти и эффективность одновременной работы.

Соответственно хеш-индекс не может выдавать упорядоченные данные (can_order, orderable). По той же причине хеш-индекс не работает с неопределенными значениями: операция «равно» не имеет смысла для null (search_nulls).

Amit Kapila не так давно [показал](http://amitkapila16.blogspot.ru/2017/03/hash-indexes-are-faster-than-btree.html), что хэш-индексы иногда могут быть быстрее B-деревьев. Следовательно, если вы ищите только по равенству, имеет смысл сравнить оба варианта и выбрать тот, который на ваших данных и объемах будет быстрее

----------------

# Btree index 
Стоит еще раз подчеркнуть, что при любом способе сканирования (индексном, исключительно индексном, по битовой карте) метод доступа btree возвращает упорядоченные данные, что хорошо видно на приведенных выше рисунках.
Поэтому, если на таблице имеется индекс по условию сортировки, оптимизатор будет учитывать обе возможности: обращение к таблице по индексу и автоматическое получение отсортированных данных, либо последовательное чтение таблицы и последующая сортировка результата.

При этом слева в дереве оказались бы большие значения, а справа — меньшие. Зачем это может понадобиться, если по индексированным значениям можно проходить как в одну сторону, так и в другую?
Причина в многоколоночных индексах. Давайте создадим представление, которое будет показывать модели самолетов и условное деление на ближне-, средне- и дальнемагистральные суда

Метод доступа btree индексирует неопределенные значения и поддерживает поиск по условиям is null и is not null.  
  
Возьмем таблицу рейсов, в которой встречаются неопределенные значения:  
  
`demo=# create index on flights(actual_arrival);   CREATE INDEX   demo=# explain(costs off) select * from flights where actual_arrival is null;                         QUERY PLAN                         -------------------------------------------------------    Bitmap Heap Scan on flights      Recheck Cond: (actual_arrival IS NULL)      ->  Bitmap Index Scan on flights_actual_arrival_idx            Index Cond: (actual_arrival IS NULL)   (4 rows)   `  
Неопределенные значения располагаются с одного или другого края листовых узлов в зависимости от того, как был создан индекс (nulls first или nulls last). Это важно, если в запросе участвует сортировка: порядок расположения неопределенных значений в индексе и в порядке сортировки должны совпадать, чтобы индекс можно было использовать.  
В этом примере порядки совпадают, поэтому индекс может использоваться:  
  
`demo=# explain(costs off) select * from flights order by actual_arrival **nulls last**;                          QUERY PLAN                         --------------------------------------------------------    Index Scan using flights_actual_arrival_idx on flights   (1 row)   `  
А здесь порядки отличаются, и оптимизатор выбирает сканирование таблицы и сортировку:  
  
`demo=# explain(costs off) select * from flights order by actual_arrival **nulls first**;                  QUERY PLAN                 ----------------------------------------    Sort      Sort Key: actual_arrival NULLS FIRST      ->  Seq Scan on flights   (3 rows)   `  
Чтобы индекс мог использоваться, надо создать его так, чтобы неопределенные значения шли в начале:  
  
`demo=# create index flights_nulls_first_idx on flights(actual_arrival **nulls first**);   CREATE INDEX   demo=# explain(costs off) select * from flights order by actual_arrival **nulls first**;                        QUERY PLAN                         -----------------------------------------------------    Index Scan using flights_nulls_first_idx on flights   (1 row)`


- А еще можно сделать так, чтобы праймери кей индекс пересодать и добавить  include поле

------


# # GiST
В чем же разница? Индекс b-tree жестко привязан к семантике сравнения: поддержка операторов «больше», «меньше», «равно» — это все, на что он способен (зато способен очень хорошо!). Но в современных базах хранятся и такие типы данных, для которых эти операторы просто не имеют смысла: геоданные, текстовые документы, картинки…  
  
Тут на помощь и приходит индексный метод GiST. Он позволяет задать принцип распределения данных произвольного типа по сбалансированному дереву, и метод использования этого представления для доступа по некоторому оператору. Например, в GiST-индекс можно «уложить» R-дерево для пространственных данных с поддержкой операторов взаимного расположения (находится слева, справа; содержит и т. п.), или RD-дерево для множеств с поддержкой операторов пересечения или вхождения.




-----

# GIN
Еще заметим, что, в отличие от обычного B-дерева, страницы индекса GIN связаны не двунаправленным, а однонаправленным списком. Этого достаточно, поскольку обход дерева выполняется всегда только в одну сторону.
### GiST или GIN?
  
Для многих типов данных существуют классы операторов и для GiST, и для GIN, что вызывает вопрос: чем же пользоваться? Пожалуй, уже можно сделать какие-то выводы.  
  
Как правило, GIN выигрывает в точности и скорости поиска у GiST. Если данные изменяются не часто, а искать надо быстро — скорее всего выбор падет на GIN.  
  
С другой стороны, если данные изменяются активно, накладные расходы на обновление GIN могут оказаться слишком велики. В этом случае придется сравнивать оба варианта и выбирать тот, чьи показатели будут лучше сбалансированы.