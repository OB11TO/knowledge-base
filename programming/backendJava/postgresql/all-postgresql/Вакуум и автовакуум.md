---
title: Вакуум и автовакуум
tags:
  - PostgreSql
related_topics: 
created: 2024-09-27 15:03
modified: 2024-10-09T17:25:02+03:00
questions: 
notes: 
links:
  - https://edu.postgrespro.ru/dba2/dba2_08_wal_buffercache.pdf
---

----
[[Очистка и ее горизонт]]
[[Автоваккум]]
[[sql скрипты для вакуума]]

----

В PostgreSQL команда **`VACUUM`** используется для очистки и реорганизации данных в базе, но она **не удаляет данные из буфера**. **`VACUUM`** работает с **хранением на диске**, удаляя "мертвые строки" и освобождая место для новых данных. Давайте рассмотрим это подробнее.

### Как работает `VACUUM` в PostgreSQL:

Когда данные в PostgreSQL обновляются или удаляются, они фактически **не удаляются сразу** — вместо этого создаются новые версии строк, а старые версии остаются на месте. Это связано с механизмом **MVCC** (многоверсионного управления параллелизмом), который PostgreSQL использует для обеспечения изоляции транзакций.

- **Мертвые строки**: Когда строки были изменены или удалены транзакцией, которая была завершена, они становятся "мертвыми" (то есть они больше не нужны, так как на них не ссылаются активные транзакции).
- Эти мертвые строки продолжают занимать место на диске, и для их удаления и освобождения пространства используется **`VACUUM`**.

### Что делает **`VACUUM`**:

1. **Удаление мертвых строк с диска**:
    
    - **`VACUUM`** освобождает пространство на диске, физически удаляя мертвые строки, которые больше не нужны.
    - Это помогает базе данных повторно использовать это пространство для новых данных, не увеличивая размер таблицы.
2. **Маркировка страниц**:
    
    - **`VACUUM`** помечает страницы (блоки) таблиц как доступные для повторного использования, если в них больше нет активных данных.
    - Однако **`VACUUM`** **не уменьшает размер файла таблицы на диске**, он просто делает пространство внутри файла доступным для повторного использования.

### Буферизация в PostgreSQL:

PostgreSQL использует **буферный пул** (в оперативной памяти) для кэширования данных и их блоков (страниц), чтобы ускорить доступ к ним. Когда блок данных читается с диска, он помещается в буфер, и дальнейшие операции с этим блоком могут происходить без необходимости повторного чтения с диска.

Однако **`VACUUM`** не очищает данные из буферного пула. Его задача — работать с физическим пространством на диске. Вот как это происходит:

- Когда **`VACUUM`** запускается, он сканирует страницы таблицы и очищает мертвые строки.
- **Если страница таблицы находится в буфере**, **`VACUUM`** может обновить её прямо в буфере, пометив мертвые строки как удаленные.
- Если страница не находится в буфере, она загружается с диска, обрабатывается и записывается обратно на диск после очистки.

### Заключение:

**`VACUUM`** в PostgreSQL **не удаляет данные из буфера**, так как его основная функция — это очистка и реорганизация данных **на диске**. Он физически удаляет мертвые строки и освобождает пространство для повторного использования, но не управляет кэшированными данными в буфере напрямую.

В PostgreSQL данные хранятся в виде **строк (tuples)** внутри таблиц, и каждая строка представляет собой запись с набором значений для каждого столбца таблицы. Давайте рассмотрим пример того, как конкретные строки хранятся в таблице на уровне базы данных.

### Пример таблицы:

Предположим, у нас есть таблица `users`, которая содержит информацию о пользователях:

`CREATE TABLE users (     id SERIAL PRIMARY KEY,     username VARCHAR(50),     email VARCHAR(100),     created_at TIMESTAMP );`

В эту таблицу добавлены несколько строк:

`INSERT INTO users (username, email, created_at) VALUES  ('john_doe', 'john@example.com', '2023-09-30 10:00:00'), ('jane_smith', 'jane@example.com', '2023-09-30 11:00:00'), ('mike_brown', 'mike@example.com', '2023-09-30 12:00:00');`

### Содержимое таблицы:

После вставки, таблица `users` будет содержать следующие строки:

|id|username|email|created_at|
|---|---|---|---|
|1|john_doe|john@example.com|2023-09-30 10:00:00|
|2|jane_smith|jane@example.com|2023-09-30 11:00:00|
|3|mike_brown|mike@example.com|2023-09-30 12:00:00|

### Как строки хранятся на уровне базы данных:

На уровне хранения в PostgreSQL каждая строка внутри таблицы хранится как **tuple** (кортеж), и каждое значение в этой строке сохраняется в соответствующих полях (столбцах) этой таблицы. В базе данных строки физически сохраняются в файлах на диске.

Когда вы вставляете данные в таблицу, PostgreSQL создаёт запись в физическом файле таблицы с соответствующим набором данных:

1. Для каждой строки создается отдельная запись в таблице с указанием ее **идентификатора строки** и значения всех полей (столбцов).
2. Каждая строка включает также служебную информацию, например, версию строки (для поддержки механизма **MVCC**) и флаги, которые сообщают, является ли строка "мертвой" или активной.

#### Что происходит при обновлении строки:

Допустим, мы обновляем пользователя с `id = 1`:

`UPDATE users SET email = 'new_john@example.com' WHERE id = 1;`

- PostgreSQL **не перезаписывает** существующую строку. Вместо этого оно создает **новую версию строки** с обновленными данными.
- Старая версия строки помечается как "мертвая" и остается в таблице до тех пор, пока **`VACUUM`** не удалит её.
- Новая версия строки будет содержать новое значение для поля `email`.

### Пример представления данных в базе данных (на уровне хранения):

Представьте, что таблица хранится как набор строк, каждая из которых содержит следующие данные:

- `id`: идентификатор строки (уникальный ключ).
- `username`: строка с именем пользователя.
- `email`: строка с email адресом.
- `created_at`: временная метка создания записи.

### Пример физического хранения:

Вот как может выглядеть строка на уровне физического хранения в PostgreSQL (пример для `id = 1`):

```yaml
Tuple (строка): ------------------------------------------- 
Transaction ID: 12345         (идентификатор транзакции, которая создала строку)
Item Pointer: [Block: 12, Offset: 3] (расположение строки в блоке данных) 
CTID: (12, 3)                (идентификатор строки для отслеживания версии) 
Data:     id: 1    username: 'john_doe'    email: 'john@example.com'    created_at: '2023-09-30 10:00:00
```
`

### Когда происходит обновление:

Допустим, email пользователя изменился. Теперь PostgreSQL создает новую версию строки:

yaml

Копировать код

`Tuple (новая версия строки после UPDATE): ------------------------------------------- Transaction ID: 12346         (идентификатор транзакции, которая обновила строку) Item Pointer: [Block: 15, Offset: 7] (новое расположение строки в блоке) CTID: (15, 7)                 (новый идентификатор строки) Data:     id: 1    username: 'john_doe'    email: 'new_john@example.com'    created_at: '2023-09-30 10:00:00' -------------------------------------------  Tuple (старая версия строки): ------------------------------------------- Transaction ID: 12345         (идентификатор транзакции, которая создала строку) Item Pointer: [Block: 12, Offset: 3] (старое расположение строки) CTID: (12, 3)                (старый идентификатор строки) Data:     id: 1    username: 'john_doe'    email: 'john@example.com'    created_at: '2023-09-30 10:00:00'    --> Помечена как "мертвая" и подлежит очистке. -------------------------------------------`

**Старая версия** строки останется в базе до тех пор, пока не будет выполнен `VACUUM`, который физически удалит её и освободит место для новых данных.

### Заключение:

В PostgreSQL строки в базе данных хранятся как кортежи (tuples) внутри страниц (блоков) таблицы на диске. Эти строки содержат не только данные из столбцов, но и дополнительную информацию о транзакциях, версиях строк и состоянии данных (активные или удаленные). Строки, которые больше не актуальны (например, после `UPDATE` или `DELETE`), остаются в таблице до тех пор, пока их не удалит `VACUUM`, освобождая пространство для повторного использования.


![[Pasted image 20240930173043.png]]
![[Pasted image 20240930173105.png]]
![[Pasted image 20240930173215.png]]

![[Pasted image 20240930173355.png]]


![[Pasted image 20240930173730.png]]
- <mark class="hltr-red">Первое ограничение</mark> - это <mark class="hltr-yellow">невозможность запустить</mark> <mark class="hltr-green2">vacuum full</mark> в <mark class="hltr-purple">транзакции</mark> 
![[Pasted image 20240930173835.png]]

 - <mark class="hltr-red">Второе ограничение </mark>- это запуск <mark class="hltr-green2">vacuum full</mark> <mark class="hltr-yellow">вне транзакции начнется, когда мы закончим транзакции и снимем блокировки, до тех пор вакуум будет ждат</mark>ь
<mark class="hltr-blue"> вот хороший результат </mark>
 ![[Pasted image 20240930174113.png]]


- Обычный <mark class="hltr-yellow">vacuum vervose</mark> <mark class="hltr-green2">будет работать, даже пока транзакция не завершилась </mark>
![[Pasted image 20240930174252.png]]
![[Pasted image 20241009171336.png]]
![[Pasted image 20241009171430.png]]![[Pasted image 20241009172003.png]]
![[Pasted image 20241009172047.png]]






























