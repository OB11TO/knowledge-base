---
title: QTP-Индексы с дополнительными столбцами
tags:
  - PostgreSql
related_topics: 
created: 2024-11-25 17:10
modified: 2024-11-25T17:21:16+03:00
questions: 
notes: 
links: 
---


![[Pasted image 20241125171134.png]]
![[Pasted image 20241125171421.png]]
![[Pasted image 20241125171826.png]]
### Когда использовать INCLUDE индексы?

1. Когда запросы часто возвращают дополнительные столбцы, не участвующие в условиях поиска.
2. Для оптимизации **SELECT** запросов, которые читают одни и те же данные.
3. Когда хочется избежать обратных обращений к таблице.


Использование **INCLUDE индексов** дает много преимуществ, но они не лишены потенциальных проблем. Давай разберем основные трудности, которые могут возникнуть, и как их решать.

---

### 1. **Увеличение размера индекса**

- **Проблема:** Каждый INCLUDE индекс требует места на диске. Чем больше столбцов добавляется, тем больше размер индекса. Это может замедлить операции вставки, обновления и удаления, так как индексы нужно обновлять при каждой модификации данных.
- **Решение:**
    - Включайте в индекс только те столбцы, которые часто используются в запросах.
    - Не добавляйте большие столбцы (например, `TEXT` или `BLOB`) в INCLUDE, если это не критично.
    - Регулярно проверяйте и удаляйте неиспользуемые или избыточные индексы.

---

### 2. **Дублирование данных**

- **Проблема:** Если столбцы в INCLUDE индексе также хранятся в других индексах или в основной таблице, это приводит к дублированию данных, увеличению дискового пространства и снижению производительности.
- **Решение:**
    - Анализируйте существующие индексы перед созданием нового. Возможно, уже есть индекс, который можно использовать для оптимизации.
    - Объединяйте индексы, если это возможно.

---

### 3. **Сложность поддержки индексов**

- **Проблема:** Чем больше индексов у таблицы, тем сложнее управлять их актуальностью. Это может приводить к увеличению времени выполнения операций `INSERT`, `UPDATE` и `DELETE`, так как индексы обновляются вместе с таблицей.
- **Решение:**
    - Используйте инструменты мониторинга, чтобы выявить неиспользуемые индексы (например, в PostgreSQL — `pg_stat_user_indexes`).
    - Регулярно пересматривайте структуру индексов, чтобы удалять или изменять те, которые больше не используются.

---

### 4. **Замедление транзакций**

- **Проблема:** Если в индекс добавлены столбцы, которые часто обновляются, каждая транзакция будет дольше выполняться из-за необходимости обновления индекса. Это особенно заметно при больших объемах данных.
- **Решение:**
    - Не добавляйте часто изменяемые столбцы в INCLUDE индекс.
    - Используйте стратегии оптимизации транзакций, такие как **batching** (групповая обработка изменений).

---

### 5. **Сложности с анализом запросов**

- **Проблема:** Если запросы сильно различаются, то INCLUDE индекс может подходить только для одного типа запроса, но быть бесполезным для других. В итоге планировщик запросов (query planner) может выбрать неэффективный индекс.
- **Решение:**
    - Анализируйте запросы с помощью инструментов оптимизации, например, `EXPLAIN` или `EXPLAIN ANALYZE`, чтобы понимать, какой индекс используется.
    - Избегайте создания слишком специфичных индексов, если запросы часто меняются.

---

### 6. **Деградация производительности при большом числе индексов**

- **Проблема:** Если таблица содержит слишком много индексов, база данных может начать тратить больше времени на выбор подходящего индекса. Это может замедлить выполнение запросов.
- **Решение:**
    - Проводите аудит индексов. Если индекс редко используется, удалите его.
    - Создавайте комбинированные индексы, которые покрывают сразу несколько столбцов, вместо множества узконаправленных.

---

### 7. **Обновление структуры данных**

- **Проблема:** Если структура таблицы меняется (например, добавляются или удаляются столбцы), INCLUDE индекс может стать неактуальным. Это может вызвать ошибки или лишнюю работу при реиндексации.
- **Решение:**
    - Планируйте изменения структуры таблицы с учетом существующих индексов.
    - После изменения таблицы обновляйте индексы с помощью `REINDEX` или пересоздавайте их.

---

### 8. **Простои при создании или обновлении индексов**

- **Проблема:** При создании больших индексов (особенно INCLUDE) база данных может временно блокировать таблицу, что снижает доступность.
- **Решение:**
    - Используйте **CONCURRENTLY** в PostgreSQL для создания индексов без блокировки таблицы:
        
        sql
        
        Копировать код
        
        `CREATE INDEX CONCURRENTLY idx_name_include ON table_name (column1) INCLUDE (column2);`
        
    - Проводите операции создания или изменения индексов в нерабочее время.

---

### 9. **Проблемы с выбором покрытия запросов**

- **Проблема:** INCLUDE индексы часто используются для покрытия запросов, чтобы не обращаться к таблице. Однако, если запрос запрашивает столбцы, которые не включены в индекс, эффективность падает.
- **Решение:**
    - Анализируйте, какие именно столбцы чаще всего используются в запросах, и включайте их в индекс.
    - Добавляйте только те столбцы, которые действительно нужны для покрытия запросов.

---

### Итог:

**INCLUDE индексы** ускоряют запросы, но требуют грамотного подхода к проектированию. Чтобы минимизировать проблемы:

1. Добавляйте только те столбцы, которые реально используются.
2. Регулярно проверяйте и удаляйте неэффективные индексы.
3. Используйте инструменты мониторинга производительности.
4. Избегайте добавления часто обновляемых или слишком больших столбцов.

Правильная настройка индексов и мониторинг запросов помогут избежать большинства проблем и сделать работу базы данных быстрой и стабильной.


![[Pasted image 20241125172046.png]]
<mark class="hltr-yellow">Теперь оптимизатор выбирает метод Index Only Scan и использует только что созданный индекс. Количество прочитанных страниц сократилось. Поскольку карта видимости актуальна, обращаться к таблице не пришлось (Heap Fetches: 0).

В include-индекс можно включать столбцы с типами данных, которые не поддерживаются B-деревом (например, геометрические типы и xml).</mark>

