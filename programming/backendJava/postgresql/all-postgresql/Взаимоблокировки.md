---
title: Взаимоблокировки
tags:
  - PostgreSql
related_topics: 
created: 2024-11-19 17:03
modified: 2024-11-19T17:03:22+03:00
questions: 
notes: 
links: 
---




# Взаимоблокировки

  
<mark class="hltr-yellow">При использовании блокировок возможна ситуация</mark> _взаимоблокировки_ (или _тупика_). Она возникает, <mark class="hltr-green2">когда одна транзакция пытается захватить ресурс, уже захваченные другой транзакцией, в то время как другая транзакция пытается захватить ресурс, захваченный первой.</mark> Это проиллюстрировано на левом рисунке ниже: сплошные стрелки показывают захваченные ресурсы, пунктирные — попытки захватить уже занятый ресурс.  
  
Визуально взаимоблокировку удобно представлять, построив граф ожиданий. Для этого мы убираем конкретные ресурсы и оставляем только транзакции, отмечая, какая транзакция какую ожидает. Если в графе есть контур (из вершины можно по стрелкам добраться до нее же самой) — это взаимоблокировка.

![[Pasted image 20241119163839.png]]

Конечно, взаимоблокировка возможна не только для двух транзакций, но и для любого большего числа.  
  
Если взаимоблокировка возникла, участвующие в ней транзакции не могут ничего с этим сделать — они будут ждать бесконечно. Поэтому все СУБД, и <mark class="hltr-yellow">PostgreSQL тоже, автоматически отслеживают взаимоблокировки.  </mark>
  
Однако <mark class="hltr-yellow">проверка требует определенных усилий, которые не хочется прилагать всякий раз, когда запрашивается новая блокировка</mark> (все-таки взаимоблокировки достаточно редки). Поэтому <mark class="hltr-green2">когда процесс пытается захватить блокировку и не может, он встает в очередь и засыпает, но взводит таймер на значение, указанное в параметре</mark> <mark class="hltr-red">_deadlock_timeout_</mark> (по умолчанию — 1 секунда). <mark class="hltr-yellow">Если ресурс освобождается раньше, то и хорошо, мы сэкономили на проверке. А вот если по истечении _deadlock_timeout_ ожидание продолжается, тогда ожидающий процесс будет разбужен и инициирует проверку.  </mark>
  
Если<mark class="hltr-green2"> проверка (которая состоит в построении графа ожиданий и поиска</mark> в нем контуров) <mark class="hltr-yellow">не выявила взаимоблокировок</mark>, то <mark class="hltr-yellow">процесс продолжает спать — теперь уже до победного конца.  </mark>
  

> Ранее в комментариях меня справедливо упрекнули в том, что я ничего не сказал про параметр _lock_timeout_, который действует на любой оператор и позволяет избежать неопределенно долгого ожидания: если блокировку не удалось получить за указанное время, оператор завершается с ошибкой lock_not_available. Его не стоит путать с параметром _statement_timeout_, который ограничивает общее время выполнения оператора, неважно, ожидает ли он блокировку или просто выполняет работу.  

  
Е<mark class="hltr-green2">сли же взаимоблокировка выявлена, то одна из транзакций (в большинстве случаев — та, которая инициировала проверку) принудительно обрывается. При этом освобождаются захваченные ей блокировки и остальные транзакции могут продолжать работу.  </mark>

Через секунду первая транзакция, не получив доступ к ресурсу, инициирует проверку взаимоблокировки и обрывается сервером.  
  

```
ERROR:  deadlock detected
DETAIL:  Process 16477 waits for ShareLock on transaction 530695; blocked by process 16513.
Process 16513 waits for ShareLock on transaction 530694; blocked by process 16477.
HINT:  See server log for query details.
CONTEXT:  while updating tuple (0,2) in relation "accounts"
```

  
Теперь вторая транзакция может продолжить работу.


Взаимоблокировки обычно означают, что приложение спроектировано неправильно. Обнаружить такие ситуации можно двумя способами: во-первых, будут появляться сообщения в журнале сервера, и во-вторых, будет увеличиваться значение pg_stat_database.deadlocks.


# Взаимоблокировка двух команд UPDATE

  
Иногда можно получить взаимоблокировку там, где, казалось бы, ее быть никак не должно. Например, удобно и привычно воспринимать команды SQL как атомарные, но возьмем UPDATE — эта <mark class="hltr-red">команда блокирует строки по мере их обновления. Это происходит не одномоментно. Поэтому если одна команда будет обновлять строки в одном порядке, а другая — в другом, они могут взаимозаблокироваться.
</mark>

![[Pasted image 20241119165943.png]]
![[Pasted image 20241119165956.png]]
![[Pasted image 20241119170010.png]]
![[Pasted image 20241119170020.png]]
![[Pasted image 20241119170032.png]]
![[Pasted image 20241119170043.png]]
