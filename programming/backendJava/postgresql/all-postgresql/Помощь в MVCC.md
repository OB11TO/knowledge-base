---
title: Помощь в MVCC
tags:
  - PostgreSql
related_topics: 
created: 2024-09-26 18:21
modified: 2024-09-26T18:25:33+03:00
questions: 
notes: 
links: 
---

#### А как MVCC помогает на уровни READ COMMITED ?? она же не делает снимок экрана ?

Ты прав: **MVCC (Multiversion Concurrency Control)** на уровне **READ COMMITTED** д<mark class="hltr-purple">ействительно не создает "снимок" базы данных на момент начала транзакции, как это происходит на уровне</mark> **REPEATABLE READ** или **SERIALIZABLE**. Но давай разберемся, как именно работает **MVCC** и почему на уровне **READ COMMITTED** транзакции видят только зафиксированные данные, и <mark class="hltr-yellow">как это достигается без создания полного снимка.</mark>

### Как работает MVCC на уровне **READ COMMITTED**

#### Основные принципы MVCC:

1. **Версии строк (tuples)**:
    
    - PostgreSQL<mark class="hltr-green2"> использует многоверсионную архитектуру, при которой каждая операция изменения данных (вставка, обновление, удаление) не перезаписывает существующую строку, а создает новую версию строки.</mark>
    - В каждой строке хранятся два служебных поля:
        - **xmin** — идентификатор транзакции, которая создала эту версию строки.
        - **xmax** — идентификатор транзакции, которая удалила или изменила эту версию строки (если строка все еще "жива", **xmax** будет пустым).
2. **Механизм видимости строк**:
    
    - <mark class="hltr-yellow">Когда транзакция начинает читать данные, она проверяет метаинформацию о каждой строке</mark>:
        - Если идентификатор транзакции, создавшей строку (**xmin**), меньше текущей транзакции, и **xmax** пустой (строка не была удалена или изменена), строка считается видимой для текущей транзакции.
        - <mark class="hltr-red">Если строка была изменена незавершенной транзакцией, то она невидима для других транзакций.</mark>

#### Особенности уровня **READ COMMITTED**:

1. **Изоляция на уровне команд (statement-level isolation)**:
    
    - На уровне **READ COMMITTED** каждая команда (`SELECT`, `UPDATE`, `DELETE`) видит данные, которые были зафиксированы (committed) до начала выполнения этой конкретной команды.
    - Это означает, что между отдельными запросами внутри одной транзакции данные могут измениться, если другие транзакции зафиксируют изменения.
2. **Пример поведения на уровне READ COMMITTED**:
    
    - Предположим, транзакция T1 читает данные из таблицы (например, `SELECT * FROM employees`).
    - В это время другая транзакция T2 обновляет одну из строк таблицы и фиксирует изменения (COMMIT).
    - Если T1 повторит тот же запрос после фиксации изменений в T2, она увидит уже обновленные данные.

Таким образом, **MVCC** позволяет **READ COMMITTED** <mark class="hltr-yellow">изолировать команды так, чтобы каждая команда видела данные, которые были зафиксированы до её начала, не создавая "снимка" всей базы данных на уровне транзакции. </mark>Это дает больше гибкости по сравнению с уровнями изоляции, где создается "снимок", как в **REPEATABLE READ** и **SERIALIZABLE**.

### Почему уровень **READ COMMITTED** работает без снимков?

- **READ COMMITTED** <mark class="hltr-green2">не требует снимков всей базы данных, так как он решает задачу видимости на уровне отдельных строк (tuples). </mark>Вместо создания глобального снимка, как в более строгих уровнях изоляции, каждая команда видит зафиксированные на момент её начала данные.
    
- <mark class="hltr-yellow">Это позволяет транзакции динамически получать актуальные данные на момент выполнения каждой отдельной операции, что обеспечивает более высокую производительность в многопользовательских системах, при этом устраняя проблему грязных чтений.</mark>
    

### Пример поведения MVCC на уровне **READ COMMITTED**:

Предположим, у нас есть таблица `employees`, и мы выполняем следующие транзакции:

1. Транзакция **T1**:
```sql
BEGIN;
SELECT * FROM employees WHERE id = 1; -- Читает данные {id=1, name='John', salary=5000}

```

2. Параллельно транзакция **T2**:
```sql
BEGIN;
UPDATE employees SET salary = 6000 WHERE id = 1;
COMMIT; -- T2 зафиксировала изменения

```

3. Транзакция **T1** повторяет запрос:
```sql
SELECT * FROM employees WHERE id = 1; -- Теперь она видит {id=1, name='John', salary=6000}

```

На уровне **READ COMMITTED**, транзакция **T1** увидит новые данные, зафиксированные **T2**, при выполнении второго запроса. **MVCC** здесь работает на уровне отдельных команд, и каждая команда в транзакции **T1** видит только данные, зафиксированные к моменту её выполнения.

### Как **MVCC** решает проблему грязных чтений:

На уровне **READ COMMITTED** транзакции не могут видеть незавершенные изменения, поскольку:

- Строки, измененные незавершенной транзакцией, имеют свойство **xmax**, и пока транзакция не завершена, эти строки невидимы для других транзакций.
- Только когда транзакция, сделавшая изменения, завершится (COMMIT), её изменения станут видимыми для других транзакций.

### Итог:

- На уровне **READ COMMITTED**, **MVCC** управляет видимостью данных на уровне каждой команды, а не транзакции. Это позволяет каждой команде работать с актуальными данными, зафиксированными на момент начала выполнения этой команды.
- **MVCC** предотвращает грязные чтения и обеспечивает согласованность данных, но допускает такие аномалии, как **неповторяемые чтения** и **фантомные чтения**, которые можно устранить только на более высоких уровнях изоляции, таких как **REPEATABLE READ** и **SERIALIZABLE**.

Таким образом, **MVCC** в PostgreSQL на уровне **READ COMMITTED** предлагает баланс между производительностью и изоляцией, решая проблему видимости незавершенных транзакций без необходимости создания снимков всей базы данных.