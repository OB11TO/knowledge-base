---
title: Что будет если транзакция откатилась в WAL есть запись
tags:
  - PostgreSql
related_topics: 
created: 2024-09-26 17:39
modified: 2024-09-27T12:28:38+03:00
questions: 
notes: 
links: 
---

Если изменения данных успешно записались в **WAL** (журнал транзакций) с помощью **WAL Writer**, но затем произошел сбой, и транзакция откатилась, важно понимать, как PostgreSQL справляется с такой ситуацией.

### Что происходит при сбое после записи в WAL:

1. **WAL обеспечивает возможность восстановления**:
    
    - Основная задача **WAL** — гарантировать возможность восстановления данных после сбоя. Когда транзакция записана в WAL, это означает, что база данных зафиксировала изменения на уровне журналирования. Даже если фактические данные в таблицах не были записаны на диск (из `shared buffers`), PostgreSQL сможет восстановить их на основе WAL.
2. **Откат транзакции (rollback)**:
    
    - Если транзакция откатывается после того, как данные были записаны в WAL (например, из-за сбоя, ошибки в бизнес-логике или явного запроса на откат), PostgreSQL не использует эти изменения для обновления данных на диске.
    - <mark class="hltr-red">WAL записи будут помечены как неактуальные. Это не означает, что они удаляются немедленно, но они будут проигнорированы при восстановлении базы данных после сбоя.</mark>
3. **Сбой системы после записи в WAL**:
    
    - В случае системного сбоя после того, как изменения были записаны в **WAL**, но транзакция еще не была зафиксирована (`COMMIT`), при перезапуске PostgreSQL произведет **восстановление (recovery)** на основе WAL журнала. Однако поскольку транзакция не была зафиксирована, PostgreSQL распознает её как **незавершенную** и **откатит изменения**.
    - Это означает, что данные из незавершенной транзакции не будут применены к основной таблице при восстановлении.
4. **Процесс восстановления (recovery)**:
    
    - Когда PostgreSQL перезапускается после сбоя, он использует WAL для восстановления состояния базы данных. В ходе восстановления транзакции, которые были зафиксированы (`COMMIT`), будут повторно применены к данным. Транзакции, которые не были зафиксированы (в том числе те, которые были частично записаны в WAL), будут **откатаны**. Это обеспечивается механизмом **redo/undo**, встроенным в WAL.
    - Если система перезапускается, PostgreSQL проигрывает все изменения из WAL файла до последней зафиксированной точки и игнорирует незафиксированные изменения.

### Итак, если произошел сбой и транзакция не завершилась успешно:

- **Изменения, которые были записаны в WAL, но транзакция не была зафиксирована, будут отменены** при восстановлении системы.
- **WAL гарантирует**, что незавершенные транзакции (даже если они были записаны в журнал) не повлияют на данные базы данных.
- После сбоя **PostgreSQL откатит незавершенные транзакции** и применит только те, которые были зафиксированы.

### Пример:

Предположим, произошел сбой после того, как WAL Writer записал изменения в журнал, но транзакция не была зафиксирована:

- В процессе восстановления PostgreSQL проигрывает все транзакции, которые были записаны в WAL.
- Когда PostgreSQL сталкивается с незавершенной транзакцией (нет записи о `COMMIT` в WAL), он откатывает все изменения, связанные с этой транзакцией.

### Ключевая идея:

- **Запись в WAL не означает завершение транзакции**. Запись в WAL лишь фиксирует факт, что база данных может восстановить транзакцию, если она была зафиксирована. В случае сбоя транзакция откатится, если она не завершилась командой `COMMIT`.

Это поведение гарантирует, что база данных остается в согласованном состоянии, даже в случае сбоя, и изменения, внесенные незавершенными транзакциями, не будут применены.