---
title: Оптимизация запросов
tags:
  - PostgreSql
related_topics: 
created: 2024-12-02 13:13
modified: 2024-12-02T18:08:38+03:00
questions: 
notes: 
links: 
---

------
[[Анализ запросов в Postgres Лекция из Тензор]]




-----




![[Pasted image 20241202131404.png]]
![[Pasted image 20241202132716.png]]
![[Pasted image 20241202132807.png]]
  ![[Pasted image 20241202133003.png]]
  
  ![[Pasted image 20241202133126.png]]
![[Pasted image 20241202133208.png]]
![[Pasted image 20241202133327.png]]
 
   ![[Pasted image 20241202133436.png]]
 ![[Pasted image 20241202133642.png]]
 ![[Pasted image 20241202133653.png]]

![[Pasted image 20241202134331.png]]


![[Pasted image 20241202134618.png]]

![[Pasted image 20241202134700.png]]


 

![[Pasted image 20241202155321.png]]



В PostgreSQL при выполнении команды `EXPLAIN (ANALYZE)` параметр **`loops`** показывает, сколько раз соответствующая операция была выполнена за время выполнения запроса. Это важно для понимания того, как оптимизатор PostgreSQL обрабатывает запрос, особенно при работе с вложенными циклами и итеративными операциями.

---

### **Когда возникают `loops`?**

1. **Одиночное выполнение (loops = 1):**
    
    - Если операция была выполнена только один раз, это означает, что данные были обработаны в одном общем проходе.
    - Это типично для последовательного сканирования таблиц или соединений без вложенных циклов.
2. **Множественное выполнение (loops > 1):**
    
    - Когда операция повторяется несколько раз, например:
        - При использовании вложенных циклов (`Nested Loop`).
        - В случае повторного выполнения операций для каждой строки или подмножества данных.
    - Каждое выполнение одного цикла считается отдельным **loop**.

---

### **Пример 1: Простое последовательное сканирование**

sql

Копировать код

`EXPLAIN (ANALYZE, COSTS OFF) SELECT * FROM employees;`

**Результат:**

csharp

Копировать код

`Seq Scan on employees (actual rows=1000 loops=1)`

- `loops=1` означает, что последовательное сканирование таблицы `employees` выполнено **один раз** для получения всех строк.

---

### **Пример 2: Nested Loop (вложенный цикл)**

sql

Копировать код

`EXPLAIN (ANALYZE, COSTS OFF) SELECT e.name, d.name FROM employees e JOIN departments d ON e.department_id = d.id;`

**Результат:**

sql

Копировать код

`Nested Loop (actual rows=10000 loops=1)   -> Seq Scan on employees e (actual rows=1000 loops=1)   -> Index Scan using departments_pkey on departments d (actual rows=10 loops=1000)`

- **`Nested Loop`** выполняется **1 раз**, чтобы соединить таблицы.
- Вложенный **`Index Scan`** выполняется **1000 раз**, так как для каждой строки из `employees` ищется соответствующая строка в `departments`.

---

### **Пример 3: С рекурсивным запросом**

sql

Копировать код

`WITH RECURSIVE subordinates AS (     SELECT employee_id, manager_id     FROM employees     WHERE manager_id IS NULL     UNION ALL     SELECT e.employee_id, e.manager_id     FROM employees e     JOIN subordinates s ON e.manager_id = s.employee_id ) SELECT * FROM subordinates;`

**Результат:**

sql

Копировать код

`CTE Scan on subordinates (actual rows=1000 loops=1)   -> Recursive Union (actual rows=1000 loops=1)      -> Seq Scan on employees (actual rows=10 loops=1)      -> Nested Loop (actual rows=990 loops=10)         -> Index Scan on employees (actual rows=99 loops=10)`

- `Seq Scan` на начальном уровне выполняется **1 раз**.
- Внутренний `Nested Loop` и `Index Scan` выполняются **10 раз**, так как рекурсия повторяется для каждого уровня вложенности.

---

### **Почему важен параметр `loops`?**

1. **Диагностика производительности:**
    - Высокое значение `loops` может указывать на неэффективность запроса:
        - Например, если цикл выполняется для каждой строки при большом объёме данных, это может вызвать значительное увеличение времени выполнения.
2. **Оптимизация запросов:**
    - Если `loops` слишком велико, стоит рассмотреть:
        - Оптимизацию индексов.
        - Переписывание запроса (например, вместо вложенных циклов использовать хэш-соединения).
        - Ограничение объема данных, передаваемых в подзапросы.
3. **Индикатор избыточных операций:**
    - Если `loops` слишком велико, это может означать, что PostgreSQL выполняет больше операций, чем требуется.

---

### **Рекомендации для анализа `loops`:**

1. **Ожидаемое значение `loops`:**
    - Для последовательных операций (например, сканирование таблицы или соединения) `loops` обычно равно 1.
    - Для вложенных циклов или рекурсивных операций значение `loops` может быть больше, и это нормально для сложных запросов.
2. **Высокое значение `loops`:**
    - Обратите внимание на использование индексов: может быть, PostgreSQL использует неправильный план.
    - Проверьте, нет ли неэффективных соединений (например, `Nested Loop` с большими таблицами вместо `Hash Join`).
3. **Используйте лимиты:**
    - Для проверки запросов с большим числом циклов используйте `LIMIT`, чтобы ограничить объем данных и ускорить диагностику.

Понимание значения `loops` помогает лучше анализировать планы выполнения и оптимизировать сложные запросы в PostgreSQL.