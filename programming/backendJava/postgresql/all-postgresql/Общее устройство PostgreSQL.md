---
title: Общее устройство PostgreSQL
tags:
  - PostgreSql
related_topics: 
created: 2024-09-26 12:48
modified: 2025-04-09T13:38:57+03:00
questions: 
notes: 
links: 
---
 
---
[[Как данные обрабатываются в PostgreSQL]]
[[Что происходит внутри сессии]]
[[Что будет если транзакция откатилась в WAL есть запись]]
[[Shared_buffer  vs Work_mem]]

----



- Архитектура Postgres немного отличается от других СУБД <mark class="hltr-cyan">(чем ??? пока хз)</mark>
- <mark class="hltr-yellow"> Сначала запускается один процесс</mark> (<mark class="hltr-red">server</mark>) <mark class="hltr-yellow">далее происходит</mark> <mark class="hltr-red">fork</mark>() - <mark class="hltr-green2">создание других процессов</mark>
- То есть <mark class="hltr-yellow">один процесс порождает другие процессы у которых своя роль</mark>


![[Pasted image 20240926130222.png]]

- <mark class="hltr-red">Далее порождается SHARED MEMORY</mark> и через него идет общение с базой данных. 
- <mark class="hltr-purple">Все процессы общаются через SHARED MEMORY</mark>

![[Pasted image 20240926130532.png]]

![[Pasted image 20240926134708.png]]

![[Pasted image 20240926134951.png]]

![[Pasted image 20240926135041.png]]


![[Pasted image 20240926135214.png]]

- <mark class="hltr-red">НУЖНО СЛЕДИТЬ ЗА КОНФИГУРАЦИЕЙ </mark>
![[Pasted image 20240926135339.png]]




------

Компоненты памяти в **PostgreSQL** можно разделить в основном на две категории: область памяти 
 **1). Общая память**  (<mark class="hltr-yellow">shared memory</mark>)
 **2). Память процесса или серверная память** (<mark class="hltr-blue">per backend memory</mark>)
 ![[Pasted image 20240926131009.png]]
 
----

#### Общая память
<mark class="hltr-yellow"> Общая память относится к памяти, зарезервированной для кэширования базы данных и журналов транзакций</mark>. Эта область **используется всеми процессами** сервера PostgreSQL. Когда <mark class="hltr-green2">сервер запускается, он занимает часть оперативной памяти. В зависимости от различных параметров, таких как</mark> **shared_buffers,** **wal_buffers и т.д.**

##### **Разделяемую память можно дополнительно классифицировать** **следующим образом:**

**Общий буфер:** <mark class="hltr-yellow">Задает объем памяти, который сервер базы данных использует для буферов общей памяти</mark>. Назначение общего буфера - <mark class="hltr-red">**минимизировать операции ввода-вывода с ДИСКА**</mark>. <mark class="hltr-blue">Доступ к общим буферам осуществляется всеми фоновыми серверами и пользовательскими процессами, подключающимися к базе данных</mark>. <mark class="hltr-yellow">Данные, которые записываются или изменяются в этом месте, называются</mark> “<mark class="hltr-red">грязными данными</mark>", а единицей обработки являются блоки базы данных (или страницы), измененные блоки также называются “грязными блоками" или “грязными страницами”. <mark class="hltr-yellow">Разделяемые буферы управляются параметром</mark> **shared_buffers**. где д<mark class="hltr-green2">анные из файлов базы данных временно хранятся в памяти перед записью или после чтения с диска</mark>
`Когда клиент делает запрос к таблице, PostgreSQL сначала проверяет, находятся ли нужные данные в shared buffers. Если данные уже находятся в буфере, они читаются из памяти (cache hit), что гораздо быстрее, чем чтение с диска. Если данных нет в буфере (cache miss), они загружаются с диска и записываются в буфер.`

**Буфер WAL (журнал предварительной записи):** Буфер WAL -<mark class="hltr-yellow"> это буфер</mark>, который <mark class="hltr-red">**временно хранит изменения**</mark> в базе данных. Эти <mark class="hltr-yellow">данные WAL представляют собой метаданные об изменениях фактических данных</mark>, и их достаточно для восстановления фактических данных во время операций восстановления базы данных. <mark class="hltr-blue">Данные WAL записываются в набор физических файлов в постоянном расположении, называемом</mark> “**Сегменты WAL**“. Распределение памяти в буфере WAL контролируется параметром **wal_buffers**.
WAL — это механизм записи изменений данных в журнал перед их непосредственной записью в базу. Это обеспечивает целостность данных даже в случае сбоя системы. Записи WAL хранятся в памяти (WAL Buffers) перед тем, как их записывают на диск.

**Буфер блокировки:** CLOG расшифровывается как “**журнал фиксации**”. Буферы БЛОКИРОВКИ - это область для хранения **страниц журнала фиксации**. Страницы журнала фиксации содержат **журнал метаданных транзакций** и отличаются от данных WAL. В журналах фиксации отображается состояние фиксации всех транзакций и указывается, была ли транзакция завершена (зафиксирована). Для управления этой областью памяти **нет конкретного параметра**. Это автоматически управляется ядром базы данных в небольших объемах. <mark class="hltr-green2"> буфер для временного хранения записей журналов транзакций до их записи на диск.
</mark>

**Lock Space (память для блокировок):** Этот <mark class="hltr-yellow">компонент памяти предназначен для хранения всех</mark> **<mark class="hltr-red">тяжелых блокировок</mark>,** используемых экземпляром PostgreSQL. <mark class="hltr-blue">Эти блокировки являются общими для всех фоновых серверов и пользовательских процессов, подключающихся к базе данных</mark>. Настройка двух параметров базы данных, а именно **max_locks_per_transaction** и **max_pred_locks_per_transaction**, определенным образом влияет на размер этого компонента памяти.
<mark class="hltr-green2">механизмы блокировок для обеспечения согласованности данных и предотвращения конфликтов между процессами.</mark>

#### Как это работает:

Каждый процесс PostgreSQL имеет доступ к общей памяти для того, чтобы взаимодействовать с данными или метаданными, не блокируя работу других процессов. **Shared Memory** инициализируется при старте сервера и делится между всеми процессами

----

#### Память процесса или серверная память
**Память процесса:** <mark class="hltr-red">Эта область памяти **выделяется каждым внутренним процессом** **для собственного использования</mark>.** Он временно используется приватно каждым процессом Postgres. <mark class="hltr-yellow">По умолчанию размер каждого сеанса будет составлять 4 МБ.</mark> Например.: Если имеется 100 сеансов, то они будут занимать 400 Мб.

##### Память процесса можно дополнительно классифицировать **следующим образом:**

**Вакуумные буферы:**<mark class="hltr-yellow"> Это максимальный объем памяти, используемый каждым из рабочих процессов</mark> <mark class="hltr-red">autovacuum</mark>, и он контролируется параметром базы данных **autovacuum_work_mem** . <mark class="hltr-green2">Память выделяется из оперативной памяти операционной системы, а также зависит от параметра базы данных</mark> **autovacuum_max_workers** . Все эти настройки параметров вступают в силу только тогда, когда **включен демон автоматической очистки**. Этот компонент памяти не используется никаким другим фоновым сервером или пользовательским процессом.

**Рабочая память:** <mark class="hltr-yellow">Это объем памяти, зарезервированный либо для</mark> одной операции <mark class="hltr-red">**сортировки**</mark>, либо для <mark class="hltr-red">**хэш-таблицы**</mark> в запросе,<mark class="hltr-purple"> и он управляется параметром **work_mem**</mark>
Операция сортировки может быть одной из **ORDER BY**, **DISTINCT,** или **Merge join**, а операция с **хэш-таблицей** может быть вызвана **хэш-соединением**, **агрегацией на основе хэша** или подзапросом **IN**. Один сложный запрос может содержать любое количество таких операций **сортировки** или **хэш-таблицы**, и для каждой из этих операций в пользовательском соединении будет создано столько **блоков выделения памяти,** сколько определено параметром **work_mem**.

Рабочая память для обслуживания: Это максимальный объем выделяемой оперативной памяти, используемой для операций обслуживания. Операцией обслуживания может быть **ВАКУУМИРОВАНИЕ**, **СОЗДАНИЕ ИНДЕКСА** или добавление **ВНЕШНЕГО КЛЮЧА** к таблице. Настройка контролируется **параметром базы данных maintenance_work_mem** .

**Временные буферы:** База данных может содержать одну или несколько временных таблиц, и для обработки **блоков данных (страниц)** таких временных таблиц требуется отдельное выделение памяти. Временные буферы, определенные параметром **temp_buffers** . Временные буферы используются только для доступа к временным таблицам в сеансе пользователя. 
**Temporary Memory (Временная память)**
Когда PostgreSQL выполняет сложные операции, такие как сортировка больших наборов данных или хеширование, которые не могут быть выполнены в пределах локальной памяти процесса, он использует **временную память**. Эта память может быть как в оперативной памяти, так и на диске в виде временных файлов, если объём данных превышает доступную память.

- **temp_buffers**: Используется для хранения временных данных внутри транзакции.
- **temp_file_limit**: Ограничивает максимальный размер временных файлов, создаваемых для выполнения операций.

---
### **Модель процессов (Process Model)**

В PostgreSQL используется модель **forked-process**, где каждый клиентский запрос выполняется в отдельном процессе, называемом **Backend Process** (процесс пользователя). Модель процессов обеспечивает параллелизм запросов и изоляцию транзакций.

#### Ключевые процессы:

- **Postmaster** — главный процесс, который управляет другими процессами PostgreSQL, обрабатывает соединения и запускает фоновые процессы.
- **Backend Process** — создаётся для каждого нового клиентского подключения и обрабатывает его запросы.
- **WAL Writer** — процесс, записывающий изменения в WAL (журнал транзакций).
- **Checkpointer** — отвечает за сброс изменённых данных на диск.
- **Autovacuum** — процесс автоматической очистки и реорганизации данных.



----

### Процессная модель и память

В PostgreSQL используется многопроцессная модель. Каждый клиентский запрос обрабатывается отдельным процессом (backend process). Все процессы PostgreSQL взаимодействуют через **общую память** (Shared Memory), но у каждого процесса есть своя **локальная память**.

#### Пример взаимодействия процессов с памятью:

1. **Backend Process**: Когда клиент подключается к PostgreSQL, создается новый процесс backend. Этот процесс управляет запросами от клиента и использует как локальную, так и общую память.
2. **Общая память**: Если запрос требует данных из таблицы, backend процесс сначала проверяет, есть ли нужные страницы данных в **shared buffers**. Если данные уже находятся в буфере (cache hit), они читаются из памяти. Если данных нет в буфере (cache miss), процесс считывает их с диска и загружает в shared buffers.
3. **Локальная память**: Backend процесс использует локальную память для выполнения операций над данными. Например, если нужно отсортировать данные, процесс использует рабочую память (`work_mem`) для выполнения сортировки. Если памяти недостаточно, операция может выйти за пределы доступной оперативной памяти и использовать временные файлы на диске.

#### Фоновые процессы и их использование памяти:

- **Checkpointer**: Этот процесс отвечает за сброс изменённых данных из буфера на диск, чтобы минимизировать потери данных при сбое. Checkpointer использует общую память для получения информации о данных, которые должны быть записаны на диск.
- **WAL Writer**: Этот процесс отвечает за запись данных в журнал транзакций (WAL). Он использует буферы WAL для записи изменений перед тем, как они попадают на диск.
- **Background Writer**: Этот процесс периодически сбрасывает старые страницы из **shared buffers**, чтобы освободить место для новых данных.

**Checkpointer** и **Background Writer** — это два фоновых процесса в PostgreSQL, которые работают с буфером и управляют записью данных на диск, но выполняют разные задачи:

1. **Checkpointer**:
    
    - Основная задача: периодически сбрасывает все **изменённые** (грязные) страницы из **shared_buffers** на диск.
    - Происходит во время **контрольной точки** (checkpoint), которая создается, чтобы обеспечить целостность данных и минимизировать время восстановления после сбоя.
    - Цель: записать все данные на диск и синхронизировать состояние базы данных с логами транзакций (WAL).
2. **Background Writer**:
    
    - Основная задача: **постепенно** сбрасывает **часть изменённых** (грязных) страниц из **shared_buffers** на диск между контрольными точками.
    - Помогает предотвратить накопление слишком большого количества грязных страниц, чтобы снизить нагрузку на Checkpointer во время контрольных точек.
    - Цель: улучшить производительность, уменьшая количество работы Checkpointer'а.

### Разница:

- **Checkpointer** — сбрасывает все страницы при достижении контрольной точки.
- **Background Writer** — сбрасывает страницы постепенно между контрольными точками, чтобы сгладить нагрузку на систему.

### Пример обработки запроса и использования памяти

Рассмотрим пример выполнения запроса:

1. **Подключение**: Клиент подключается к базе данных через TCP/IP. **Postmaster** создаёт новый процесс backend для обработки запросов этого клиента.
    
2. **Запрос**: Клиент отправляет запрос, например, `SELECT * FROM users WHERE age > 30`.
    
3. **Планирование и выполнение**:
    
    - **Parser**: Запрос парсится и разбирается на составляющие.
    - **Planner**: Оптимизатор строит план выполнения запроса, определяя, какие индексы и таблицы нужно использовать.
    - **Executor**: Запрос начинает выполняться. Backend процесс обращается к **Shared Buffers**, чтобы проверить, находятся ли нужные страницы таблицы `users` в памяти.
        - Если данные есть в буфере (cache hit), они читаются из буфера.
        - Если данных нет в буфере (cache miss), процесс загружает страницы с диска и записывает их в буфер.
4. **Работа с памятью**:
    
    - Backend процесс использует **work_mem** для выполнения сортировки и фильтрации данных.
    - Если памяти недостаточно для выполнения сортировки, PostgreSQL начинает использовать временные файлы для обработки данных.
5. **Отправка результата**: После завершения выполнения запроса результат отправляется клиенту через процесс backend, а использованная память освобождается.
    

### Оптимизация памяти на уровне архитектора:

- **shared_buffers**: Размер буферов должен быть настроен для эффективного использования памяти, особенно если сервер имеет большое количество оперативной памяти. Однако слишком большой объём shared buffers может увеличить нагрузку на фоновые процессы.
    
- **work_mem**: Настройка рабочей памяти зависит от сложности запросов и объема данных. Если сервер выполняет много сложных операций, таких как сортировка или агрегация, необходимо увеличить `work_mem`. Важно помнить, что каждый запрос может использовать свою копию `work_mem`, что в случае множества параллельных запросов может привести к превышению объема доступной памяти.
    
- **maintenance_work_mem**: Этот параметр отвечает за объем памяти, выделяемой для выполнения операций обслуживания базы данных, таких как `VACUUM` или создание индексов. Настройка этого параметра важна для повышения производительности крупных операций обслуживания