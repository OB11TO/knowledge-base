---
title: Блокировки
tags:
  - PostgreSql
related_topics: 
created: 2024-10-02 15:40
modified: 2025-04-24T14:58:11+03:00
questions: 
notes: 
links: 
---
 


-------
[[Оптимистические блокировки ]]
[[Пессимистические блокировки]]

https://edu.postgrespro.ru/16/dev2-16/dev2_05_arch_locks.html
[[Блокировки отношений]]
[[Блокировка строк]]
[[Взаимоблокировки]]
[[Блокировки других объектов]]
 
[[Можно ли в Spring делать блокировку транзакций]]

[[Средства мониторинга блокировок]]


-----

![[Pasted image 20241002154120.png]]


![[Pasted image 20241118170458.png]]



В PostgreSQL используется множество самых разных механизмов, которые служат для блокировки чего-либо. 
Блокировки используются, чтобы упорядочить конкурентный доступ к разделяемым ресурсам.  
  
Под конкурентным доступом понимается одновременный доступ нескольких процессов. Сами процессы могут при этом выполняться как параллельно (если позволяет аппаратура), так и последовательно в режиме разделения времени — это не важно.


<mark class="hltr-yellow">Можно заметить, что такой участок разделяемой памяти сам по себе является ресурсом, к которому возможен конкурентный доступ. Если спуститься на уровень ниже, мы увидим, что для упорядочения доступа используются специальные примитивы синхронизации (такие, как семафоры или мьютексы), предоставляемые ОС. Смысл их в том, чтобы код, обращающийся к разделяемому ресурсу, одновременно выполнялся только в одном процессе. На самом низком уровне эти примитивы реализуются на основе атомарных инструкций процессора (таких, как test-and-set или compare-and-swap)</mark>

<mark class="hltr-green2">Ресурсом может быть объект</mark>, с которым работает СУБД, такой как страница данных (идентифицируется именем файла и позицией внутри файла), таблица (oid в системном каталоге), табличная строка (страница и смещение внутри страницы). Ресурсом <mark class="hltr-green2">может быть структура в памяти, такая как хеш-таблица, буфер </mark>и т. п. (идентифицируется заранее присвоенным номером). Иногда даже бывает удобно использовать абстрактные ресурсы, не имеющие никакого физического смысла (идентифицируются просто уникальным числом).  
  
<mark class="hltr-blue">На эффективность блокировок оказывают влияние много факторов, из которых выделим два.</mark>

- **Гранулярность** (степень детализации) важна, если ресурсы образуют иерархию.  
      
    Например, таблица состоит из страниц, которые содержат табличные строки. Все эти объекты могут выступать в качестве ресурсов. Если процессы обычно заинтересованы всего в нескольких строках, а блокировка устанавливается на уровне таблицы, то другие процессы не смогут одновременно работать с разными строками. Поэтому чем выше гранулярность, тем лучше для возможности распараллеливания.  
      
    Но это приводит к увеличению числа блокировок (информацию о которых надо хранить в памяти). В таком случае может применяться _повышение уровня_ (эскалация) блокировок: когда количество низкоуровневых, высокогранулярных блокировок превышает определенный предел, они заменяются на одну блокировку более высокого уровня.  
    
- Блокировки могут захватываться в разных **режимах**.  
      
    Имена режимов могут быть абсолютно произвольными, важна лишь матрица их совместимости друг с другом. Режим, несовместимый ни с каким режимом (в том числе с самим собой), принято называть _исключительным_ или _монопольным_ (exclusive). Если режимы совместимы, то блокировка может захватываться несколькими процессами одновременно; такие режимы называют _разделяемыми_ (shared). В целом, чем больше можно выделить разных режимов, совместимых друг с другом, тем больше создается возможностей для параллелизма.


По времени использования блокировки можно разделить на длительные и короткие.  
  

- **Долговременные** блокировки захватываются на потенциально большое время (обычно до конца транзакции) и чаще всего относятся к таким ресурсам, как таблицы (отношения) и строки. Как правило, PostgreSQL управляет такими блокировками автоматически, но пользователь, тем не менее, имеет определенный контроль над этим процессом.  
      
    Для длительных блокировок характерно большое число режимов, чтобы можно было выполнять как можно больше одновременных действий над данными. Обычно для таких блокировок имеется развитая инфраструктура (например, поддержка очередей ожидания и обнаружение взаимоблокировок) и средства мониторинга, поскольку затраты на поддержание всех этих удобств все равно оказываются несравнимо меньшими по сравнению со стоимостью операций над защищаемыми данными.  
    
- **Краткосрочные** блокировки захватываются на небольшое время (от нескольких инструкций процессора до долей секунд) и обычно относятся к структурам данных в общей памяти. Такими блокировками PostgreSQL управляет полностью автоматически — об их существовании надо просто знать.  
      
    Для коротких блокировок характерны минимум режимов (исключительный и разделяемый) и простая инфраструктура. В ряде случаев могут отсутствовать даже средства мониторинга.


В PostgreSQL используются разные виды блокировок.  
  
**Блокировки на уровне объектов** относятся к длительным, «тяжеловесным». В качестве ресурсов здесь выступают отношения и другие объекты. Если слово блокировка встречается в тексте без уточнений, то оно обозначает именно такую, «обычную» блокировку.  
  
Среди длительных блокировок отдельно выделяются **блокировки на уровне строк**. Их реализация отличается от остальных длительных блокировок из-за потенциально огромного их количества (представьте обновление миллиона строк в одной транзакции). Такие блокировки будут рассмотрены в следующей статье.  
  
Третья статья цикла будет посвящена оставшимся блокировкам на уровне объектов, а также **предикатным блокировкам** (поскольку информация о всех этих блокировках хранится в оперативной памяти однотипным образом).  
  
К коротким блокировкам относятся различные **блокировки структур оперативной памяти**. Их мы рассмотрим в последней статье цикла.

# Блокировки объектов

  
Итак, мы начинаем с блокировок уровня объектов.<mark class="hltr-yellow"> Под объектом здесь понимаются в первую очередь</mark> _отношения_ (<mark class="hltr-red">relations</mark>), то е<mark class="hltr-purple">сть таблицы, индексы, последовательности, материализованные представления, но также и некоторые другие сущности</mark>. Эти блокировки обычно защищают объекты от одновременного изменения или от использования в то время, когда объект изменяется, но также и для других нужд.  
  
Расплывчатая формулировка? Так и есть, потому что блокировки из этой группы используются для самых разных целей. Объединяет их лишь то, как они устроены.
## Устройство  
Блокировки объектов располагаются в общей памяти сервера. Их количество ограничено произведением значений двух параметров: _max_locks_per_transaction_ × _max_connections_.
Пул блокировок — общий для всех транзакций, то есть одна транзакция может захватить больше блокировок, чем _max_locks_per_transaction_: важно лишь, чтобы общее число блокировок в системе не превысило установленный предел. Пул создается при запуске, так что изменение любого из двух указанных параметров требует перезагрузки сервера.

**`max_locks_per_transaction`** — это параметр конфигурации в PostgreSQL, который определяет максимальное количество объектов (например, таблиц, индексов, строк и других блокируемых сущностей), которые одна транзакция может заблокировать одновременно.

Все блокировки можно посмотреть в представлении pg_locks.

<mark class="hltr-green2">Если ресурс уже заблокирован в несовместимом режиме, транзакция, пытающаяся захватить этот ресурс, ставится в очередь и ожидает освобождения блокировки. Ожидающие транзакции не потребляют ресурсы процессора: соответствующие обслуживающие процессы</mark> «засыпают» и пробуждаются операционной системой при освобождении ресурса.  
  
Возможна ситуация _взаимоблокировки_ или _тупика_ (<mark class="hltr-red">deadlock</mark>), при которой <mark class="hltr-yellow">одной транзакции для продолжения работы требуется ресурс, занятый второй транзакцией, а второй необходим ресурс, занятый первой</mark> (в общем случае может произойти взаимоблокировка и более двух транзакций). В таком случае ожидание будет продолжаться бесконечно, поэтому PostgreSQL автоматически определяет такие ситуации и аварийно прерывает одну из транзакций, чтобы остальные могли продолжить работу.


## Типы объектов
Вот список типов блокировок (или, если угодно, типов объектов), с которыми мы будем иметь дело в этой и следующей статьях. Названия приведены в соответствии со столбцом locktype представления pg_locks.  
  
- **relation**  
      
    Блокировки отношений.  
    
- **transactionid** и **virtualxid**  
      
    Блокировка номера транзакции (настоящего или виртуального). Каждая транзакция сама удерживает исключительную блокировку своего собственного номера, поэтому такие блокировки удобно использовать, когда нужно дождаться окончания другой транзакции.  
    
- **tuple**  
      
    Блокировка версии строки. Используется в некоторых случаях для установки приоритета среди нескольких транзакций, ожидающих блокировку одной и той же строки.  
    

  
Разговор об остальных типах блокировок мы отложим до третьей статьи цикла. Все они захватываются либо только в исключительном режиме, либо в исключительном и разделяемом.  
  
- **extend**  
      
    Используется при добавлении страниц к файлу какого-либо отношения.  
    
- **object**  
      
    Блокировка объектов, которые не являются отношениями (баз данных, схем, подписок и т. п.).  
    
- **page**  
      
    Блокировка страницы, используется нечасто и только некоторыми типами индексов.  
    
- **advisory**  
      
    Рекомендательная блокировка, устанавливается пользователем вручную.




-----

![[Pasted image 20241210181948.png]]
![[Pasted image 20241210182009.png]]
![[Pasted image 20241210182044.png]]
 ![[Pasted image 20241210182623.png]]


![[Pasted image 20241210182810.png]]


------



![[Pasted image 20241210183003.png]]

---

![[Pasted image 20241210183223.png]]

-----

![[Pasted image 20241210183821.png]]

 ![[Pasted image 20241210184002.png]]
 ![[Pasted image 20241210184031.png]]
 ![[Pasted image 20241210184254.png]]
 ![[Pasted image 20241210184515.png]]


---

![[Pasted image 20241210184704.png]]
![[Pasted image 20241210184724.png]]

