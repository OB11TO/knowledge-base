---
title: Снимки транзакций
tags:
  - PostgreSql
related_topics: 
created: 2024-09-30 18:18
modified: 2024-10-08T18:56:36+03:00
questions: 
notes: 
links: 
---

----
[[Почему снимки а не блокировки на разных уровнях]]
[[Собственные изменения в транзакции]]
[[Горизонт  событий]]
[[Экспорт снимка данных]]

----


Ваше утверждение о **снимке** (snapshot), который создается в начале каждого оператора на уровне изоляции **`READ COMMITTED`** в PostgreSQL, правильное. Давайте разберем это более подробно и постараемся объяснить на примерах, чтобы стало понятно, что именно происходит в рамках транзакции и выполнения запросов на этом уровне изоляции.
![[Pasted image 20241002152731.png]]

### Основная идея

На уровне изоляции **`READ COMMITTED`** каждый **оператор** (то есть отдельный SQL-запрос) в транзакции использует **снимок данных**, который создается **в момент начала выполнения этого запроса**. Этот снимок фиксирует текущую версию всех зафиксированных (committed) данных на момент начала запроса и используется для получения результата. Как только запрос завершен, снимок "теряется", и для следующего запроса будет создан новый снимок.

### Как работает создание снимка

- **Снимок** — это логическая "фотография" данных в базе на определённый момент времени. Этот снимок фиксирует, какие транзакции завершены и их данные можно читать (зафиксированные данные), и какие транзакции еще в процессе, их данные игнорируются.
- На уровне **`READ COMMITTED`**, снимок создается не для всей транзакции, а **каждый раз, когда выполняется новый запрос** (оператор). Это позволяет видеть только **зафиксированные данные** к моменту начала оператора.

### Пример

Рассмотрим следующую ситуацию с двумя транзакциями:

1. **Транзакция A** (ТA) на уровне изоляции **`READ COMMITTED`**:
    - Начинает свою работу, но ещё не выполняет никаких запросов.
2. **Транзакция B** (ТB):
    - Начинает работать и изменяет строку в таблице.
    - Транзакция B выполняет `COMMIT`, зафиксировав свои изменения.

После этого в **Транзакции A** выполняются два запроса:

- **Первый запрос** в транзакции A (`SELECT`) увидит данные, которые были зафиксированы до его выполнения. Если ТB уже завершила свою работу и зафиксировала изменения до начала первого запроса ТA, то изменения будут видны. Иначе, ТA увидит данные до этих изменений.
- **Второй запрос** в транзакции A (`SELECT`) увидит уже новый снимок данных, который был создан в момент начала выполнения этого запроса. Если в это время другая транзакция (например, ТC) зафиксировала новые изменения, они будут видны этому второму запросу.

### На рисунке момент создания снимка

Синяя отметка на вашем рисунке символизирует **создание снимка** на момент начала выполнения каждого отдельного запроса в транзакции. Этот снимок фиксирует состояние базы данных с точки зрения зафиксированных транзакций. Процесс работает так:

1. Когда оператор начинает выполняться (например, `SELECT` или `UPDATE`), PostgreSQL создает снимок, который фиксирует все зафиксированные данные на момент **начала выполнения этого оператора**.
2. Этот снимок активен на протяжении всего выполнения данного оператора (до завершения выполнения).
3. Если в базе данных параллельно происходят другие транзакции, которые изменяют данные и фиксируют изменения (например, с помощью `COMMIT`), следующий оператор (например, второй `SELECT`) в текущей транзакции увидит уже новые данные, так как для него будет создан **новый снимок** в начале его выполнения.

### Пример с пошаговым объяснением:

1. Транзакция A начинает выполнение:
    
    - Первый оператор (`SELECT * FROM table`) создаёт **снимок 1**, который отражает все зафиксированные данные на момент начала выполнения этого запроса. Оператор завершает работу.
2. В этот момент параллельная транзакция B делает изменения в таблице и фиксирует их.
    
3. Транзакция A выполняет второй оператор (`SELECT * FROM table`):
    
    - Создается **снимок 2**, который будет отличаться от снимка 1, так как изменения, сделанные и зафиксированные транзакцией B, теперь видны. Этот новый оператор видит обновленные данные.

### Заключение:

Уровень изоляции **`READ COMMITTED`** создает **новый снимок** данных **для каждого оператора** внутри транзакции. Этот снимок активен только в течение выполнения конкретного оператора и отражает зафиксированные данные на момент его начала. Это означает, что между запросами внутри одной транзакции данные могут изменяться, если другие транзакции фиксируют свои изменения.


