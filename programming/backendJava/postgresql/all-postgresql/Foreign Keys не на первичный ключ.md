---
title: Foreign Keys не на первичный ключ
tags:
  - PostgreSql
related_topics: 
created: 2024-09-25 14:00
modified: 2024-09-25T14:02:56+03:00
questions: 
notes: 
links: 
---

Да, в реляционных базах данных можно создать **внешний ключ** (**Foreign Key**) на колонку, которая не является **первичным ключом** (**Primary Key**). <mark class="hltr-yellow">Это довольно редкая практика, но она возможна и в некоторых случаях может быть полезна.</mark> Однако, есть определённые нюансы и потенциальные риски, которые следует учитывать при использовании такого подхода.

### Основные моменты при создании Foreign Key не на первичный ключ:

1. **Foreign Key можно создать на любой уникальный столбец**, а не только на первичный ключ:
    
    - Внешний ключ может ссылаться на **любую колонку**,<mark class="hltr-red"> которая является </mark>**уникальной** или же имеет **индекс**, чтобы обеспечивать целостность данных.
    - Например, если у вас есть таблица с колонкой `email`, и этот столбец уникален (имеет уникальный индекс), вы можете создать внешний ключ, который ссылается на этот столбец.
    
    Пример:

```sql
ALTER TABLE orders
ADD CONSTRAINT fk_customer_email
FOREIGN KEY (customer_email)
REFERENCES customers(email);
```
**Foreign Key можно создать на неуникальную колонку**, н<mark class="hltr-red">о это нарушает основную идею внешнего ключа, что может привести к проблемам с целостностью данных.</mark>
    

### Возможные риски и последствия

#### 1. **Нарушение целостности данных**

Одной из главных целей внешнего ключа является поддержание целостности данных, гарантируя, что каждая запись в таблице-потомке ссылается на допустимую запись в таблице-родителе. Если внешний ключ ссылается на неуникальный столбец, **цель референциальной целостности теряется**, так как одна и та же ссылка может относиться к нескольким записям в родительской таблице.

Пример:
```sql
-- Если таблица customers содержит несколько одинаковых email
-- Это может привести к тому, что внешний ключ orders будет ссылаться на несколько записей
ALTER TABLE orders
ADD CONSTRAINT fk_customer_email
FOREIGN KEY (customer_email)
REFERENCES customers(email);
```

В этом случае, при наличии одинаковых значений в столбце `email` в таблице `customers`, внешний ключ не сможет однозначно определить, на какую строку в таблице `customers` ссылается каждая запись в таблице `orders`. Это нарушит референциальную целостность.

#### 2. **Проблемы с производительностью**

Внешний ключ, созданный на неуникальный столбец, может привести к **снижению производительности** базы данных. Внешний ключ обычно подразумевает выполнение операций поиска для проверки ссылочной целостности. Если внешний ключ ссылается на неиндексированный или неуникальный столбец, это может значительно замедлить такие операции.

Без индекса поиск нужного значения в родительской таблице будет происходить по всей таблице, что увеличит время выполнения запросов. Особенно это заметно при работе с большими таблицами.

#### 3. **Отсутствие гарантий уникальности**

Первичный ключ гарантирует уникальность значений в таблице, что делает его надёжным кандидатом для ссылок внешних ключей. Если внешний ключ ссылается на колонку, которая не является уникальной, это может вызвать **неоднозначные или неправильные** связи между таблицами. Например, если в родительской таблице будет несколько строк с одинаковыми значениями в целевом столбце, внешняя таблица не сможет точно указать, к какой из этих строк она относится.

#### 4. **Каскадные операции (DELETE/UPDATE)**

Каскадные операции, такие как `ON DELETE CASCADE` или `ON UPDATE CASCADE`, могут не работать должным образом, если внешний ключ ссылается на неуникальный столбец. В случае удаления или обновления записи в родительской таблице база данных не сможет точно определить, на какие строки в дочерней таблице каскадировать изменения, что может привести к неожиданным последствиям, таким как удаление неверных записей.

#### 5. **Логические ошибки в бизнес-логике**

Использование внешнего ключа на неуникальный столбец может привести к **логическим ошибкам** в бизнес-логике приложения. Например, если приложение предполагает, что одна запись в дочерней таблице может ссылаться только на одну запись в родительской, а фактически это не так из-за неуникальности столбца, это может нарушить работу приложения.

### Пример ситуации, где можно использовать Foreign Key не на первичный ключ:

В реальных системах иногда возникает необходимость создания внешнего ключа не на первичный ключ. Например, если у вас есть таблица клиентов, и каждому клиенту присвоен **уникальный идентификационный код** (например, `customer_code`), который не является первичным ключом, но имеет уникальный индекс. Вы можете создать внешний ключ, ссылающийся на этот столбец:

```sql
CREATE TABLE customers (
    customer_id SERIAL PRIMARY KEY,
    customer_code VARCHAR(50) UNIQUE,
    name VARCHAR(100)
);

CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    customer_code VARCHAR(50),
    order_date DATE,
    FOREIGN KEY (customer_code) REFERENCES customers(customer_code)
);

```

В этом примере внешний ключ `customer_code` в таблице `orders` ссылается на уникальный столбец `customer_code` в таблице `customers`, и это допустимо, так как поле уникально.

### Резюме:

1. **Можно создать Foreign Key на не первичный ключ**, но этот столбец должен быть уникальным, чтобы гарантировать корректную ссылочную целостность.
    
2. Если внешний ключ ссылается на **неуникальный столбец**, это может привести к **нарушению целостности данных**, ухудшению производительности и непредсказуемым результатам, особенно при каскадных операциях.
    
3. **Лучшие практики**:
    
    - Всегда старайтесь ссылаясь на первичный ключ или уникальный индекс, чтобы обеспечить целостность данных.
    - Используйте индексы на столбцах, к которым ссылается внешний ключ, для повышения производительности.
    - Если столбец, на который ссылается внешний ключ, не уникален, внимательно оценивайте риски для целостности данных и производительности.

Итак, в большинстве случаев рекомендуется использовать внешний ключ на **первичный** или **уникальный** ключ, чтобы гарантировать согласованность и целостность данных в базе данных.