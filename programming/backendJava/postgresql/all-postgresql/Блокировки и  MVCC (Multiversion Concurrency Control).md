---
title: Блокировки и  MVCC (Multiversion Concurrency Control)
tags: 
related_topics: 
created: 2024-09-26 18:26
modified: 2025-04-09T14:55:59+03:00
questions: 
notes: 
links: 
---

Блокировки и **MVCC** (Multiversion Concurrency Control) — это два разных механизма, которые в PostgreSQL и других СУБД используются для решения разных задач, связанных с параллельной обработкой транзакций.

### Основная разница:

- **MVCC** — <mark class="hltr-yellow">это способ управления параллельным доступом к данным, при котором одновременно могут существовать несколько версий одной и той же строки (tuple)</mark>. Он предотвращает проблемы, связанные с чтением непоследовательных данных (например, грязные чтения) и управляет видимостью данных для транзакций.
- **Блокировки** (locks) — <mark class="hltr-green2">это механизм защиты от конфликтов при одновременном изменении данных</mark>. Они <mark class="hltr-red">предотвращают проблемы, которые возникают, когда несколько транзакций пытаются одновременно изменить одни и те же строки.</mark>

### Зачем нужны блокировки, если у нас есть MVCC?

**MVCC** решает проблему конкуренции при чтении данных, но не решает проблемы, связанные с конкуренцией при записи данных. Вот несколько ситуаций, где **MVCC** не может полностью заменить блокировки, и блокировки становятся необходимы:

#### 1. **Конфликт при изменении данных (write-write conflict)**

- **MVCC** позволяет нескольким транзакциям одновременно читать одну и ту же строку, создавая для каждой свою "версию" данных. Однако, если несколько транзакций пытаются **одновременно изменить одни и те же строки**, возникает конфликт. Здесь нужно гарантировать, что данные будут корректно изменены.
- Например, если две транзакции одновременно пытаются изменить одну строку, одна из них должна "заблокировать" эту строку, чтобы другая не смогла сделать изменения до тех пор, пока первая транзакция не завершится (COMMIT или ROLLBACK).
- **Блокировка** защищает данные от некорректных изменений и потерь обновлений, когда изменения одной транзакции могут быть перезаписаны другой.

**Пример:**

- Транзакция T1 обновляет строку `{id=1, salary=5000}`.
- Транзакция T2 в то же время пытается обновить ту же строку.
- Одна из транзакций должна ждать завершения другой, иначе результат обновлений будет непредсказуем.

#### 2. **Избежание потерь данных (lost updates)**

- Без блокировок при параллельном изменении строк данные могут потеряться. Например, транзакция T1 читает данные и изменяет их, а T2 в это время читает те же данные. Если обе транзакции изменят строку и запишут результат, одно из изменений будет потеряно.
- **Блокировки** помогают предотвратить потерю обновлений, гарантируя, что одна транзакция завершит свои изменения, прежде чем другая начнет свои.

#### 3. **Поддержание целостности данных**

- В некоторых случаях блокировки необходимы для того, чтобы поддерживать логическую целостность данных, особенно когда несколько транзакций одновременно работают с взаимосвязанными данными.
- Например, при работе с внешними ключами, если одна транзакция удаляет строку, которая ссылается на другую таблицу, другая транзакция не должна иметь возможность вставлять или изменять связанные данные до завершения первой транзакции.

#### 4. **Индексные блокировки**

- Блокировки применяются не только к данным, но и к структурам данных, таким как индексы. Если транзакция изменяет индекс, другая транзакция не должна иметь возможность работать с этим индексом, пока не завершатся изменения.

#### 5. **Блокировки на уровне таблиц и схем**

- Блокировки применяются также для предотвращения конфликтов на уровне всей таблицы или схемы данных. Например, если идет изменение структуры таблицы (например, добавление столбцов), другие транзакции должны быть заблокированы, чтобы избежать неконсистентных состояний схемы.

### Типы блокировок в PostgreSQL:

1. **Блокировки на уровне строк**:
    
    - **Row-level locks (строчные блокировки)** — это наиболее используемый тип блокировок, который предотвращает одновременные изменения одной и той же строки в разных транзакциях. Блокировки строк нужны, чтобы предотвратить **потерю обновлений** и **конфликты при записи**.
2. **Блокировки на уровне таблиц**:
    
    - Например, для операций изменения схемы, когда транзакция добавляет столбцы или удаляет таблицу, применяется **блокировка на уровне таблицы**.
3. **Блокировки для индексов**:
    
    - Когда идет работа с индексами (например, пересоздание индексов), необходимо предотвратить доступ к индексам другим транзакциям, чтобы избежать нарушения их целостности.
4. **Шеринговые и эксклюзивные блокировки**:
    
    - **Шеринговая блокировка (Shared Lock)** позволяет нескольким транзакциям читать данные, но блокирует изменения.
    - **Эксклюзивная блокировка (Exclusive Lock)** — блокирует и чтение, и запись, пока транзакция не завершит свои изменения.

### Пример работы блокировок:

Предположим, у нас есть две транзакции, которые пытаются одновременно изменить одну и ту же строку:

1. Транзакция T1:

```sql
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;

```

Транзакция T2:
```sql
BEGIN;
UPDATE accounts SET balance = balance + 200 WHERE id = 1;

```

Если бы не было блокировок, обе транзакции могли бы завершиться, перезаписывая изменения друг друга, что приведет к потере данных. Но благодаря блокировкам:

- Когда T1 начинает изменять строку с `id = 1`, PostgreSQL ставит **эксклюзивную блокировку** на эту строку.
- T2 должна будет ждать завершения T1, прежде чем она сможет изменить те же данные.
- Когда T1 завершится (выполнит COMMIT или ROLLBACK), блокировка будет снята, и T2 сможет продолжить свои изменения.

### Почему блокировки и MVCC дополняют друг друга?

**MVCC** позволяет транзакциям читать старые версии данных, избегая блокировок на чтение и повышая конкурентность чтений. Однако, для записей и одновременных изменений данных блокировки необходимы, чтобы защитить данные от некорректного изменения.

- **MVCC** управляет параллельными **чтениями**, обеспечивая согласованность версий данных без необходимости блокировок для чтения. Это позволяет одновременно читать данные, не блокируя доступ для других транзакций.
- **Блокировки** нужны для управления параллельными **записями**. Без блокировок транзакции могли бы перезаписывать изменения друг друга, что привело бы к потере данных или несогласованности.

### Проблемы, которые решают блокировки:

- **Потеря обновлений**: если транзакции одновременно пытаются изменить одну и ту же строку.
- **Конфликт записей**: предотвращение одновременных изменений тех же данных.
- **Согласованность индексов и таблиц**: предотвращение некорректных изменений в индексах или структуре таблиц.

### Заключение:

- **MVCC** решает проблему конкурентного **чтения** данных, позволяя транзакциям видеть разные версии строк без блокировок.
- **Блокировки** необходимы для управления конкурентными **записями** данных, чтобы защитить данные от конфликтов и потерь.

Таким образом, **MVCC** и блокировки вместе помогают обеспечить высокую конкурентность доступа и целостность данных в PostgreSQL. **MVCC** снимает нагрузку с блокировок для чтения, улучшая производительность и снижая задержки, тогда как блокировки предотвращают конфликты при параллельных изменениях данных


В PostgreSQL блокировки и механизм **MVCC (Multiversion Concurrency Control)** работают на разных уровнях системы, и их реализация связана как с **общей памятью**, так и с **файлами на диске**. Давайте разберем, где происходят блокировки и как работает MVCC.

### 1. **Где происходят блокировки?**

Блокировки в PostgreSQL происходят на нескольких уровнях:

- **Уровень строк** (самый распространённый в PostgreSQL)
- **Уровень страниц** (в некоторых случаях)
- **Уровень таблиц** (например, при изменении структуры таблицы)
- **Общая память** используется для управления блокировками и их состоянием

#### Уровни блокировок:

1. **Блокировки на уровне строк** (Row-Level Locks):
    
    - Это наиболее часто используемый тип блокировки в PostgreSQL.
    - PostgreSQL использует **блокировки на уровне строк**, чтобы обеспечить корректную работу транзакций при изменении данных.
    - Блокировки строк происходят в **общей памяти**, в так называемой **`lock manager`** структуре, которая хранит информацию о текущих блокировках. Когда транзакция пытается изменить строку, создается блокировка на эту строку в этой структуре, и другие транзакции получают информацию, что эта строка заблокирована.
    - Пример: Когда транзакция выполняет `UPDATE` или `DELETE` над строкой, PostgreSQL блокирует эту строку, чтобы другие транзакции не могли её одновременно изменить.
2. **Блокировки на уровне таблиц** (Table-Level Locks):
    
    - Эти блокировки происходят, когда выполняются операции, которые изменяют структуру таблицы, например, **`ALTER TABLE`**, **`DROP TABLE`** или **`VACUUM`**.
    - Блокировки на уровне таблиц также управляются в общей памяти через **`lock manager`** и используются для защиты целостности структуры таблицы.
    - Пример: Если транзакция выполняет `ALTER TABLE`, то PostgreSQL ставит блокировку на всю таблицу, чтобы другие транзакции не могли параллельно изменять её структуру.
3. **Блокировки на уровне страниц (Page-Level Locks)**:
    
    - Эти блокировки используются реже и применяются в некоторых специфических ситуациях, например, при работе с индексами.
    - Страницы (или блоки данных) — это минимальная единица хранения данных на диске, и иногда PostgreSQL блокирует определенные страницы, чтобы избежать конфликтов при доступе к данным или их индексации.

#### Где хранятся блокировки:

- **Общая память** (Shared Memory): Все блокировки (строк, страниц, таблиц) управляются через специальную структуру в общей памяти — это область, называемая **Lock Manager**.
    - Lock Manager хранит текущие состояния блокировок (кто блокирует, на каких уровнях, и какие транзакции ждут блокировок).
    - Блокировки на диске не хранятся; они хранятся в оперативной памяти, а при сбое системы они теряются.

### 2. **Где происходит MVCC?**

**MVCC (Multiversion Concurrency Control)** — это механизм, который позволяет нескольким транзакциям одновременно читать и изменять данные, обеспечивая изоляцию между транзакциями без явных блокировок на чтение.

#### Как работает MVCC в PostgreSQL:

- **Версии строк**: Каждая строка в таблице может иметь несколько версий. Когда транзакция изменяет строку (например, через `UPDATE`), PostgreSQL создаёт **новую версию строки**, не изменяя старую. Таким образом, старые версии строк остаются доступными для других транзакций, которые их могут использовать для чтения, а новые версии доступны только для транзакций, которые их создают.
    
    MVCC реализуется за счёт того, что транзакция видит только те строки (версии строк), которые были зафиксированы до её начала.
    
- **Снимки данных (Snapshot)**: Каждая транзакция работает с **снимком** данных, который был актуален на момент её начала. Этот снимок фиксирует состояние базы данных, и транзакция видит только те строки, которые были зафиксированы до её начала.
    
    - Когда создаётся новая версия строки, старая версия остаётся в таблице до тех пор, пока она не будет очищена с помощью **`VACUUM`**.

#### Где происходит MVCC:

- **Хранение на диске**:
    - Основная часть работы MVCC связана с **файловой системой** и диском. Каждая строка таблицы имеет специальные метаданные, такие как **идентификатор транзакции**, которая её создала (и идентификатор транзакции, которая её удаляет, если применимо).
    - Эти метаданные хранятся в самих строках на уровне файлов данных на диске.
- **Общая память**:
    - Вся информация о видимости данных для транзакций (в каких транзакциях строки были созданы или удалены) частично управляется через память, так как снимки данных, которыми пользуются транзакции, хранятся в общей памяти. Однако сами данные (версии строк) хранятся на диске.

#### Механизм видимости строк:

- Когда транзакция делает запрос к таблице, PostgreSQL проверяет метаданные строк (когда и кем они были созданы/удалены) и принимает решение, должна ли эта строка быть видимой для текущей транзакции.
- Это решение принимается на основе информации о состоянии других транзакций, которая хранится как в памяти (в том числе в системных таблицах), так и в метаданных строк.

### Итог:

1. **Блокировки**:
    - Блокировки происходят в **общей памяти** (в структуре **Lock Manager**).
    - Блокировки могут быть на уровне строк, страниц и таблиц, но физически они управляются через общую память и влияют на доступ транзакций к данным.
2. **MVCC**:
    - MVCC работает с версиями строк, которые хранятся **на диске**.
    - Видимость строк для транзакций определяется на основе метаданных, которые хранятся в самих строках (на диске), но управляется через общую память (через снимки данных и транзакционные идентификаторы).

Таким образом, механизм блокировок управляется в основном в памяти, а MVCC оперирует версиями строк, которые физически хранятся на диске.




-------

В PostgreSQL при использовании MVCC и уровня изоляции по умолчанию **Read Committed** произойдет следующее:

### Сценарий:

1. **Т1** начинает транзакцию, **удаляет строку**, но пока не коммитит.
    
2. **Т2** начинает транзакцию (до коммита Т1) и пытается **обновить ту же строку**.
    
    - На этом этапе Т2 «видит» строку, так как удаление Т1 еще не закоммичено.
        
    - Однако Т2 блокируется, ожидая снятия блокировки, которую удерживает Т1.
        
3. **Т1 коммитит удаление**. Строка помечается как удаленная.
    
4. **Т2** получает управление, но теперь **не находит строку** для обновления (так как Т1 уже закоммитила удаление).
    
    - Команда `UPDATE` в Т2 завершается успешно, но **не изменяет ни одной строки** (поскольку целевая строка удалена).
        
5. **Т2 коммитит**, но **никаких изменений в БД не вносится**.
    

### Итог:

- **Строка остается удаленной**.
    
- Обновление от Т2 **не применяется**, так как строка уже отсутствует на момент выполнения `UPDATE`.
    
- В БД сохраняется состояние после коммита Т1 (строка удалена), а Т2 не вносит изменений.
    

---

### Если используется уровень изоляции **Repeatable Read**:

- Т2 будет использовать снимок данных на момент своего начала (видит строку, даже если Т1 удалила ее позже).
    
- При попытке обновить строку PostgreSQL обнаружит конфликт версий (строка удалена в текущем состоянии БД, но существует в снимке Т2).
    
- Это вызовет **ошибку сериализации** (`Serialization Failure`), и Т2 будет **откачена**.
    

---

### Ключевые моменты:

1. **Блокировки**: Т1 блокирует строку при удалении. Т2 ждет снятия блокировки, но после коммита Т1 строка уже удалена.
    
2. **Видимость данных**: При `Read Committed` каждая команда видит последние закоммиченные изменения. После коммита Т1 строка невидима для новых операций.
    
3. **Поведение UPDATE**: Если строка удалена, `UPDATE` не найдет ее и не выполнит действий (0 строк обновлено), но транзакция не прерывается.
    

**Итоговый результат**: Строка **не восстанавливается**, обновление Т2 **не применяется**. БД остается в состоянии, где строка удалена.