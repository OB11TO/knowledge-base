---
title: Можно ли в Spring делать блокировку транзакций
tags: 
related_topics: 
created: 2024-11-19 16:43
modified: 2024-11-19T16:44:12+03:00
questions: 
notes: 
links: 
---


Да, в Spring и PostgreSQL можно столкнуться с взаимоблокировкой транзакций (deadlock), если не соблюдать определенные меры предосторожности. Взаимоблокировка может произойти, если две или более транзакций пытаются захватить ресурсы в разном порядке, создавая замкнутый цикл зависимостей.

### Как это может произойти?

1. **Порядок блокировок ресурсов**: Например, транзакция A блокирует строку X, а транзакция B блокирует строку Y. Затем A пытается захватить Y, а B — X. Это приводит к deadlock.
2. **Эскалация блокировок**: PostgreSQL может эскалировать блокировки с уровня строки до уровня таблицы, если запросы обрабатывают большое количество строк.
3. **Параллельные транзакции**: В Spring, особенно при использовании `@Transactional` с уровнем изоляции выше `READ_COMMITTED`, вероятность взаимоблокировки возрастает.

### Как избежать взаимоблокировок?

1. **Единый порядок доступа к ресурсам**:
    
    - Всегда захватывайте ресурсы в одном и том же порядке. Например, если вы читаете из таблицы A, а затем из таблицы B, убедитесь, что все транзакции делают это в таком же порядке.
2. **Используйте правильный уровень изоляции**:
    
    - В большинстве случаев `READ_COMMITTED` подходит и снижает вероятность взаимоблокировок. Более высокие уровни, такие как `REPEATABLE_READ` или `SERIALIZABLE`, увеличивают вероятность конкуренции за блокировки.
3. **Ограничьте длительность транзакций**:
    
    - Старайтесь, чтобы транзакции были как можно короче. Избегайте выполнения долгих операций (например, запросов к внешним API) внутри транзакций.
4. **Обновление ресурсов в батчах**:
    
    - Если нужно обновить много строк, выполняйте операции по частям, чтобы минимизировать вероятность захвата множества блокировок одновременно.
5. **Тайм-ауты для транзакций**:
    
    - Установите тайм-аут для транзакций через Spring, чтобы избежать бесконечного ожидания:
        
        java
        
        Копировать код
        
        `@Transactional(timeout = 5) public void someMethod() {     // Ваш код }`
        
6. **Использование параметров PostgreSQL**:
    
    - PostgreSQL сам обнаруживает взаимоблокировки и разрывает их, выбрасывая исключение. Это регулируется параметром `deadlock_timeout` (по умолчанию 1 секунда). Убедитесь, что этот параметр настроен оптимально.

### Пример сценария взаимоблокировки

```sql
-- Транзакция 1
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;

-- Транзакция 2
BEGIN;
UPDATE accounts SET balance = balance - 200 WHERE id = 2;

-- Теперь Транзакция 1 пытается заблокировать id=2
UPDATE accounts SET balance = balance - 100 WHERE id = 2;

-- Транзакция 2 пытается заблокировать id=1
UPDATE accounts SET balance = balance - 200 WHERE id = 1;

-- Взаимоблокировка!

```


### В Spring

Если транзакции выполняются в разных потоках, то их поведение в PostgreSQL можно воспроизвести:

```java
@Service
public class AccountService {

    @Transactional
    public void transferFromAccountAtoB() {
        accountRepository.updateBalance(1, -100); // Блокировка строки с id=1
        accountRepository.updateBalance(2, +100); // Попытка заблокировать строку с id=2
    }

    @Transactional
    public void transferFromAccountBtoA() {
        accountRepository.updateBalance(2, -200); // Блокировка строки с id=2
        accountRepository.updateBalance(1, +200); // Попытка заблокировать строку с id=1
    }
}

```


Если оба метода будут вызваны одновременно, то возможна взаимоблокировка.

### Как обработать deadlock в Spring?

Spring может обработать исключение `DeadlockLoserDataAccessException`, которое выбрасывается, когда PostgreSQL разрывает взаимоблокировку:

```java
try {
    transferService.transferFunds();
} catch (DeadlockLoserDataAccessException e) {
    // Логика обработки, например, повтор транзакции
}

```

### Итог

Да, при неправильной работе с транзакциями в Spring и PostgreSQL возможны взаимоблокировки. Чтобы избежать их:

- Контролируйте порядок захвата ресурсов.
- Используйте минимально необходимый уровень изоляции.
- Сократите длительность транзакций.
- Настройте правильную обработку исключений.