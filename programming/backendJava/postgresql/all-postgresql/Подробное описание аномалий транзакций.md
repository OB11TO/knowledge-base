---
title: Подробное описание аномалий транзакций
tags:
  - PostgreSql
related_topics: 
created: 2025-04-22 13:51
modified: 2025-04-24T12:51:49+03:00
questions: 
notes: 
links: 
---


------
[[Паттерны работы с бд в микросервисах]]


-------


![[Pasted image 20250422135921.png]]

```sql
|[Lost Update. Read Committed]|
|||
||Tx1 Tx2|

||begin;|
||set transaction isolation level read committed;|
||show transaction isolation level;|
||begin;|
||set transaction isolation level read committed;|
||show transaction isolation level;|
||select * from accounts where id = 1;|
||select * from accounts where id = 1;|

ПРОБЛЕМА вот тут, мы приравниваем 1500 + 7, из за этого значения перетираются. 
Можно использовать Repitable READ, он ЗАЩИТИТ ОТ ПАРАЛЕЛЬНОГО write и выкинет ошибку сериализации.

ИЛИ писать set balance + 7
Тогда после блокировки изменений, получится 1514, а не 1507

||update accounts set balance = 1500 + 7|
||where id = 1 returning *;|
||update accounts set balance = 1500 + 7|
||where id = 1 returning *;|
||commit;|
||commit;|
||
```
- Вот подробная картинка 
 ![[Pasted image 20250423140508.png]]

![[Pasted image 20250424125137.png]]

------

![[Pasted image 20250422140640.png]]



------

![[Pasted image 20250422141107.png]]




------
![[Pasted image 20250422141611.png]]

--------
![[Pasted image 20250422141824.png]]

-----
![[Pasted image 20250422144724.png]]
Это классический пример **write skew**‑аномалии (записного уклона) при работе на уровне **Snapshot Isolation** (в PostgreSQL это уровень Repeatable Read). На слайде «Write‑Skew #0 anomaly» показано следующее:

1. **Оба транзакции стартуют почти одновременно** и получают один и тот же **снимок** БД (snapshot).
    
    - Tx1 видит строки зелёныеv1,v2зелёные v1, v2зелёныеv1,v2.
        
    - Tx2 тоже видит ровно те же строки v1,v2v1, v2v1,v2.
        
2. **Обе транзакции читают** эти же исходные значения (R(cond) → (v1,v2)) и вычисляют новое значение v3 = v1 & v2.  
    При этом они **не модифицируют** сами v1 и v2, то есть нет прямого write‑write конфликта на этих строках.
    
3. Затем каждая **вставляет** (INSERT) «совсем новую» строку с v3.  
    Поскольку под Repeatable Read в PostgreSQL каждая транзакция смотрит на свою собственную копию снимка, она **не видит** вставку, сделанную параллельным участником.  
    Нет ни конфликта по существующим строкам, ни уникального ограничения на v3 → обе вставки спокойно проходят.
    
4. Обе транзакции **успешно коммитятся**, и в результате в таблице оказываются **две одинаковые** строки v3.
    

### Почему Repeatable Read не помогает

- В PostgreSQL уровень Repeatable Read реализован как Snapshot Isolation.
    
- Snapshot Isolation **гарантирует**, что внутри транзакции вы не увидите чужих коммитов, но **не запрещает** ситуацию, когда две транзакции **читают один и тот же набор строк** и на основании этого **независимо** делают вставки, которые не пересекаются с исходными данными (то есть не возникает write‑write конфликта на одних и тех же физических строках).
    
- Такие «фантомные» или «write‑skew» аномалии при Snapshot Isolation остаются возможными.
![[Pasted image 20250423143529.png]]

### Как это исправить

- Чтобы подобные аномалии **обнаруживались** и **откатывались**, нужно использовать уровень **SERIALIZABLE** (в PostgreSQL он основан на Serializable Snapshot Isolation с отслеживанием конфликтов на уровне **predicate locks**).
    
- Тогда при попытке второго коммита СУБД выявит конфликт (TX1 и TX2 «пересеклись» по логическому условию) и **откатит** одну из транзакций с ошибкой `could not serialize access`.

-----

![[Pasted image 20250422150321.png]]

- <mark class="hltr-red">На группе одних и тех же строк принимаем разные решения параллельно.</mark> 
![[Pasted image 20250423143625.png]]
Это ещё один вариант **write‑skew**‑аномалии при работе на уровне **Snapshot Isolation** (в PostgreSQL уровень `REPEATABLE READ`):
![[Pasted image 20250422150746.png]]
## Почему `REPEATABLE READ` это не ловит

- Уровень **Repeatable Read** в PostgreSQL — это реализация **Snapshot Isolation**.
    
- Каждая транзакция видит **свой** снимок данных и **не видит** изменений, которые сделал параллельный участник, пока она не закоммитится и не начнёт новую транзакцию.
    
- Здесь нет прямого **write–write конфликта**: Tx1 и Tx2 обновляют **разные** строки (`Alice` vs `Bob`), поэтому никаких блокировок на одних и тех же физических строках не возникает.
    
- Следовательно, обе транзакции спокойно коммитятся, хотя вместе они нарушили глобальное инвариантное условие.
    
## Как это предотвратить

- На уровне **SERIALIZABLE** PostgreSQL отслеживает не только физические блокировки, но и **логические зависимости** (predicate‑locks).
![[Pasted image 20250423144020.png]]

- При повторном коммите СУБД увидит, что две транзакции «пересекаются» по одному и тому же условию (они обе опираются на одно и то же значение `COUNT(*)`) и **отклонит** одну из них с ошибкой типа:

```java
ERROR:  could not serialize access due to read/write dependencies among transactions

```

**Вывод:** подобные «скрытые» конфликты обновления разных строк по одной и той же логической предикате (`IF COUNT ≥ 2`) не обнаруживаются на Repeatable Read, но успешно выявляются и блокируются на уровне Serializable.


-----

![[Pasted image 20250422151049.png]]

- <mark class="hltr-green2">Циклическая зависимость . Выворачиваем по одному и обновляем другое и наоборот. ЦИКЛИЧЕСКИЙ ГРАФ</mark>
## Как это предотвратить

- На уровне **SERIALIZABLE** PostgreSQL отслеживает не только физические блокировки, но и **логические зависимости** (predicate‑locks)
![[Pasted image 20250423143959.png]]
![[Pasted image 20250423142043.png]]

-------
![[Pasted image 20250422151454.png]]



------
![[Pasted image 20250422163809.png]]

----
![[Pasted image 20250422163947.png]]



-----
![[Pasted image 20250422164507.png]]


-----
![[Pasted image 20250422171941.png]]

-----
![[Pasted image 20250422172027.png]]

-----

![[Pasted image 20250423142822.png]]
 - <mark class="hltr-yellow">НИ ОДИН УРОВЕНЬ ИЗОЛЯЦИИ ТУТ НЕ ПОМОЖЕТ !</mark>

------

