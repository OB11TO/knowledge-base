---
title: Что происходит внутри сессии
tags:
  - PostgreSql
related_topics: 
created: 2024-09-26 15:05
modified: 2024-11-25T11:09:17+03:00
questions: 
notes: 
links: 
---
Внутри PostgreSQL сессия выполняет запрос, проходя через несколько этапов обработки. Каждый этап выполняет свою роль: от разбора запроса до его фактического выполнения и возвращения результата. Рассмотрим каждый этап подробно:

1. **Parser (Парсер)**
    
    На этом этапе происходит синтаксический анализ SQL-запроса. <mark class="hltr-green2">Главная задача парсера — проверить, является ли запрос валидным с точки зрения синтаксиса и превратить его в дерево разбора (parse tree)</mark>. Это <mark class="hltr-yellow">дерево отражает структуру запроса, но ещё не проверяет его с точки зрения корректности данных.</mark>
    
    - **Что происходит:**
        
        - Парсер анализирует запрос на предмет синтаксических ошибок (например, проверяет правильность ключевых слов, имен таблиц, функций и т.д.).
        - <mark class="hltr-red">Результатом работы парсера является дерево разбора (parse tree) </mark>— <mark class="hltr-yellow">структура данных, которая описывает элементы запроса в виде узлов дерева.</mark>
    - **Пример**: Запрос: `SELECT name FROM employees WHERE age > 30;` Результат: дерево, содержащее операторы `SELECT`, `FROM`, `WHERE`, а также колонки и значения.
        
2. **Analyser (Анализатор)**
    
    Следующим этапом является **анализатор**, который<mark class="hltr-yellow"> преобразует дерево разбора в **дерево запроса (query tree)** и проверяет запрос на логическую корректность.</mark>
    
    - **Что происходит:**
        
        - <mark class="hltr-purple">Проверка существования упомянутых объектов (например, таблиц и колонок) в базе данных.</mark>
        - <mark class="hltr-blue">Проверка прав доступа пользователя на выполнение запроса.</mark>
        - <mark class="hltr-purple">Определение типов данных и проверка их совместимости</mark> (например, если используется функция, которая ожидает число, но в запросе передается строка — это ошибка).
        - <mark class="hltr-blue">Определение необходимости преобразования типов данных</mark> (например, приведение строк к числам).
        - <mark class="hltr-purple">Привязка таблиц и колонок к конкретным объектам в базе.</mark>
    - **Пример**: Запрос: `SELECT name FROM employees WHERE age > 30;`
        
        - Анализатор проверит, существует ли таблица `employees` и колонка `name`, <mark class="hltr-yellow">проверит совместимость типов данных и прав пользователя на выполнение запроса.</mark>
3. **Rewriter (Переписчик)**
    
    После анализа запрос проходит через **переписчик (rewriter)**, который модифицирует дерево запроса, если это необходимо. Обычно это касается представлений (views), правил (rules) и триггеров.
    
    - **Что происходит:**
        
        - Если запрос обращается к **представлениям** (views), переписчик заменяет представления на соответствующие запросы.
        - Если существуют **правила переписывания** (например, правило `INSTEAD OF` для обновления представлений или замены запросов), переписчик применяет их.
        - Может происходить модификация запроса с целью оптимизации или выполнения специальных правил.
    - **Пример**: Если запрос обращается к представлению `active_employees`, переписчик заменит запрос на фактический запрос, описывающий это представление:
        
        - Запрос: `SELECT name FROM active_employees;`
        - Представление: `CREATE VIEW active_employees AS SELECT * FROM employees WHERE is_active = true;`
        - Переписанный запрос: `SELECT name FROM employees WHERE is_active = true;`
4. **Planner (Планировщик)**
    
    На этом этапе планировщик определяет, **как лучше всего выполнить запрос** с точки зрения производительности. Это включает выбор способов доступа к данным (например, через индекс или последовательное сканирование) и оптимизацию порядка выполнения операций.
    
    - **Что происходит:**
        
        - Планировщик <mark class="hltr-purple">анализирует доступные индексы, статистику по таблицам и данные, чтобы выбрать наилучший план выполнения запроса.</mark>
        - Выбор метода доступа к данным: последовательное сканирование (Sequential Scan), использование индексов (Index Scan) или комбинация методов.
        - Оптимизация соединений (JOIN) — выбор наиболее эффективного способа соединения таблиц (например, Nested Loop, Hash Join, Merge Join).
        - Принятие решения о возможности параллельного выполнения запросов, если данные позволяют это сделать.
        - Определение стоимости различных планов выполнения запроса и выбор самого оптимального с точки зрения затрат ресурсов.
    - **Результат**: **План запроса (query plan)** — это набор шагов, который описывает, как будет выполняться запрос. Включает последовательность действий, использование индексов, методов соединений и т.д.
        
    - **Пример**: Для запроса `SELECT * FROM employees WHERE age > 30;` планировщик может выбрать последовательное сканирование всей таблицы или использование индекса по колонке `age`, в зависимости от размера данных и наличия индексов.
        
5. **Executor (Исполнитель)**
    
    Это последний этап, на котором **план запроса** фактически исполняется, и запрос взаимодействует с данными. Исполнитель проходит по плану, выполняя шаги один за другим, и возвращает результат пользователю.
    
    - **Что происходит:**
        
        - Исполнитель выполняет действия, описанные в плане запроса: сканирование таблиц, выбор нужных строк, выполнение фильтров и соединений.
        - Чтение данных из памяти или с диска (если страницы не находятся в shared_buffers).
        - Выполнение операций на данных (например, агрегация, сортировка, фильтрация).
        - Постепенная передача результатов обратно клиенту (если это SELECT-запрос), либо выполнение модификаций данных (если это INSERT, UPDATE или DELETE).
    - **Пример**: Для запроса `SELECT name FROM employees WHERE age > 30;` исполнитель будет:
        
        - Прочитывать строки таблицы `employees`,
        - Проверять условие `age > 30`,
        - Возвращать результат в виде списка имен.

### Пример работы на реальном запросе

Запрос:

```sql
SELECT name, age FROM employees WHERE age > 30 ORDER BY age DESC;
```

1. **Parser**: Разбирает запрос на составляющие — проверяет синтаксис и формирует начальное дерево запроса.
2. **Analyser**: Проверяет, существует ли таблица `employees`, проверяет колонки `name` и `age`, проверяет права доступа пользователя.
3. **Rewriter**: Если `employees` является представлением или если есть правила, то запрос переписывается.
4. **Planner**: Определяет оптимальный план запроса. Например, если существует индекс по колонке `age`, планировщик может выбрать его для ускорения фильтрации и сортировки.
5. **Executor**: Выполняет план запроса, фильтрует строки по условию `age > 30`, сортирует их по возрасту в порядке убывания и возвращает результат клиенту.

### Заключение

Таким образом, запрос в PostgreSQL проходит через несколько стадий: от простого разбора синтаксиса до полной оптимизации и выполнения. Каждый из этих этапов служит своей цели: проверка корректности, оптимизация выполнения и фактическое выполнение запроса, что позволяет базе данных работать эффективно даже с большими объёмами данных.

![[Pasted image 20241001163954.png]]
