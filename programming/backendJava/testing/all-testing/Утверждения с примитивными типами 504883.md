---
title: Утверждения с примитивными типами 504883
tags:
  - Testing
related_topics: 
created: 2025-01-16 13:35
modified: 2025-02-04T13:10:54+03:00
questions: 
notes: 
links: 
---


<mark class="hltr-green2">Поговорим о структуре тестового метода.</mark> Тесты желательно писать в одном стиле. Хорошо <mark class="hltr-yellow">зарекомендовал себя шаблон тестов, получивший название</mark> **AAA** - **A**rrange, **A**ct, **A**ssert.

На этапе **Arrange** <mark class="hltr-blue">производится подготовка данных для проверяемого действия - создаются нужные объекты, поля объектов наполняются тестовыми данными.</mark>
Этап **Act** - это<mark class="hltr-red"> выполнение действия объекта, которое должно будет оцениваться, и сохранение результата этого действия.</mark>
Этап **Assert** -<mark class="hltr-yellow"> это проверка соответствие фактического результата действия ожидаемому результату.</mark>

Рассмотрим метод из предыдущего урока и отметим на нем этапы **Arrange-Act-Assert**:

```java
@Test
void whenMultiCallHasNextThenTrue() {
/* Arrange - создание объекта и заполнение его данными */
   ArrayIt iterator = new ArrayIt(
           new int[] {1, 2, 3}
   );
/* Act - выполнение действия и сохранение результата */
   boolean rsl = iterator.hasNext();
/* Assert - оценка соответствия результата ожидаемому исходу */
   assertThat(result).isTrue();
/* этапы Act и Assert могут быть размещены в одной строке кода */
   assertThat(iterator.hasNext()).isTrue();
}
```


-----

### **1. AAA (Arrange, Act, Assert) — Основной шаблон**

Этот шаблон помогает структурировать тесты для ясности:

- **Arrange**: Подготовка данных, объектов, моков или среды тестирования.
- **Act**: Выполнение действия, которое нужно протестировать.
- **Assert**: Проверка результата выполнения действия.

**Пример:**
```java
@Test
void shouldReturnSumOfTwoNumbers() {
    // Arrange
    Calculator calculator = new Calculator();
    int a = 5, b = 10;

    // Act
    int result = calculator.add(a, b);

    // Assert
    assertEquals(15, result);
}

```

### **Используйте `@DisplayName`**

Для повышения читаемости отчетов тестов можно добавлять аннотации `@DisplayName`, чтобы явно указать, что проверяется.

```java
@DisplayName("Calculator should return correct sum of two numbers")
@Test
void shouldReturnSumOfTwoNumbers() { 
    assertEquals(15, calculator.add(5, 10)); 
}
```

### **10. Старайтесь писать BDD-тесты Behavior Driven Development (BDD)

Используйте подход **Given-When-Then** (BDD), чтобы тесты были еще более читаемыми.

**Пример:**

```java
@Test
void shouldReturnDiscountForPremiumUser() {
    // Given
    User user = new User("John", UserType.PREMIUM);
    DiscountService discountService = new DiscountService();

    // When
    double discount = discountService.calculateDiscount(user);

    // Then
    assertEquals(0.2, discount);
}

```

### **Резюме**

Следуйте этим принципам:

- Используйте структуру **AAA** или **Given-When-Then**.
- Держите тесты изолированными и маленькими.
- Пишите понятные имена тестов.
- Покрывайте как позитивные, так и негативные сценарии.
- Используйте инструменты мокирования и читаемые ассерты.

Таким образом, ваши тесты будут чистыми, понятными и полезными для команды.


----

### **1. AAA (Arrange-Act-Assert)**

- **Подход:**
    
    - <mark class="hltr-green2">Сосредоточен на действиях (что делаем и какой результат проверяем).</mark>
    - Основной <mark class="hltr-yellow">акцент</mark> на **технической реализации**.
- **Структура:**
    
    1. **Arrange**: Подготовка данных, объектов или условий.
    2. **Act**: Выполнение тестируемого действия (метод, операция).
    3. **Assert**: Проверка результата действия.
- **Пример:**

```java
@Test
void shouldReturnSumOfTwoNumbers() {
    // Arrange
    Calculator calculator = new Calculator();
    int a = 5;
    int b = 10;

    // Act
    int result = calculator.add(a, b);

    // Assert
    assertEquals(15, result);
}

```

**Когда использовать:**

- При <mark class="hltr-red">написании</mark> **юнит-тестов** (Unit Tests).
- Для тестов, где важна структура и простота.
- <mark class="hltr-red">Когда необходимо проверить отдельный метод или класс.</mark>


### **2. Given-When-Then (BDD-стиль)**

- **Подход:**
    
    - Сосредоточен на **поведении** <mark class="hltr-yellow">системы с точки зрения пользователя.</mark>
    - Основной акцент на **бизнес-логике** и <mark class="hltr-green2">описании сценариев.</mark>
- **Структура:**
    
    1. **Given**: <mark class="hltr-blue">Указание начальных условий или контекста.</mark>
    2. **When**: <mark class="hltr-red">Определение действия или события.</mark>
    3. **Then**: <mark class="hltr-yellow">Проверка результата или изменений</mark>.
- **Пример:**

```java
@Test
void shouldReturnCorrectDiscountForPremiumUser() {
    // Given
    User user = new User("John", UserType.PREMIUM);
    DiscountService discountService = new DiscountService();

    // When
    double discount = discountService.calculateDiscount(user);

    // Then
    assertEquals(0.2, discount);
}

```

- **Когда использовать:**
    
    - При написании **BDD-тестов** (Behavior-Driven Development).
    - Для тестов, где важно описать поведение системы в понятных терминах.
    - В интеграционных тестах (Integration Tests) или end-to-end тестах.

---

### **Основные отличия:**

|Характеристика|**AAA**|**Given-When-Then**|
|---|---|---|
|**Фокус**|Техническая реализация.|Бизнес-логика и поведение.|
|**Сфера применения**|Юнит-тесты (Unit Tests).|BDD, интеграционные или e2e тесты.|
|**Читаемость**|Техническая, ориентирована на код.|Более естественный язык (поведение).|
|**Подход к описанию**|"Что я делаю?"|"Что происходит в системе?"|

---

### **Когда что лучше использовать?**

1. **AAA:**
    
    - Когда пишете **технические тесты**, например, для отдельных методов или классов.
    - Когда нужно сделать тесты максимально простыми и понятными для разработчиков.
    - Если проект не использует BDD-подход.
2. **Given-When-Then:**
    
    - Когда проект использует BDD или важно объяснить поведение системы в бизнес-терминах.
    - Для тестов, где участвуют сложные сценарии, зависящие от нескольких условий.
    - Когда тесты читают не только разработчики, но и аналитики, тестировщики или клиенты.

---

### **Комбинированный подход**

В реальных проектах часто используются обе структуры:

- Для **юнит-тестов** применяют AAA.
- Для **интеграционных** или **поведенческих тестов** — Given-When-Then.

Это помогает охватить как техническую, так и бизнес-логику, делая тесты понятными и гибкими для разных задач.


### **Похожи потому что:**

1. **Три этапа:**
    
    - Оба подхода разделяют тест на понятные шаги:
        - **AAA**: <mark class="hltr-green2">Подготовка (Arrange), выполнение (Act), проверка (Assert).</mark>
        - **Given-When-Then**: <mark class="hltr-purple">Условие (Given), действие (When), ожидание (Then).</mark>
2. **Читаемость:**
    
    - Оба подхода упрощают понимание тестов, так как обеспечивают логическую последовательность.
3. **Логика выполнения:**
    
    - Оба описывают, что **дано (контекст)**, что **делается** и что **проверяется**.

---

### **Чем отличаются:**

|**Критерий**|**AAA**|**Given-When-Then**|
|---|---|---|
|**Фокус**|Технический. Ориентирован на код и реализацию.|Поведенческий. Ориентирован на логику и сценарии.|
|**Описание**|Конкретные действия и результаты.|Сценарий поведения с акцентом на бизнес-логику.|
|**Применение**|Юнит-тесты (Unit Tests), работа с кодом.|BDD, интеграционные или e2e тесты.|
|**Целевая аудитория**|Разработчики.|Разработчики, тестировщики, бизнес-аналитики.|
|**Читаемость для "не технарей"**|Умеренная.|Высокая. Более "естественный язык".|