---
title: BuildScripts
tags:
  - Gradle
related_topics: 
created: 2024-09-23 13:08
modified: 2024-11-11T17:53:00+03:00
questions: 
notes: 
links: 
---
Секция `buildscript` в Gradle используется для указания **зависимостей и репозиториев**, которые нужны самому Gradle для выполнения сборочного процесса. Основная цель этой секции — настроить окружение, в котором будут выполняться Gradle-скрипты, включая подключение плагинов, необходимых для сборки проекта.

### Основные задачи секции `buildscript`:

1. **Подключение репозиториев** — указывает, откуда Gradle будет загружать зависимости для **самих скриптов сборки**. Это могут быть Maven-репозитории (локальные или удаленные), где находятся плагины или другие зависимости, необходимые для работы Gradle.
    
    Пример:
```java
buildscript {
    repositories {
        mavenLocal()
        mavenCentral()
    }
}

```

**Задание зависимостей (classpath)** — в секции `dependencies` можно указать зависимости (например, плагины), которые нужны для выполнения задач Gradle. Эти зависимости не относятся к приложению, а необходимы для самой сборки.

Пример:
```java
buildscript {
    dependencies {
        classpath "com.palantir.gradle.docker:gradle-docker:0.26.0"
    }
}


```

Эта строка сообщает Gradle, что для выполнения сборочного процесса ему нужно скачать и использовать плагин **Palantir Docker**.

### Когда и зачем используется `buildscript`?

1. **Подключение плагинов, которых нет по умолчанию**: Если вы хотите использовать в сборке какой-то плагин, который Gradle не знает по умолчанию (например, плагин для Docker или специальных отчетов), вам нужно указать его в `buildscript`. Это делает Gradle "осведомленным" о том, где искать плагин и как его использовать.
    
2. **Настройка репозиториев для скриптов**: Обычно репозитории для приложения указываются в секции `repositories` вне `buildscript`. Однако если сами скрипты требуют дополнительных ресурсов (например, специфических плагинов из частных репозиториев), то эти репозитории должны быть указаны в `buildscript`, чтобы Gradle знал, откуда их загрузить.
    
3. **Разделение зависимостей**: Gradle отделяет зависимости для приложения и для сборочного процесса. Плагины и инструменты для сборки указываются в `buildscript`, а зависимости для приложения — в основной части `dependencies`.

Пример работы `buildscript`:
```java
buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath "org.springframework.boot:spring-boot-gradle-plugin:2.5.0"
    }
}

apply plugin: 'org.springframework.boot'

```
### Как это работает:

1. **`buildscript.repositories`** — задает, откуда скачать зависимости для сборочного процесса (в данном случае Maven Central).
2. **`buildscript.dependencies`** — добавляет плагин Spring Boot как зависимость для самого процесса сборки.
3. **`apply plugin`** — активирует Spring Boot плагин, чтобы можно было использовать его задачи в проекте.

### Когда `buildscript` не нужен?

Если все плагины, которые вы используете, находятся в стандартных репозиториях (например, Gradle Plugin Portal), то вы можете использовать более современный синтаксис подключения плагинов через секцию `plugins`, и тогда `buildscript` не требуется:

```java
plugins {
    id 'org.springframework.boot' version '2.5.0'
}

```

### Вывод:

Секция `buildscript` нужна, чтобы указать Gradle, где найти зависимости и плагины для самого процесса сборки. Это особенно полезно для загрузки и использования плагинов, которые не включены в стандартный набор Gradle.



![[Pasted image 20240923130835.png]]



`apply plugin: 'com.palantir.docker'` — это строка в файле `build.gradle`, которая подключает плагин для работы с Docker в Gradle-проекте.

Этот плагин предоставляет набор задач и возможностей для управления Docker-контейнерами и образами непосредственно из Gradle. Плагин создан компанией Palantir, и его основная задача — упростить процесс создания, сборки, тестирования и деплоя приложений, которые упаковываются в Docker-контейнеры.

### Основные возможности плагина:

1. **Сборка Docker-образов** — позволяет определять Dockerfile и автоматизировать процесс сборки Docker-образов.
2. **Управление контейнерами** — можно запускать, останавливать и управлять Docker-контейнерами через Gradle.
3. **Публикация образов** — можно автоматизировать процесс публикации Docker-образов в Docker Registry.

### Пример использования:

- **Dockerfile** — добавляется в корень проекта или в любую другую директорию.
- **Gradle задачи** — создаются задачи типа `docker`, `dockerRun`, `dockerPush`, которые позволяют управлять образами и контейнерами.

Пример сборки Docker-образа:
```java
docker {
    name "${project.group}/${project.name}:${project.version}"
    files "Dockerfile", "build/libs/${project.name}.jar"
    buildArgs(['JAR_FILE': "build/libs/${project.name}.jar"])
}

```

Использование строки `classpath "com.palantir.gradle.docker:gradle-docker:0.26.0"` и последующее добавление плагина с помощью `apply plugin: 'com.palantir.docker'` в файле `build.gradle` необходимо для того, чтобы подключить и активировать плагин Palantir Docker в вашем Gradle-проекте. Давай разберем по шагам, зачем нужны оба этих действия:

### 1. **Зачем добавлять `classpath` в `buildscript`?**

В этом блоке происходит **загрузка плагина**. Gradle должен знать, откуда и как скачать этот плагин для последующего использования. Это как установка зависимости — мы говорим Gradle, что нужно загрузить плагин **Palantir Docker** версии **0.26.0**.

Без этой строки Gradle не знал бы, где найти плагин, и не смог бы его использовать.

### 2. **Зачем добавлять `apply plugin: 'com.palantir.docker'`?**

После того как мы загрузили плагин в `buildscript`, необходимо его **активировать**. Эта строка делает плагин доступным для использования в вашем проекте. Без этого плагин не будет подключен, даже если он был загружен на предыдущем шаге.

### Почему нужно и то, и другое?

- **`classpath`** — это этап **загрузки** плагина. Здесь Gradle узнает, где находится плагин и какую его версию использовать.
- **`apply plugin`** — это этап **активации** плагина. После загрузки мы указываем Gradle использовать функциональность плагина в текущем проекте.

### Пример с аналогией:

Представьте, что плагин — это инструмент, например, молоток.

- **`classpath`** — это действие "купить и принести молоток на стройку". Если его не сделать, у вас не будет молотка.
- **`apply plugin`** — это действие "взять молоток и начать им работать". Если его не сделать, молоток будет лежать без дела.

### Как это работает в контексте Docker:

Когда вы подключаете плагин `com.palantir.docker`:

- Вы можете автоматизировать процесс создания Docker-образов, их сборки и управления контейнерами непосредственно через задачи Gradle.
- Плагин добавляет новые задачи в Gradle, такие как `docker`, `dockerRun`, `dockerPush`, которые можно использовать в сборочном процессе.

### Итог:

- **`classpath`** — загружает плагин (делает его доступным для использования в вашем проекте).
- **`apply plugin`** — активирует плагин (включает его функциональность, например, задачи для работы с Docker).